var yT = Object.defineProperty;
var Wv = e => {
    throw TypeError(e)
}
;
var gT = (e, t, r) => t in e ? yT(e, t, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: r
}) : e[t] = r;
var St = (e, t, r) => gT(e, typeof t != "symbol" ? t + "" : t, r)
  , Ph = (e, t, r) => t.has(e) || Wv("Cannot " + r);
var _ = (e, t, r) => (Ph(e, t, "read from private field"),
r ? r.call(e) : t.get(e))
  , de = (e, t, r) => t.has(e) ? Wv("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, r)
  , J = (e, t, r, n) => (Ph(e, t, "write to private field"),
n ? n.call(e, r) : t.set(e, r),
r)
  , Pe = (e, t, r) => (Ph(e, t, "access private method"),
r);
var wc = (e, t, r, n) => ({
    set _(s) {
        J(e, t, s, r)
    },
    get _() {
        return _(e, t, n)
    }
});
function z1(e, t) {
    for (var r = 0; r < t.length; r++) {
        const n = t[r];
        if (typeof n != "string" && !Array.isArray(n)) {
            for (const s in n)
                if (s !== "default" && !(s in e)) {
                    const i = Object.getOwnPropertyDescriptor(n, s);
                    i && Object.defineProperty(e, s, i.get ? i : {
                        enumerable: !0,
                        get: () => n[s]
                    })
                }
        }
    }
    return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, {
        value: "Module"
    }))
}
(function() {
    const t = document.createElement("link").relList;
    if (t && t.supports && t.supports("modulepreload"))
        return;
    for (const s of document.querySelectorAll('link[rel="modulepreload"]'))
        n(s);
    new MutationObserver(s => {
        for (const i of s)
            if (i.type === "childList")
                for (const a of i.addedNodes)
                    a.tagName === "LINK" && a.rel === "modulepreload" && n(a)
    }
    ).observe(document, {
        childList: !0,
        subtree: !0
    });
    function r(s) {
        const i = {};
        return s.integrity && (i.integrity = s.integrity),
        s.referrerPolicy && (i.referrerPolicy = s.referrerPolicy),
        s.crossOrigin === "use-credentials" ? i.credentials = "include" : s.crossOrigin === "anonymous" ? i.credentials = "omit" : i.credentials = "same-origin",
        i
    }
    function n(s) {
        if (s.ep)
            return;
        s.ep = !0;
        const i = r(s);
        fetch(s.href, i)
    }
}
)();
var Sc = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function _y(e) {
    return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e
}
var U1 = {
    exports: {}
}
  , Df = {}
  , V1 = {
    exports: {}
}
  , je = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Hu = Symbol.for("react.element")
  , vT = Symbol.for("react.portal")
  , bT = Symbol.for("react.fragment")
  , xT = Symbol.for("react.strict_mode")
  , wT = Symbol.for("react.profiler")
  , ST = Symbol.for("react.provider")
  , kT = Symbol.for("react.context")
  , ET = Symbol.for("react.forward_ref")
  , _T = Symbol.for("react.suspense")
  , TT = Symbol.for("react.memo")
  , CT = Symbol.for("react.lazy")
  , qv = Symbol.iterator;
function PT(e) {
    return e === null || typeof e != "object" ? null : (e = qv && e[qv] || e["@@iterator"],
    typeof e == "function" ? e : null)
}
var B1 = {
    isMounted: function() {
        return !1
    },
    enqueueForceUpdate: function() {},
    enqueueReplaceState: function() {},
    enqueueSetState: function() {}
}
  , W1 = Object.assign
  , q1 = {};
function Vo(e, t, r) {
    this.props = e,
    this.context = t,
    this.refs = q1,
    this.updater = r || B1
}
Vo.prototype.isReactComponent = {};
Vo.prototype.setState = function(e, t) {
    if (typeof e != "object" && typeof e != "function" && e != null)
        throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, e, t, "setState")
}
;
Vo.prototype.forceUpdate = function(e) {
    this.updater.enqueueForceUpdate(this, e, "forceUpdate")
}
;
function H1() {}
H1.prototype = Vo.prototype;
function Ty(e, t, r) {
    this.props = e,
    this.context = t,
    this.refs = q1,
    this.updater = r || B1
}
var Cy = Ty.prototype = new H1;
Cy.constructor = Ty;
W1(Cy, Vo.prototype);
Cy.isPureReactComponent = !0;
var Hv = Array.isArray
  , Z1 = Object.prototype.hasOwnProperty
  , Py = {
    current: null
}
  , K1 = {
    key: !0,
    ref: !0,
    __self: !0,
    __source: !0
};
function Q1(e, t, r) {
    var n, s = {}, i = null, a = null;
    if (t != null)
        for (n in t.ref !== void 0 && (a = t.ref),
        t.key !== void 0 && (i = "" + t.key),
        t)
            Z1.call(t, n) && !K1.hasOwnProperty(n) && (s[n] = t[n]);
    var o = arguments.length - 2;
    if (o === 1)
        s.children = r;
    else if (1 < o) {
        for (var l = Array(o), c = 0; c < o; c++)
            l[c] = arguments[c + 2];
        s.children = l
    }
    if (e && e.defaultProps)
        for (n in o = e.defaultProps,
        o)
            s[n] === void 0 && (s[n] = o[n]);
    return {
        $$typeof: Hu,
        type: e,
        key: i,
        ref: a,
        props: s,
        _owner: Py.current
    }
}
function $T(e, t) {
    return {
        $$typeof: Hu,
        type: e.type,
        key: t,
        ref: e.ref,
        props: e.props,
        _owner: e._owner
    }
}
function $y(e) {
    return typeof e == "object" && e !== null && e.$$typeof === Hu
}
function NT(e) {
    var t = {
        "=": "=0",
        ":": "=2"
    };
    return "$" + e.replace(/[=:]/g, function(r) {
        return t[r]
    })
}
var Zv = /\/+/g;
function $h(e, t) {
    return typeof e == "object" && e !== null && e.key != null ? NT("" + e.key) : t.toString(36)
}
function id(e, t, r, n, s) {
    var i = typeof e;
    (i === "undefined" || i === "boolean") && (e = null);
    var a = !1;
    if (e === null)
        a = !0;
    else
        switch (i) {
        case "string":
        case "number":
            a = !0;
            break;
        case "object":
            switch (e.$$typeof) {
            case Hu:
            case vT:
                a = !0
            }
        }
    if (a)
        return a = e,
        s = s(a),
        e = n === "" ? "." + $h(a, 0) : n,
        Hv(s) ? (r = "",
        e != null && (r = e.replace(Zv, "$&/") + "/"),
        id(s, t, r, "", function(c) {
            return c
        })) : s != null && ($y(s) && (s = $T(s, r + (!s.key || a && a.key === s.key ? "" : ("" + s.key).replace(Zv, "$&/") + "/") + e)),
        t.push(s)),
        1;
    if (a = 0,
    n = n === "" ? "." : n + ":",
    Hv(e))
        for (var o = 0; o < e.length; o++) {
            i = e[o];
            var l = n + $h(i, o);
            a += id(i, t, r, l, s)
        }
    else if (l = PT(e),
    typeof l == "function")
        for (e = l.call(e),
        o = 0; !(i = e.next()).done; )
            i = i.value,
            l = n + $h(i, o++),
            a += id(i, t, r, l, s);
    else if (i === "object")
        throw t = String(e),
        Error("Objects are not valid as a React child (found: " + (t === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : t) + "). If you meant to render a collection of children, use an array instead.");
    return a
}
function kc(e, t, r) {
    if (e == null)
        return e;
    var n = []
      , s = 0;
    return id(e, n, "", "", function(i) {
        return t.call(r, i, s++)
    }),
    n
}
function jT(e) {
    if (e._status === -1) {
        var t = e._result;
        t = t(),
        t.then(function(r) {
            (e._status === 0 || e._status === -1) && (e._status = 1,
            e._result = r)
        }, function(r) {
            (e._status === 0 || e._status === -1) && (e._status = 2,
            e._result = r)
        }),
        e._status === -1 && (e._status = 0,
        e._result = t)
    }
    if (e._status === 1)
        return e._result.default;
    throw e._result
}
var vr = {
    current: null
}
  , ad = {
    transition: null
}
  , IT = {
    ReactCurrentDispatcher: vr,
    ReactCurrentBatchConfig: ad,
    ReactCurrentOwner: Py
};
function G1() {
    throw Error("act(...) is not supported in production builds of React.")
}
je.Children = {
    map: kc,
    forEach: function(e, t, r) {
        kc(e, function() {
            t.apply(this, arguments)
        }, r)
    },
    count: function(e) {
        var t = 0;
        return kc(e, function() {
            t++
        }),
        t
    },
    toArray: function(e) {
        return kc(e, function(t) {
            return t
        }) || []
    },
    only: function(e) {
        if (!$y(e))
            throw Error("React.Children.only expected to receive a single React element child.");
        return e
    }
};
je.Component = Vo;
je.Fragment = bT;
je.Profiler = wT;
je.PureComponent = Ty;
je.StrictMode = xT;
je.Suspense = _T;
je.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = IT;
je.act = G1;
je.cloneElement = function(e, t, r) {
    if (e == null)
        throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + e + ".");
    var n = W1({}, e.props)
      , s = e.key
      , i = e.ref
      , a = e._owner;
    if (t != null) {
        if (t.ref !== void 0 && (i = t.ref,
        a = Py.current),
        t.key !== void 0 && (s = "" + t.key),
        e.type && e.type.defaultProps)
            var o = e.type.defaultProps;
        for (l in t)
            Z1.call(t, l) && !K1.hasOwnProperty(l) && (n[l] = t[l] === void 0 && o !== void 0 ? o[l] : t[l])
    }
    var l = arguments.length - 2;
    if (l === 1)
        n.children = r;
    else if (1 < l) {
        o = Array(l);
        for (var c = 0; c < l; c++)
            o[c] = arguments[c + 2];
        n.children = o
    }
    return {
        $$typeof: Hu,
        type: e.type,
        key: s,
        ref: i,
        props: n,
        _owner: a
    }
}
;
je.createContext = function(e) {
    return e = {
        $$typeof: kT,
        _currentValue: e,
        _currentValue2: e,
        _threadCount: 0,
        Provider: null,
        Consumer: null,
        _defaultValue: null,
        _globalName: null
    },
    e.Provider = {
        $$typeof: ST,
        _context: e
    },
    e.Consumer = e
}
;
je.createElement = Q1;
je.createFactory = function(e) {
    var t = Q1.bind(null, e);
    return t.type = e,
    t
}
;
je.createRef = function() {
    return {
        current: null
    }
}
;
je.forwardRef = function(e) {
    return {
        $$typeof: ET,
        render: e
    }
}
;
je.isValidElement = $y;
je.lazy = function(e) {
    return {
        $$typeof: CT,
        _payload: {
            _status: -1,
            _result: e
        },
        _init: jT
    }
}
;
je.memo = function(e, t) {
    return {
        $$typeof: TT,
        type: e,
        compare: t === void 0 ? null : t
    }
}
;
je.startTransition = function(e) {
    var t = ad.transition;
    ad.transition = {};
    try {
        e()
    } finally {
        ad.transition = t
    }
}
;
je.unstable_act = G1;
je.useCallback = function(e, t) {
    return vr.current.useCallback(e, t)
}
;
je.useContext = function(e) {
    return vr.current.useContext(e)
}
;
je.useDebugValue = function() {}
;
je.useDeferredValue = function(e) {
    return vr.current.useDeferredValue(e)
}
;
je.useEffect = function(e, t) {
    return vr.current.useEffect(e, t)
}
;
je.useId = function() {
    return vr.current.useId()
}
;
je.useImperativeHandle = function(e, t, r) {
    return vr.current.useImperativeHandle(e, t, r)
}
;
je.useInsertionEffect = function(e, t) {
    return vr.current.useInsertionEffect(e, t)
}
;
je.useLayoutEffect = function(e, t) {
    return vr.current.useLayoutEffect(e, t)
}
;
je.useMemo = function(e, t) {
    return vr.current.useMemo(e, t)
}
;
je.useReducer = function(e, t, r) {
    return vr.current.useReducer(e, t, r)
}
;
je.useRef = function(e) {
    return vr.current.useRef(e)
}
;
je.useState = function(e) {
    return vr.current.useState(e)
}
;
je.useSyncExternalStore = function(e, t, r) {
    return vr.current.useSyncExternalStore(e, t, r)
}
;
je.useTransition = function() {
    return vr.current.useTransition()
}
;
je.version = "18.3.1";
V1.exports = je;
var g = V1.exports;
const ve = _y(g)
  , RT = z1({
    __proto__: null,
    default: ve
}, [g]);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var OT = g
  , MT = Symbol.for("react.element")
  , AT = Symbol.for("react.fragment")
  , LT = Object.prototype.hasOwnProperty
  , DT = OT.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner
  , FT = {
    key: !0,
    ref: !0,
    __self: !0,
    __source: !0
};
function Y1(e, t, r) {
    var n, s = {}, i = null, a = null;
    r !== void 0 && (i = "" + r),
    t.key !== void 0 && (i = "" + t.key),
    t.ref !== void 0 && (a = t.ref);
    for (n in t)
        LT.call(t, n) && !FT.hasOwnProperty(n) && (s[n] = t[n]);
    if (e && e.defaultProps)
        for (n in t = e.defaultProps,
        t)
            s[n] === void 0 && (s[n] = t[n]);
    return {
        $$typeof: MT,
        type: e,
        key: i,
        ref: a,
        props: s,
        _owner: DT.current
    }
}
Df.Fragment = AT;
Df.jsx = Y1;
Df.jsxs = Y1;
U1.exports = Df;
var d = U1.exports;
const zT = Symbol()
  , Ny = Symbol()
  , Pl = "a"
  , J1 = "f"
  , Kv = "p"
  , X1 = "c"
  , ew = "t"
  , jy = "h"
  , Ul = "w"
  , Iy = "o"
  , Ry = "k";
let UT = (e, t) => new Proxy(e,t);
const Nm = Object.getPrototypeOf
  , jm = new WeakMap
  , tw = e => e && (jm.has(e) ? jm.get(e) : Nm(e) === Object.prototype || Nm(e) === Array.prototype)
  , Td = e => typeof e == "object" && e !== null
  , VT = e => Object.values(Object.getOwnPropertyDescriptors(e)).some(t => !t.configurable && !t.writable)
  , BT = e => {
    if (Array.isArray(e))
        return Array.from(e);
    const t = Object.getOwnPropertyDescriptors(e);
    return Object.values(t).forEach(r => {
        r.configurable = !0
    }
    ),
    Object.create(Nm(e), t)
}
  , WT = (e, t) => {
    const r = {
        [J1]: t
    };
    let n = !1;
    const s = (o, l) => {
        if (!n) {
            let c = r[Pl].get(e);
            if (c || (c = {},
            r[Pl].set(e, c)),
            o === Ul)
                c[Ul] = !0;
            else {
                let f = c[o];
                f || (f = new Set,
                c[o] = f),
                f.add(l)
            }
        }
    }
      , i = () => {
        n = !0,
        r[Pl].delete(e)
    }
      , a = {
        get(o, l) {
            return l === Ny ? e : (s(Ry, l),
            rw(Reflect.get(o, l), r[Pl], r[X1], r[ew]))
        },
        has(o, l) {
            return l === zT ? (i(),
            !0) : (s(jy, l),
            Reflect.has(o, l))
        },
        getOwnPropertyDescriptor(o, l) {
            return s(Iy, l),
            Reflect.getOwnPropertyDescriptor(o, l)
        },
        ownKeys(o) {
            return s(Ul),
            Reflect.ownKeys(o)
        }
    };
    return t && (a.set = a.deleteProperty = () => !1),
    [a, r]
}
  , Oy = e => e[Ny] || e
  , rw = (e, t, r, n) => {
    if (!tw(e))
        return e;
    let s = n && n.get(e);
    if (!s) {
        const l = Oy(e);
        VT(l) ? s = [l, BT(l)] : s = [l],
        n == null || n.set(e, s)
    }
    const [i,a] = s;
    let o = r && r.get(i);
    return (!o || o[1][J1] !== !!a) && (o = WT(i, !!a),
    o[1][Kv] = UT(a || i, o[0]),
    r && r.set(i, o)),
    o[1][Pl] = t,
    o[1][X1] = r,
    o[1][ew] = n,
    o[1][Kv]
}
  , qT = (e, t) => {
    const r = Reflect.ownKeys(e)
      , n = Reflect.ownKeys(t);
    return r.length !== n.length || r.some( (s, i) => s !== n[i])
}
  , nw = (e, t, r, n, s=Object.is) => {
    if (s(e, t))
        return !1;
    if (!Td(e) || !Td(t))
        return !0;
    const i = r.get(Oy(e));
    if (!i)
        return !0;
    if (n) {
        if (n.get(e) === t)
            return !1;
        n.set(e, t)
    }
    let a = null;
    for (const o of i[jy] || [])
        if (a = Reflect.has(e, o) !== Reflect.has(t, o),
        a)
            return a;
    if (i[Ul] === !0) {
        if (a = qT(e, t),
        a)
            return a
    } else
        for (const o of i[Iy] || []) {
            const l = !!Reflect.getOwnPropertyDescriptor(e, o)
              , c = !!Reflect.getOwnPropertyDescriptor(t, o);
            if (a = l !== c,
            a)
                return a
        }
    for (const o of i[Ry] || [])
        if (a = nw(e[o], t[o], r, n, s),
        a)
            return a;
    if (a === null)
        throw new Error("invalid used");
    return a
}
  , HT = e => tw(e) && e[Ny] || null
  , Qv = (e, t=!0) => {
    jm.set(e, t)
}
  , ZT = (e, t, r) => {
    const n = []
      , s = new WeakSet
      , i = (a, o) => {
        var l, c, f;
        if (s.has(a))
            return;
        Td(a) && s.add(a);
        const h = Td(a) && t.get(Oy(a));
        if (h) {
            if ((l = h[jy]) === null || l === void 0 || l.forEach(m => {
                const y = `:has(${String(m)})`;
                n.push(o ? [...o, y] : [y])
            }
            ),
            h[Ul] === !0) {
                const m = ":ownKeys";
                n.push(o ? [...o, m] : [m])
            } else
                (c = h[Iy]) === null || c === void 0 || c.forEach(m => {
                    const y = `:hasOwn(${String(m)})`;
                    n.push(o ? [...o, y] : [y])
                }
                );
            (f = h[Ry]) === null || f === void 0 || f.forEach(m => {
                "value"in (Object.getOwnPropertyDescriptor(a, m) || {}) && i(a[m], o ? [...o, m] : [m])
            }
            )
        } else
            o && n.push(o)
    }
    ;
    return i(e),
    n
}
  , Cd = {}
  , My = e => typeof e == "object" && e !== null
  , KT = e => My(e) && !Ff.has(e) && (Array.isArray(e) || !(Symbol.iterator in e)) && !(e instanceof WeakMap) && !(e instanceof WeakSet) && !(e instanceof Error) && !(e instanceof Number) && !(e instanceof Date) && !(e instanceof String) && !(e instanceof RegExp) && !(e instanceof ArrayBuffer) && !(e instanceof Promise)
  , sw = (e, t) => {
    const r = Im.get(e);
    if ((r == null ? void 0 : r[0]) === t)
        return r[1];
    const n = Array.isArray(e) ? [] : Object.create(Object.getPrototypeOf(e));
    return Qv(n, !0),
    Im.set(e, [t, n]),
    Reflect.ownKeys(e).forEach(s => {
        if (Object.getOwnPropertyDescriptor(n, s))
            return;
        const i = Reflect.get(e, s)
          , {enumerable: a} = Reflect.getOwnPropertyDescriptor(e, s)
          , o = {
            value: i,
            enumerable: a,
            configurable: !0
        };
        if (Ff.has(i))
            Qv(i, !1);
        else if (li.has(i)) {
            const [l,c] = li.get(i);
            o.value = sw(l, c())
        }
        Object.defineProperty(n, s, o)
    }
    ),
    Object.preventExtensions(n)
}
  , QT = (e, t, r, n) => ({
    deleteProperty(s, i) {
        const a = Reflect.get(s, i);
        r(i);
        const o = Reflect.deleteProperty(s, i);
        return o && n(["delete", [i], a]),
        o
    },
    set(s, i, a, o) {
        const l = !e() && Reflect.has(s, i)
          , c = Reflect.get(s, i, o);
        if (l && (Gv(c, a) || nu.has(a) && Gv(c, nu.get(a))))
            return !0;
        r(i),
        My(a) && (a = HT(a) || a);
        const f = !li.has(a) && YT(a) ? ya(a) : a;
        return t(i, f),
        Reflect.set(s, i, f, o),
        n(["set", [i], a, c]),
        !0
    }
})
  , li = new WeakMap
  , Ff = new WeakSet
  , Im = new WeakMap
  , $l = [1, 1]
  , nu = new WeakMap;
let Gv = Object.is
  , GT = (e, t) => new Proxy(e,t)
  , YT = KT
  , JT = sw
  , XT = QT;
function ya(e={}) {
    if (!My(e))
        throw new Error("object required");
    const t = nu.get(e);
    if (t)
        return t;
    let r = $l[0];
    const n = new Set
      , s = (w, v=++$l[0]) => {
        r !== v && (r = v,
        n.forEach(p => p(w, v)))
    }
    ;
    let i = $l[1];
    const a = (w=++$l[1]) => (i !== w && !n.size && (i = w,
    l.forEach( ([v]) => {
        const p = v[1](w);
        p > r && (r = p)
    }
    )),
    r)
      , o = w => (v, p) => {
        const S = [...v];
        S[1] = [w, ...S[1]],
        s(S, p)
    }
      , l = new Map
      , c = (w, v) => {
        const p = !Ff.has(v) && li.get(v);
        if (p) {
            if ((Cd ? "production" : void 0) !== "production" && l.has(w))
                throw new Error("prop listener already exists");
            if (n.size) {
                const S = p[2](o(w));
                l.set(w, [p, S])
            } else
                l.set(w, [p])
        }
    }
      , f = w => {
        var v;
        const p = l.get(w);
        p && (l.delete(w),
        (v = p[1]) == null || v.call(p))
    }
      , h = w => (n.add(w),
    n.size === 1 && l.forEach( ([p,S], P) => {
        if ((Cd ? "production" : void 0) !== "production" && S)
            throw new Error("remove already exists");
        const j = p[2](o(P));
        l.set(P, [p, j])
    }
    ),
    () => {
        n.delete(w),
        n.size === 0 && l.forEach( ([p,S], P) => {
            S && (S(),
            l.set(P, [p]))
        }
        )
    }
    );
    let m = !0;
    const y = XT( () => m, c, f, s)
      , k = GT(e, y);
    nu.set(e, k);
    const x = [e, a, h];
    return li.set(k, x),
    Reflect.ownKeys(e).forEach(w => {
        const v = Object.getOwnPropertyDescriptor(e, w);
        "value"in v && v.writable && (k[w] = e[w])
    }
    ),
    m = !1,
    k
}
function iw(e, t, r) {
    const n = li.get(e);
    (Cd ? "production" : void 0) !== "production" && !n && console.warn("Please use proxy object");
    let s;
    const i = []
      , a = n[2];
    let o = !1;
    const c = a(f => {
        i.push(f),
        s || (s = Promise.resolve().then( () => {
            s = void 0,
            o && t(i.splice(0))
        }
        ))
    }
    );
    return o = !0,
    () => {
        o = !1,
        c()
    }
}
function Yv(e) {
    const t = li.get(e);
    (Cd ? "production" : void 0) !== "production" && !t && console.warn("Please use proxy object");
    const [r,n] = t;
    return JT(r, n())
}
function eC() {
    return {
        proxyStateMap: li,
        refSet: Ff,
        snapCache: Im,
        versionHolder: $l,
        proxyCache: nu
    }
}
const tC = {}
  , rC = (e, t) => {
    const r = g.useRef(void 0);
    g.useEffect( () => {
        r.current = ZT(e, t)
    }
    ),
    g.useDebugValue(r.current)
}
  , nC = rC
  , sC = new WeakMap;
function Ay(e, t) {
    const n = g.useMemo( () => e && new WeakMap, [e])
      , s = g.useRef(void 0);
    let i = !0;
    const a = g.useSyncExternalStore(g.useCallback(l => {
        const c = iw(e, l);
        return l(),
        c
    }
    , [e, void 0]), () => {
        const l = Yv(e);
        try {
            if (!i && s.current && !nw(s.current, l, n, new WeakMap))
                return s.current
        } catch {}
        return l
    }
    , () => Yv(e));
    i = !1,
    g.useLayoutEffect( () => {
        s.current = a
    }
    ),
    (tC ? "production" : void 0) !== "production" && nC(a, n);
    const o = g.useMemo( () => new WeakMap, []);
    return rw(a, n, o, sC)
}
const {proxyStateMap: iC, snapCache: aC} = eC()
  , Ec = e => typeof e == "object" ? ya({
    x: e
}).x : e
  , _c = e => iC.has(e);
function Wt(e) {
    const t = []
      , r = new Map;
    let n = 0;
    const s = new WeakMap
      , i = () => {
        const c = aC.get(o)
          , f = c == null ? void 0 : c[1];
        if (f && !s.has(f)) {
            const h = new Map(r);
            s.set(f, h)
        }
    }
      , a = c => s.get(c) || r;
    if (e) {
        if (typeof e[Symbol.iterator] != "function")
            throw new TypeError("not iterable");
        for (const c of e)
            if (!r.has(c)) {
                const f = Ec(c);
                r.set(f, n),
                t[n++] = f
            }
    }
    const o = {
        data: t,
        index: n,
        epoch: 0,
        get size() {
            return _c(this) || i(),
            r.size
        },
        has(c) {
            const f = a(this)
              , h = Ec(c);
            return this.epoch,
            f.has(h)
        },
        add(c) {
            if (!_c(this))
                throw new Error("Cannot perform mutations on a snapshot");
            const f = Ec(c);
            return r.has(f) || (r.set(f, this.index),
            this.data[this.index++] = f,
            this.epoch++),
            this
        },
        delete(c) {
            if (!_c(this))
                throw new Error("Cannot perform mutations on a snapshot");
            const f = Ec(c)
              , h = r.get(f);
            return h === void 0 ? !1 : (delete this.data[h],
            r.delete(f),
            this.epoch++,
            !0)
        },
        clear() {
            if (!_c(this))
                throw new Error("Cannot perform mutations on a snapshot");
            this.data.length = 0,
            this.index = 0,
            this.epoch++,
            r.clear()
        },
        forEach(c) {
            this.epoch,
            a(this).forEach(h => {
                c(this.data[h], this.data[h], this)
            }
            )
        },
        *values() {
            this.epoch;
            const c = a(this);
            for (const f of c.values())
                yield this.data[f]
        },
        keys() {
            return this.epoch,
            this.values()
        },
        *entries() {
            this.epoch;
            const c = a(this);
            for (const f of c.values()) {
                const h = this.data[f];
                yield[h, h]
            }
        },
        toJSON() {
            return new Set(this.values())
        },
        [Symbol.iterator]() {
            return this.values()
        },
        get[Symbol.toStringTag]() {
            return "Set"
        },
        intersection(c) {
            this.epoch;
            const f = Wt(c)
              , h = Wt();
            for (const m of this.values())
                f.has(m) && h.add(m);
            return Wt(h)
        },
        union(c) {
            this.epoch;
            const f = Wt()
              , h = Wt(c);
            for (const m of this.values())
                f.add(m);
            for (const m of h)
                f.add(m);
            return Wt(f)
        },
        difference(c) {
            this.epoch;
            const f = Wt()
              , h = Wt(c);
            for (const m of this.values())
                h.has(m) || f.add(m);
            return Wt(f)
        },
        symmetricDifference(c) {
            this.epoch;
            const f = Wt()
              , h = Wt(c);
            for (const m of this.values())
                h.has(m) || f.add(m);
            for (const m of h.values())
                this.has(m) || f.add(m);
            return Wt(f)
        },
        isSubsetOf(c) {
            this.epoch;
            const f = Wt(c);
            return this.size <= c.size && [...this.values()].every(h => f.has(h))
        },
        isSupersetOf(c) {
            this.epoch;
            const f = Wt(c);
            return this.size >= c.size && [...f].every(h => this.has(h))
        },
        isDisjointFrom(c) {
            this.epoch;
            const f = Wt(c);
            return [...this.values()].every(h => !f.has(h))
        }
    }
      , l = ya(o);
    return Object.defineProperties(l, {
        size: {
            enumerable: !1
        },
        data: {
            enumerable: !1
        },
        index: {
            enumerable: !1
        },
        epoch: {
            enumerable: !1
        },
        toJSON: {
            enumerable: !1
        }
    }),
    Object.seal(l),
    l
}
function ra(e) {
    return {
        ok: !0,
        value: e
    }
}
function Rm(e) {
    return {
        ok: !1,
        error: e
    }
}
function Om(e) {
    if (!e)
        throw new Error("Expected Ok result, but got undefined");
    if (!e.ok)
        throw new Error(`Expected Ok result, but got Err: ${e.error}`)
}
function oC(e, t="Value") {
    if (e == null)
        throw new Error(`${t} is not defined`)
}
function Cn(e) {
    const t = new Map;
    return async (...r) => {
        const n = JSON.stringify(r);
        let s = t.get(n);
        if (!s) {
            s = e(...r);
            const i = await s;
            return t.delete(n),
            i
        }
        return s
    }
}
function aw() {
    const e = "0123456789abcdef";
    let t = "";
    for (let r = 0; r < 36; r++) {
        const n = Math.random() * 16 | 0;
        r === 8 || r === 13 || r === 18 || r === 23 ? t += "-" : r === 14 ? t += "4" : r === 19 ? t += e[n & 3 | 8] : t += e[n]
    }
    return t
}
const ks = new WeakMap
  , ji = new WeakMap
  , ts = new WeakMap;
var lC = {};
const Pd = Symbol("anyProducer")
  , Jv = Promise.resolve()
  , $d = Symbol("listenerAdded")
  , Nd = Symbol("listenerRemoved");
let jd = !1
  , Nh = !1;
const Id = e => typeof e == "string" || typeof e == "symbol" || typeof e == "number";
function Ca(e) {
    if (!Id(e))
        throw new TypeError("`eventName` must be a string, symbol, or number")
}
function Tc(e) {
    if (typeof e != "function")
        throw new TypeError("listener must be a function")
}
function Pa(e, t) {
    const r = ji.get(e);
    if (r.has(t))
        return r.get(t)
}
function Vl(e, t) {
    const r = Id(t) ? t : Pd
      , n = ts.get(e);
    if (n.has(r))
        return n.get(r)
}
function uC(e, t, r) {
    const n = ts.get(e);
    if (n.has(t))
        for (const s of n.get(t))
            s.enqueue(r);
    if (n.has(Pd)) {
        const s = Promise.all([t, r]);
        for (const i of n.get(Pd))
            i.enqueue(s)
    }
}
function Xv(e, t) {
    t = Array.isArray(t) ? t : [t];
    let r = !1
      , n = () => {}
      , s = [];
    const i = {
        enqueue(a) {
            s.push(a),
            n()
        },
        finish() {
            r = !0,
            n()
        }
    };
    for (const a of t) {
        let o = Vl(e, a);
        o || (o = new Set,
        ts.get(e).set(a, o)),
        o.add(i)
    }
    return {
        async next() {
            return s ? s.length === 0 ? r ? (s = void 0,
            this.next()) : (await new Promise(a => {
                n = a
            }
            ),
            this.next()) : {
                done: !1,
                value: await s.shift()
            } : {
                done: !0
            }
        },
        async return(a) {
            s = void 0;
            for (const o of t) {
                const l = Vl(e, o);
                l && (l.delete(i),
                l.size === 0 && ts.get(e).delete(o))
            }
            return n(),
            arguments.length > 0 ? {
                done: !0,
                value: await a
            } : {
                done: !0
            }
        },
        [Symbol.asyncIterator]() {
            return this
        }
    }
}
function e0(e) {
    if (e === void 0)
        return t0;
    if (!Array.isArray(e))
        throw new TypeError("`methodNames` must be an array of strings");
    for (const t of e)
        if (!t0.includes(t))
            throw typeof t != "string" ? new TypeError("`methodNames` element must be a string") : new Error(`${t} is not Emittery method`);
    return e
}
const Aa = e => e === $d || e === Nd;
function Cc(e, t, r) {
    if (Aa(t))
        try {
            jd = !0,
            e.emit(t, r)
        } finally {
            jd = !1
        }
}
class na {
    static mixin(t, r) {
        return r = e0(r),
        n => {
            if (typeof n != "function")
                throw new TypeError("`target` must be function");
            for (const a of r)
                if (n.prototype[a] !== void 0)
                    throw new Error(`The property \`${a}\` already exists on \`target\``);
            function s() {
                return Object.defineProperty(this, t, {
                    enumerable: !1,
                    value: new na
                }),
                this[t]
            }
            Object.defineProperty(n.prototype, t, {
                enumerable: !1,
                get: s
            });
            const i = a => function(...o) {
                return this[t][a](...o)
            }
            ;
            for (const a of r)
                Object.defineProperty(n.prototype, a, {
                    enumerable: !1,
                    value: i(a)
                });
            return n
        }
    }
    static get isDebugEnabled() {
        if (typeof lC != "object")
            return Nh;
        const {env: t} = globalThis.process ?? {
            env: {}
        };
        return t.DEBUG === "emittery" || t.DEBUG === "*" || Nh
    }
    static set isDebugEnabled(t) {
        Nh = t
    }
    constructor(t={}) {
        ks.set(this, new Set),
        ji.set(this, new Map),
        ts.set(this, new Map),
        ts.get(this).set(Pd, new Set),
        this.debug = t.debug ?? {},
        this.debug.enabled === void 0 && (this.debug.enabled = !1),
        this.debug.logger || (this.debug.logger = (r, n, s, i) => {
            try {
                i = JSON.stringify(i)
            } catch {
                i = `Object with the following keys failed to stringify: ${Object.keys(i).join(",")}`
            }
            (typeof s == "symbol" || typeof s == "number") && (s = s.toString());
            const a = new Date
              , o = `${a.getHours()}:${a.getMinutes()}:${a.getSeconds()}.${a.getMilliseconds()}`;
            console.log(`[${o}][emittery:${r}][${n}] Event Name: ${s}
	data: ${i}`)
        }
        )
    }
    logIfDebugEnabled(t, r, n) {
        (na.isDebugEnabled || this.debug.enabled) && this.debug.logger(t, this.debug.name, r, n)
    }
    on(t, r, {signal: n}={}) {
        Tc(r),
        t = Array.isArray(t) ? t : [t];
        for (const i of t) {
            Ca(i);
            let a = Pa(this, i);
            a || (a = new Set,
            ji.get(this).set(i, a)),
            a.add(r),
            this.logIfDebugEnabled("subscribe", i, void 0),
            Aa(i) || Cc(this, $d, {
                eventName: i,
                listener: r
            })
        }
        const s = () => {
            this.off(t, r),
            n == null || n.removeEventListener("abort", s)
        }
        ;
        return n == null || n.addEventListener("abort", s, {
            once: !0
        }),
        n != null && n.aborted && s(),
        s
    }
    off(t, r) {
        Tc(r),
        t = Array.isArray(t) ? t : [t];
        for (const n of t) {
            Ca(n);
            const s = Pa(this, n);
            s && (s.delete(r),
            s.size === 0 && ji.get(this).delete(n)),
            this.logIfDebugEnabled("unsubscribe", n, void 0),
            Aa(n) || Cc(this, Nd, {
                eventName: n,
                listener: r
            })
        }
    }
    once(t) {
        let r;
        const n = new Promise(s => {
            r = this.on(t, i => {
                r(),
                s(i)
            }
            )
        }
        );
        return n.off = r,
        n
    }
    events(t) {
        t = Array.isArray(t) ? t : [t];
        for (const r of t)
            Ca(r);
        return Xv(this, t)
    }
    async emit(t, r) {
        if (Ca(t),
        Aa(t) && !jd)
            throw new TypeError("`eventName` cannot be meta event `listenerAdded` or `listenerRemoved`");
        this.logIfDebugEnabled("emit", t, r),
        uC(this, t, r);
        const n = Pa(this, t) ?? new Set
          , s = ks.get(this)
          , i = [...n]
          , a = Aa(t) ? [] : [...s];
        await Jv,
        await Promise.all([...i.map(async o => {
            if (n.has(o))
                return o(r)
        }
        ), ...a.map(async o => {
            if (s.has(o))
                return o(t, r)
        }
        )])
    }
    async emitSerial(t, r) {
        if (Ca(t),
        Aa(t) && !jd)
            throw new TypeError("`eventName` cannot be meta event `listenerAdded` or `listenerRemoved`");
        this.logIfDebugEnabled("emitSerial", t, r);
        const n = Pa(this, t) ?? new Set
          , s = ks.get(this)
          , i = [...n]
          , a = [...s];
        await Jv;
        for (const o of i)
            n.has(o) && await o(r);
        for (const o of a)
            s.has(o) && await o(t, r)
    }
    onAny(t, {signal: r}={}) {
        Tc(t),
        this.logIfDebugEnabled("subscribeAny", void 0, void 0),
        ks.get(this).add(t),
        Cc(this, $d, {
            listener: t
        });
        const n = () => {
            this.offAny(t),
            r == null || r.removeEventListener("abort", n)
        }
        ;
        return r == null || r.addEventListener("abort", n, {
            once: !0
        }),
        r != null && r.aborted && n(),
        n
    }
    anyEvent() {
        return Xv(this)
    }
    offAny(t) {
        Tc(t),
        this.logIfDebugEnabled("unsubscribeAny", void 0, void 0),
        Cc(this, Nd, {
            listener: t
        }),
        ks.get(this).delete(t)
    }
    clearListeners(t) {
        t = Array.isArray(t) ? t : [t];
        for (const r of t)
            if (this.logIfDebugEnabled("clear", r, void 0),
            Id(r)) {
                const n = Pa(this, r);
                n && n.clear();
                const s = Vl(this, r);
                if (s) {
                    for (const i of s)
                        i.finish();
                    s.clear()
                }
            } else {
                ks.get(this).clear();
                for (const [n,s] of ji.get(this).entries())
                    s.clear(),
                    ji.get(this).delete(n);
                for (const [n,s] of ts.get(this).entries()) {
                    for (const i of s)
                        i.finish();
                    s.clear(),
                    ts.get(this).delete(n)
                }
            }
    }
    listenerCount(t) {
        var n, s, i;
        t = Array.isArray(t) ? t : [t];
        let r = 0;
        for (const a of t) {
            if (Id(a)) {
                r += ks.get(this).size + (((n = Pa(this, a)) == null ? void 0 : n.size) ?? 0) + (((s = Vl(this, a)) == null ? void 0 : s.size) ?? 0) + (((i = Vl(this)) == null ? void 0 : i.size) ?? 0);
                continue
            }
            a !== void 0 && Ca(a),
            r += ks.get(this).size;
            for (const o of ji.get(this).values())
                r += o.size;
            for (const o of ts.get(this).values())
                r += o.size
        }
        return r
    }
    bindMethods(t, r) {
        if (typeof t != "object" || t === null)
            throw new TypeError("`target` must be an object");
        r = e0(r);
        for (const n of r) {
            if (t[n] !== void 0)
                throw new Error(`The property \`${n}\` already exists on \`target\``);
            Object.defineProperty(t, n, {
                enumerable: !1,
                value: this[n].bind(this)
            })
        }
    }
}
const t0 = Object.getOwnPropertyNames(na.prototype).filter(e => e !== "constructor");
Object.defineProperty(na, "listenerAdded", {
    value: $d,
    writable: !1,
    enumerable: !0,
    configurable: !1
});
Object.defineProperty(na, "listenerRemoved", {
    value: Nd,
    writable: !1,
    enumerable: !0,
    configurable: !1
});
var Oe;
(function(e) {
    e.assertEqual = s => s;
    function t(s) {}
    e.assertIs = t;
    function r(s) {
        throw new Error
    }
    e.assertNever = r,
    e.arrayToEnum = s => {
        const i = {};
        for (const a of s)
            i[a] = a;
        return i
    }
    ,
    e.getValidEnumValues = s => {
        const i = e.objectKeys(s).filter(o => typeof s[s[o]] != "number")
          , a = {};
        for (const o of i)
            a[o] = s[o];
        return e.objectValues(a)
    }
    ,
    e.objectValues = s => e.objectKeys(s).map(function(i) {
        return s[i]
    }),
    e.objectKeys = typeof Object.keys == "function" ? s => Object.keys(s) : s => {
        const i = [];
        for (const a in s)
            Object.prototype.hasOwnProperty.call(s, a) && i.push(a);
        return i
    }
    ,
    e.find = (s, i) => {
        for (const a of s)
            if (i(a))
                return a
    }
    ,
    e.isInteger = typeof Number.isInteger == "function" ? s => Number.isInteger(s) : s => typeof s == "number" && isFinite(s) && Math.floor(s) === s;
    function n(s, i=" | ") {
        return s.map(a => typeof a == "string" ? `'${a}'` : a).join(i)
    }
    e.joinValues = n,
    e.jsonStringifyReplacer = (s, i) => typeof i == "bigint" ? i.toString() : i
}
)(Oe || (Oe = {}));
var Mm;
(function(e) {
    e.mergeShapes = (t, r) => ({
        ...t,
        ...r
    })
}
)(Mm || (Mm = {}));
const X = Oe.arrayToEnum(["string", "nan", "number", "integer", "float", "boolean", "date", "bigint", "symbol", "function", "undefined", "null", "array", "object", "unknown", "promise", "void", "never", "map", "set"])
  , Yn = e => {
    switch (typeof e) {
    case "undefined":
        return X.undefined;
    case "string":
        return X.string;
    case "number":
        return isNaN(e) ? X.nan : X.number;
    case "boolean":
        return X.boolean;
    case "function":
        return X.function;
    case "bigint":
        return X.bigint;
    case "symbol":
        return X.symbol;
    case "object":
        return Array.isArray(e) ? X.array : e === null ? X.null : e.then && typeof e.then == "function" && e.catch && typeof e.catch == "function" ? X.promise : typeof Map < "u" && e instanceof Map ? X.map : typeof Set < "u" && e instanceof Set ? X.set : typeof Date < "u" && e instanceof Date ? X.date : X.object;
    default:
        return X.unknown
    }
}
  , U = Oe.arrayToEnum(["invalid_type", "invalid_literal", "custom", "invalid_union", "invalid_union_discriminator", "invalid_enum_value", "unrecognized_keys", "invalid_arguments", "invalid_return_type", "invalid_date", "invalid_string", "too_small", "too_big", "invalid_intersection_types", "not_multiple_of", "not_finite"])
  , cC = e => JSON.stringify(e, null, 2).replace(/"([^"]+)":/g, "$1:");
class Ar extends Error {
    get errors() {
        return this.issues
    }
    constructor(t) {
        super(),
        this.issues = [],
        this.addIssue = n => {
            this.issues = [...this.issues, n]
        }
        ,
        this.addIssues = (n=[]) => {
            this.issues = [...this.issues, ...n]
        }
        ;
        const r = new.target.prototype;
        Object.setPrototypeOf ? Object.setPrototypeOf(this, r) : this.__proto__ = r,
        this.name = "ZodError",
        this.issues = t
    }
    format(t) {
        const r = t || function(i) {
            return i.message
        }
          , n = {
            _errors: []
        }
          , s = i => {
            for (const a of i.issues)
                if (a.code === "invalid_union")
                    a.unionErrors.map(s);
                else if (a.code === "invalid_return_type")
                    s(a.returnTypeError);
                else if (a.code === "invalid_arguments")
                    s(a.argumentsError);
                else if (a.path.length === 0)
                    n._errors.push(r(a));
                else {
                    let o = n
                      , l = 0;
                    for (; l < a.path.length; ) {
                        const c = a.path[l];
                        l === a.path.length - 1 ? (o[c] = o[c] || {
                            _errors: []
                        },
                        o[c]._errors.push(r(a))) : o[c] = o[c] || {
                            _errors: []
                        },
                        o = o[c],
                        l++
                    }
                }
        }
        ;
        return s(this),
        n
    }
    static assert(t) {
        if (!(t instanceof Ar))
            throw new Error(`Not a ZodError: ${t}`)
    }
    toString() {
        return this.message
    }
    get message() {
        return JSON.stringify(this.issues, Oe.jsonStringifyReplacer, 2)
    }
    get isEmpty() {
        return this.issues.length === 0
    }
    flatten(t=r => r.message) {
        const r = {}
          , n = [];
        for (const s of this.issues)
            s.path.length > 0 ? (r[s.path[0]] = r[s.path[0]] || [],
            r[s.path[0]].push(t(s))) : n.push(t(s));
        return {
            formErrors: n,
            fieldErrors: r
        }
    }
    get formErrors() {
        return this.flatten()
    }
}
Ar.create = e => new Ar(e);
const Po = (e, t) => {
    let r;
    switch (e.code) {
    case U.invalid_type:
        e.received === X.undefined ? r = "Required" : r = `Expected ${e.expected}, received ${e.received}`;
        break;
    case U.invalid_literal:
        r = `Invalid literal value, expected ${JSON.stringify(e.expected, Oe.jsonStringifyReplacer)}`;
        break;
    case U.unrecognized_keys:
        r = `Unrecognized key(s) in object: ${Oe.joinValues(e.keys, ", ")}`;
        break;
    case U.invalid_union:
        r = "Invalid input";
        break;
    case U.invalid_union_discriminator:
        r = `Invalid discriminator value. Expected ${Oe.joinValues(e.options)}`;
        break;
    case U.invalid_enum_value:
        r = `Invalid enum value. Expected ${Oe.joinValues(e.options)}, received '${e.received}'`;
        break;
    case U.invalid_arguments:
        r = "Invalid function arguments";
        break;
    case U.invalid_return_type:
        r = "Invalid function return type";
        break;
    case U.invalid_date:
        r = "Invalid date";
        break;
    case U.invalid_string:
        typeof e.validation == "object" ? "includes"in e.validation ? (r = `Invalid input: must include "${e.validation.includes}"`,
        typeof e.validation.position == "number" && (r = `${r} at one or more positions greater than or equal to ${e.validation.position}`)) : "startsWith"in e.validation ? r = `Invalid input: must start with "${e.validation.startsWith}"` : "endsWith"in e.validation ? r = `Invalid input: must end with "${e.validation.endsWith}"` : Oe.assertNever(e.validation) : e.validation !== "regex" ? r = `Invalid ${e.validation}` : r = "Invalid";
        break;
    case U.too_small:
        e.type === "array" ? r = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "more than"} ${e.minimum} element(s)` : e.type === "string" ? r = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "over"} ${e.minimum} character(s)` : e.type === "number" ? r = `Number must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${e.minimum}` : e.type === "date" ? r = `Date must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(e.minimum))}` : r = "Invalid input";
        break;
    case U.too_big:
        e.type === "array" ? r = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "less than"} ${e.maximum} element(s)` : e.type === "string" ? r = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "under"} ${e.maximum} character(s)` : e.type === "number" ? r = `Number must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "bigint" ? r = `BigInt must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "date" ? r = `Date must be ${e.exact ? "exactly" : e.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(e.maximum))}` : r = "Invalid input";
        break;
    case U.custom:
        r = "Invalid input";
        break;
    case U.invalid_intersection_types:
        r = "Intersection results could not be merged";
        break;
    case U.not_multiple_of:
        r = `Number must be a multiple of ${e.multipleOf}`;
        break;
    case U.not_finite:
        r = "Number must be finite";
        break;
    default:
        r = t.defaultError,
        Oe.assertNever(e)
    }
    return {
        message: r
    }
}
;
let ow = Po;
function dC(e) {
    ow = e
}
function Rd() {
    return ow
}
const Od = e => {
    const {data: t, path: r, errorMaps: n, issueData: s} = e
      , i = [...r, ...s.path || []]
      , a = {
        ...s,
        path: i
    };
    if (s.message !== void 0)
        return {
            ...s,
            path: i,
            message: s.message
        };
    let o = "";
    const l = n.filter(c => !!c).slice().reverse();
    for (const c of l)
        o = c(a, {
            data: t,
            defaultError: o
        }).message;
    return {
        ...s,
        path: i,
        message: o
    }
}
  , fC = [];
function K(e, t) {
    const r = Rd()
      , n = Od({
        issueData: t,
        data: e.data,
        path: e.path,
        errorMaps: [e.common.contextualErrorMap, e.schemaErrorMap, r, r === Po ? void 0 : Po].filter(s => !!s)
    });
    e.common.issues.push(n)
}
class nr {
    constructor() {
        this.value = "valid"
    }
    dirty() {
        this.value === "valid" && (this.value = "dirty")
    }
    abort() {
        this.value !== "aborted" && (this.value = "aborted")
    }
    static mergeArray(t, r) {
        const n = [];
        for (const s of r) {
            if (s.status === "aborted")
                return ye;
            s.status === "dirty" && t.dirty(),
            n.push(s.value)
        }
        return {
            status: t.value,
            value: n
        }
    }
    static async mergeObjectAsync(t, r) {
        const n = [];
        for (const s of r) {
            const i = await s.key
              , a = await s.value;
            n.push({
                key: i,
                value: a
            })
        }
        return nr.mergeObjectSync(t, n)
    }
    static mergeObjectSync(t, r) {
        const n = {};
        for (const s of r) {
            const {key: i, value: a} = s;
            if (i.status === "aborted" || a.status === "aborted")
                return ye;
            i.status === "dirty" && t.dirty(),
            a.status === "dirty" && t.dirty(),
            i.value !== "__proto__" && (typeof a.value < "u" || s.alwaysSet) && (n[i.value] = a.value)
        }
        return {
            status: t.value,
            value: n
        }
    }
}
const ye = Object.freeze({
    status: "aborted"
})
  , Va = e => ({
    status: "dirty",
    value: e
})
  , gr = e => ({
    status: "valid",
    value: e
})
  , Am = e => e.status === "aborted"
  , Lm = e => e.status === "dirty"
  , sa = e => e.status === "valid"
  , su = e => typeof Promise < "u" && e instanceof Promise;
function Md(e, t, r, n) {
    if (typeof t == "function" ? e !== t || !0 : !t.has(e))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return t.get(e)
}
function lw(e, t, r, n, s) {
    if (typeof t == "function" ? e !== t || !0 : !t.has(e))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return t.set(e, r),
    r
}
var ie;
(function(e) {
    e.errToObj = t => typeof t == "string" ? {
        message: t
    } : t || {},
    e.toString = t => typeof t == "string" ? t : t == null ? void 0 : t.message
}
)(ie || (ie = {}));
var Nl, jl;
class Vn {
    constructor(t, r, n, s) {
        this._cachedPath = [],
        this.parent = t,
        this.data = r,
        this._path = n,
        this._key = s
    }
    get path() {
        return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)),
        this._cachedPath
    }
}
const r0 = (e, t) => {
    if (sa(t))
        return {
            success: !0,
            data: t.value
        };
    if (!e.common.issues.length)
        throw new Error("Validation failed but no issues detected.");
    return {
        success: !1,
        get error() {
            if (this._error)
                return this._error;
            const r = new Ar(e.common.issues);
            return this._error = r,
            this._error
        }
    }
}
;
function Te(e) {
    if (!e)
        return {};
    const {errorMap: t, invalid_type_error: r, required_error: n, description: s} = e;
    if (t && (r || n))
        throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    return t ? {
        errorMap: t,
        description: s
    } : {
        errorMap: (a, o) => {
            var l, c;
            const {message: f} = e;
            return a.code === "invalid_enum_value" ? {
                message: f ?? o.defaultError
            } : typeof o.data > "u" ? {
                message: (l = f ?? n) !== null && l !== void 0 ? l : o.defaultError
            } : a.code !== "invalid_type" ? {
                message: o.defaultError
            } : {
                message: (c = f ?? r) !== null && c !== void 0 ? c : o.defaultError
            }
        }
        ,
        description: s
    }
}
class $e {
    get description() {
        return this._def.description
    }
    _getType(t) {
        return Yn(t.data)
    }
    _getOrReturnCtx(t, r) {
        return r || {
            common: t.parent.common,
            data: t.data,
            parsedType: Yn(t.data),
            schemaErrorMap: this._def.errorMap,
            path: t.path,
            parent: t.parent
        }
    }
    _processInputParams(t) {
        return {
            status: new nr,
            ctx: {
                common: t.parent.common,
                data: t.data,
                parsedType: Yn(t.data),
                schemaErrorMap: this._def.errorMap,
                path: t.path,
                parent: t.parent
            }
        }
    }
    _parseSync(t) {
        const r = this._parse(t);
        if (su(r))
            throw new Error("Synchronous parse encountered promise.");
        return r
    }
    _parseAsync(t) {
        const r = this._parse(t);
        return Promise.resolve(r)
    }
    parse(t, r) {
        const n = this.safeParse(t, r);
        if (n.success)
            return n.data;
        throw n.error
    }
    safeParse(t, r) {
        var n;
        const s = {
            common: {
                issues: [],
                async: (n = r == null ? void 0 : r.async) !== null && n !== void 0 ? n : !1,
                contextualErrorMap: r == null ? void 0 : r.errorMap
            },
            path: (r == null ? void 0 : r.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data: t,
            parsedType: Yn(t)
        }
          , i = this._parseSync({
            data: t,
            path: s.path,
            parent: s
        });
        return r0(s, i)
    }
    "~validate"(t) {
        var r, n;
        const s = {
            common: {
                issues: [],
                async: !!this["~standard"].async
            },
            path: [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data: t,
            parsedType: Yn(t)
        };
        if (!this["~standard"].async)
            try {
                const i = this._parseSync({
                    data: t,
                    path: [],
                    parent: s
                });
                return sa(i) ? {
                    value: i.value
                } : {
                    issues: s.common.issues
                }
            } catch (i) {
                !((n = (r = i == null ? void 0 : i.message) === null || r === void 0 ? void 0 : r.toLowerCase()) === null || n === void 0) && n.includes("encountered") && (this["~standard"].async = !0),
                s.common = {
                    issues: [],
                    async: !0
                }
            }
        return this._parseAsync({
            data: t,
            path: [],
            parent: s
        }).then(i => sa(i) ? {
            value: i.value
        } : {
            issues: s.common.issues
        })
    }
    async parseAsync(t, r) {
        const n = await this.safeParseAsync(t, r);
        if (n.success)
            return n.data;
        throw n.error
    }
    async safeParseAsync(t, r) {
        const n = {
            common: {
                issues: [],
                contextualErrorMap: r == null ? void 0 : r.errorMap,
                async: !0
            },
            path: (r == null ? void 0 : r.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data: t,
            parsedType: Yn(t)
        }
          , s = this._parse({
            data: t,
            path: n.path,
            parent: n
        })
          , i = await (su(s) ? s : Promise.resolve(s));
        return r0(n, i)
    }
    refine(t, r) {
        const n = s => typeof r == "string" || typeof r > "u" ? {
            message: r
        } : typeof r == "function" ? r(s) : r;
        return this._refinement( (s, i) => {
            const a = t(s)
              , o = () => i.addIssue({
                code: U.custom,
                ...n(s)
            });
            return typeof Promise < "u" && a instanceof Promise ? a.then(l => l ? !0 : (o(),
            !1)) : a ? !0 : (o(),
            !1)
        }
        )
    }
    refinement(t, r) {
        return this._refinement( (n, s) => t(n) ? !0 : (s.addIssue(typeof r == "function" ? r(n, s) : r),
        !1))
    }
    _refinement(t) {
        return new Sn({
            schema: this,
            typeName: pe.ZodEffects,
            effect: {
                type: "refinement",
                refinement: t
            }
        })
    }
    superRefine(t) {
        return this._refinement(t)
    }
    constructor(t) {
        this.spa = this.safeParseAsync,
        this._def = t,
        this.parse = this.parse.bind(this),
        this.safeParse = this.safeParse.bind(this),
        this.parseAsync = this.parseAsync.bind(this),
        this.safeParseAsync = this.safeParseAsync.bind(this),
        this.spa = this.spa.bind(this),
        this.refine = this.refine.bind(this),
        this.refinement = this.refinement.bind(this),
        this.superRefine = this.superRefine.bind(this),
        this.optional = this.optional.bind(this),
        this.nullable = this.nullable.bind(this),
        this.nullish = this.nullish.bind(this),
        this.array = this.array.bind(this),
        this.promise = this.promise.bind(this),
        this.or = this.or.bind(this),
        this.and = this.and.bind(this),
        this.transform = this.transform.bind(this),
        this.brand = this.brand.bind(this),
        this.default = this.default.bind(this),
        this.catch = this.catch.bind(this),
        this.describe = this.describe.bind(this),
        this.pipe = this.pipe.bind(this),
        this.readonly = this.readonly.bind(this),
        this.isNullable = this.isNullable.bind(this),
        this.isOptional = this.isOptional.bind(this),
        this["~standard"] = {
            version: 1,
            vendor: "zod",
            validate: r => this["~validate"](r)
        }
    }
    optional() {
        return Fn.create(this, this._def)
    }
    nullable() {
        return fi.create(this, this._def)
    }
    nullish() {
        return this.nullable().optional()
    }
    array() {
        return bn.create(this)
    }
    promise() {
        return No.create(this, this._def)
    }
    or(t) {
        return lu.create([this, t], this._def)
    }
    and(t) {
        return uu.create(this, t, this._def)
    }
    transform(t) {
        return new Sn({
            ...Te(this._def),
            schema: this,
            typeName: pe.ZodEffects,
            effect: {
                type: "transform",
                transform: t
            }
        })
    }
    default(t) {
        const r = typeof t == "function" ? t : () => t;
        return new mu({
            ...Te(this._def),
            innerType: this,
            defaultValue: r,
            typeName: pe.ZodDefault
        })
    }
    brand() {
        return new Ly({
            typeName: pe.ZodBranded,
            type: this,
            ...Te(this._def)
        })
    }
    catch(t) {
        const r = typeof t == "function" ? t : () => t;
        return new pu({
            ...Te(this._def),
            innerType: this,
            catchValue: r,
            typeName: pe.ZodCatch
        })
    }
    describe(t) {
        const r = this.constructor;
        return new r({
            ...this._def,
            description: t
        })
    }
    pipe(t) {
        return Zu.create(this, t)
    }
    readonly() {
        return yu.create(this)
    }
    isOptional() {
        return this.safeParse(void 0).success
    }
    isNullable() {
        return this.safeParse(null).success
    }
}
const hC = /^c[^\s-]{8,}$/i
  , mC = /^[0-9a-z]+$/
  , pC = /^[0-9A-HJKMNP-TV-Z]{26}$/i
  , yC = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i
  , gC = /^[a-z0-9_-]{21}$/i
  , vC = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
  , bC = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/
  , xC = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i
  , wC = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
let jh;
const SC = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/
  , kC = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/
  , EC = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/
  , _C = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/
  , TC = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/
  , CC = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/
  , uw = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))"
  , PC = new RegExp(`^${uw}$`);
function cw(e) {
    let t = "([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d";
    return e.precision ? t = `${t}\\.\\d{${e.precision}}` : e.precision == null && (t = `${t}(\\.\\d+)?`),
    t
}
function $C(e) {
    return new RegExp(`^${cw(e)}$`)
}
function dw(e) {
    let t = `${uw}T${cw(e)}`;
    const r = [];
    return r.push(e.local ? "Z?" : "Z"),
    e.offset && r.push("([+-]\\d{2}:?\\d{2})"),
    t = `${t}(${r.join("|")})`,
    new RegExp(`^${t}$`)
}
function NC(e, t) {
    return !!((t === "v4" || !t) && SC.test(e) || (t === "v6" || !t) && EC.test(e))
}
function jC(e, t) {
    if (!vC.test(e))
        return !1;
    try {
        const [r] = e.split(".")
          , n = r.replace(/-/g, "+").replace(/_/g, "/").padEnd(r.length + (4 - r.length % 4) % 4, "=")
          , s = JSON.parse(atob(n));
        return !(typeof s != "object" || s === null || !s.typ || !s.alg || t && s.alg !== t)
    } catch {
        return !1
    }
}
function IC(e, t) {
    return !!((t === "v4" || !t) && kC.test(e) || (t === "v6" || !t) && _C.test(e))
}
class yn extends $e {
    _parse(t) {
        if (this._def.coerce && (t.data = String(t.data)),
        this._getType(t) !== X.string) {
            const i = this._getOrReturnCtx(t);
            return K(i, {
                code: U.invalid_type,
                expected: X.string,
                received: i.parsedType
            }),
            ye
        }
        const n = new nr;
        let s;
        for (const i of this._def.checks)
            if (i.kind === "min")
                t.data.length < i.value && (s = this._getOrReturnCtx(t, s),
                K(s, {
                    code: U.too_small,
                    minimum: i.value,
                    type: "string",
                    inclusive: !0,
                    exact: !1,
                    message: i.message
                }),
                n.dirty());
            else if (i.kind === "max")
                t.data.length > i.value && (s = this._getOrReturnCtx(t, s),
                K(s, {
                    code: U.too_big,
                    maximum: i.value,
                    type: "string",
                    inclusive: !0,
                    exact: !1,
                    message: i.message
                }),
                n.dirty());
            else if (i.kind === "length") {
                const a = t.data.length > i.value
                  , o = t.data.length < i.value;
                (a || o) && (s = this._getOrReturnCtx(t, s),
                a ? K(s, {
                    code: U.too_big,
                    maximum: i.value,
                    type: "string",
                    inclusive: !0,
                    exact: !0,
                    message: i.message
                }) : o && K(s, {
                    code: U.too_small,
                    minimum: i.value,
                    type: "string",
                    inclusive: !0,
                    exact: !0,
                    message: i.message
                }),
                n.dirty())
            } else if (i.kind === "email")
                xC.test(t.data) || (s = this._getOrReturnCtx(t, s),
                K(s, {
                    validation: "email",
                    code: U.invalid_string,
                    message: i.message
                }),
                n.dirty());
            else if (i.kind === "emoji")
                jh || (jh = new RegExp(wC,"u")),
                jh.test(t.data) || (s = this._getOrReturnCtx(t, s),
                K(s, {
                    validation: "emoji",
                    code: U.invalid_string,
                    message: i.message
                }),
                n.dirty());
            else if (i.kind === "uuid")
                yC.test(t.data) || (s = this._getOrReturnCtx(t, s),
                K(s, {
                    validation: "uuid",
                    code: U.invalid_string,
                    message: i.message
                }),
                n.dirty());
            else if (i.kind === "nanoid")
                gC.test(t.data) || (s = this._getOrReturnCtx(t, s),
                K(s, {
                    validation: "nanoid",
                    code: U.invalid_string,
                    message: i.message
                }),
                n.dirty());
            else if (i.kind === "cuid")
                hC.test(t.data) || (s = this._getOrReturnCtx(t, s),
                K(s, {
                    validation: "cuid",
                    code: U.invalid_string,
                    message: i.message
                }),
                n.dirty());
            else if (i.kind === "cuid2")
                mC.test(t.data) || (s = this._getOrReturnCtx(t, s),
                K(s, {
                    validation: "cuid2",
                    code: U.invalid_string,
                    message: i.message
                }),
                n.dirty());
            else if (i.kind === "ulid")
                pC.test(t.data) || (s = this._getOrReturnCtx(t, s),
                K(s, {
                    validation: "ulid",
                    code: U.invalid_string,
                    message: i.message
                }),
                n.dirty());
            else if (i.kind === "url")
                try {
                    new URL(t.data)
                } catch {
                    s = this._getOrReturnCtx(t, s),
                    K(s, {
                        validation: "url",
                        code: U.invalid_string,
                        message: i.message
                    }),
                    n.dirty()
                }
            else
                i.kind === "regex" ? (i.regex.lastIndex = 0,
                i.regex.test(t.data) || (s = this._getOrReturnCtx(t, s),
                K(s, {
                    validation: "regex",
                    code: U.invalid_string,
                    message: i.message
                }),
                n.dirty())) : i.kind === "trim" ? t.data = t.data.trim() : i.kind === "includes" ? t.data.includes(i.value, i.position) || (s = this._getOrReturnCtx(t, s),
                K(s, {
                    code: U.invalid_string,
                    validation: {
                        includes: i.value,
                        position: i.position
                    },
                    message: i.message
                }),
                n.dirty()) : i.kind === "toLowerCase" ? t.data = t.data.toLowerCase() : i.kind === "toUpperCase" ? t.data = t.data.toUpperCase() : i.kind === "startsWith" ? t.data.startsWith(i.value) || (s = this._getOrReturnCtx(t, s),
                K(s, {
                    code: U.invalid_string,
                    validation: {
                        startsWith: i.value
                    },
                    message: i.message
                }),
                n.dirty()) : i.kind === "endsWith" ? t.data.endsWith(i.value) || (s = this._getOrReturnCtx(t, s),
                K(s, {
                    code: U.invalid_string,
                    validation: {
                        endsWith: i.value
                    },
                    message: i.message
                }),
                n.dirty()) : i.kind === "datetime" ? dw(i).test(t.data) || (s = this._getOrReturnCtx(t, s),
                K(s, {
                    code: U.invalid_string,
                    validation: "datetime",
                    message: i.message
                }),
                n.dirty()) : i.kind === "date" ? PC.test(t.data) || (s = this._getOrReturnCtx(t, s),
                K(s, {
                    code: U.invalid_string,
                    validation: "date",
                    message: i.message
                }),
                n.dirty()) : i.kind === "time" ? $C(i).test(t.data) || (s = this._getOrReturnCtx(t, s),
                K(s, {
                    code: U.invalid_string,
                    validation: "time",
                    message: i.message
                }),
                n.dirty()) : i.kind === "duration" ? bC.test(t.data) || (s = this._getOrReturnCtx(t, s),
                K(s, {
                    validation: "duration",
                    code: U.invalid_string,
                    message: i.message
                }),
                n.dirty()) : i.kind === "ip" ? NC(t.data, i.version) || (s = this._getOrReturnCtx(t, s),
                K(s, {
                    validation: "ip",
                    code: U.invalid_string,
                    message: i.message
                }),
                n.dirty()) : i.kind === "jwt" ? jC(t.data, i.alg) || (s = this._getOrReturnCtx(t, s),
                K(s, {
                    validation: "jwt",
                    code: U.invalid_string,
                    message: i.message
                }),
                n.dirty()) : i.kind === "cidr" ? IC(t.data, i.version) || (s = this._getOrReturnCtx(t, s),
                K(s, {
                    validation: "cidr",
                    code: U.invalid_string,
                    message: i.message
                }),
                n.dirty()) : i.kind === "base64" ? TC.test(t.data) || (s = this._getOrReturnCtx(t, s),
                K(s, {
                    validation: "base64",
                    code: U.invalid_string,
                    message: i.message
                }),
                n.dirty()) : i.kind === "base64url" ? CC.test(t.data) || (s = this._getOrReturnCtx(t, s),
                K(s, {
                    validation: "base64url",
                    code: U.invalid_string,
                    message: i.message
                }),
                n.dirty()) : Oe.assertNever(i);
        return {
            status: n.value,
            value: t.data
        }
    }
    _regex(t, r, n) {
        return this.refinement(s => t.test(s), {
            validation: r,
            code: U.invalid_string,
            ...ie.errToObj(n)
        })
    }
    _addCheck(t) {
        return new yn({
            ...this._def,
            checks: [...this._def.checks, t]
        })
    }
    email(t) {
        return this._addCheck({
            kind: "email",
            ...ie.errToObj(t)
        })
    }
    url(t) {
        return this._addCheck({
            kind: "url",
            ...ie.errToObj(t)
        })
    }
    emoji(t) {
        return this._addCheck({
            kind: "emoji",
            ...ie.errToObj(t)
        })
    }
    uuid(t) {
        return this._addCheck({
            kind: "uuid",
            ...ie.errToObj(t)
        })
    }
    nanoid(t) {
        return this._addCheck({
            kind: "nanoid",
            ...ie.errToObj(t)
        })
    }
    cuid(t) {
        return this._addCheck({
            kind: "cuid",
            ...ie.errToObj(t)
        })
    }
    cuid2(t) {
        return this._addCheck({
            kind: "cuid2",
            ...ie.errToObj(t)
        })
    }
    ulid(t) {
        return this._addCheck({
            kind: "ulid",
            ...ie.errToObj(t)
        })
    }
    base64(t) {
        return this._addCheck({
            kind: "base64",
            ...ie.errToObj(t)
        })
    }
    base64url(t) {
        return this._addCheck({
            kind: "base64url",
            ...ie.errToObj(t)
        })
    }
    jwt(t) {
        return this._addCheck({
            kind: "jwt",
            ...ie.errToObj(t)
        })
    }
    ip(t) {
        return this._addCheck({
            kind: "ip",
            ...ie.errToObj(t)
        })
    }
    cidr(t) {
        return this._addCheck({
            kind: "cidr",
            ...ie.errToObj(t)
        })
    }
    datetime(t) {
        var r, n;
        return typeof t == "string" ? this._addCheck({
            kind: "datetime",
            precision: null,
            offset: !1,
            local: !1,
            message: t
        }) : this._addCheck({
            kind: "datetime",
            precision: typeof (t == null ? void 0 : t.precision) > "u" ? null : t == null ? void 0 : t.precision,
            offset: (r = t == null ? void 0 : t.offset) !== null && r !== void 0 ? r : !1,
            local: (n = t == null ? void 0 : t.local) !== null && n !== void 0 ? n : !1,
            ...ie.errToObj(t == null ? void 0 : t.message)
        })
    }
    date(t) {
        return this._addCheck({
            kind: "date",
            message: t
        })
    }
    time(t) {
        return typeof t == "string" ? this._addCheck({
            kind: "time",
            precision: null,
            message: t
        }) : this._addCheck({
            kind: "time",
            precision: typeof (t == null ? void 0 : t.precision) > "u" ? null : t == null ? void 0 : t.precision,
            ...ie.errToObj(t == null ? void 0 : t.message)
        })
    }
    duration(t) {
        return this._addCheck({
            kind: "duration",
            ...ie.errToObj(t)
        })
    }
    regex(t, r) {
        return this._addCheck({
            kind: "regex",
            regex: t,
            ...ie.errToObj(r)
        })
    }
    includes(t, r) {
        return this._addCheck({
            kind: "includes",
            value: t,
            position: r == null ? void 0 : r.position,
            ...ie.errToObj(r == null ? void 0 : r.message)
        })
    }
    startsWith(t, r) {
        return this._addCheck({
            kind: "startsWith",
            value: t,
            ...ie.errToObj(r)
        })
    }
    endsWith(t, r) {
        return this._addCheck({
            kind: "endsWith",
            value: t,
            ...ie.errToObj(r)
        })
    }
    min(t, r) {
        return this._addCheck({
            kind: "min",
            value: t,
            ...ie.errToObj(r)
        })
    }
    max(t, r) {
        return this._addCheck({
            kind: "max",
            value: t,
            ...ie.errToObj(r)
        })
    }
    length(t, r) {
        return this._addCheck({
            kind: "length",
            value: t,
            ...ie.errToObj(r)
        })
    }
    nonempty(t) {
        return this.min(1, ie.errToObj(t))
    }
    trim() {
        return new yn({
            ...this._def,
            checks: [...this._def.checks, {
                kind: "trim"
            }]
        })
    }
    toLowerCase() {
        return new yn({
            ...this._def,
            checks: [...this._def.checks, {
                kind: "toLowerCase"
            }]
        })
    }
    toUpperCase() {
        return new yn({
            ...this._def,
            checks: [...this._def.checks, {
                kind: "toUpperCase"
            }]
        })
    }
    get isDatetime() {
        return !!this._def.checks.find(t => t.kind === "datetime")
    }
    get isDate() {
        return !!this._def.checks.find(t => t.kind === "date")
    }
    get isTime() {
        return !!this._def.checks.find(t => t.kind === "time")
    }
    get isDuration() {
        return !!this._def.checks.find(t => t.kind === "duration")
    }
    get isEmail() {
        return !!this._def.checks.find(t => t.kind === "email")
    }
    get isURL() {
        return !!this._def.checks.find(t => t.kind === "url")
    }
    get isEmoji() {
        return !!this._def.checks.find(t => t.kind === "emoji")
    }
    get isUUID() {
        return !!this._def.checks.find(t => t.kind === "uuid")
    }
    get isNANOID() {
        return !!this._def.checks.find(t => t.kind === "nanoid")
    }
    get isCUID() {
        return !!this._def.checks.find(t => t.kind === "cuid")
    }
    get isCUID2() {
        return !!this._def.checks.find(t => t.kind === "cuid2")
    }
    get isULID() {
        return !!this._def.checks.find(t => t.kind === "ulid")
    }
    get isIP() {
        return !!this._def.checks.find(t => t.kind === "ip")
    }
    get isCIDR() {
        return !!this._def.checks.find(t => t.kind === "cidr")
    }
    get isBase64() {
        return !!this._def.checks.find(t => t.kind === "base64")
    }
    get isBase64url() {
        return !!this._def.checks.find(t => t.kind === "base64url")
    }
    get minLength() {
        let t = null;
        for (const r of this._def.checks)
            r.kind === "min" && (t === null || r.value > t) && (t = r.value);
        return t
    }
    get maxLength() {
        let t = null;
        for (const r of this._def.checks)
            r.kind === "max" && (t === null || r.value < t) && (t = r.value);
        return t
    }
}
yn.create = e => {
    var t;
    return new yn({
        checks: [],
        typeName: pe.ZodString,
        coerce: (t = e == null ? void 0 : e.coerce) !== null && t !== void 0 ? t : !1,
        ...Te(e)
    })
}
;
function RC(e, t) {
    const r = (e.toString().split(".")[1] || "").length
      , n = (t.toString().split(".")[1] || "").length
      , s = r > n ? r : n
      , i = parseInt(e.toFixed(s).replace(".", ""))
      , a = parseInt(t.toFixed(s).replace(".", ""));
    return i % a / Math.pow(10, s)
}
class ui extends $e {
    constructor() {
        super(...arguments),
        this.min = this.gte,
        this.max = this.lte,
        this.step = this.multipleOf
    }
    _parse(t) {
        if (this._def.coerce && (t.data = Number(t.data)),
        this._getType(t) !== X.number) {
            const i = this._getOrReturnCtx(t);
            return K(i, {
                code: U.invalid_type,
                expected: X.number,
                received: i.parsedType
            }),
            ye
        }
        let n;
        const s = new nr;
        for (const i of this._def.checks)
            i.kind === "int" ? Oe.isInteger(t.data) || (n = this._getOrReturnCtx(t, n),
            K(n, {
                code: U.invalid_type,
                expected: "integer",
                received: "float",
                message: i.message
            }),
            s.dirty()) : i.kind === "min" ? (i.inclusive ? t.data < i.value : t.data <= i.value) && (n = this._getOrReturnCtx(t, n),
            K(n, {
                code: U.too_small,
                minimum: i.value,
                type: "number",
                inclusive: i.inclusive,
                exact: !1,
                message: i.message
            }),
            s.dirty()) : i.kind === "max" ? (i.inclusive ? t.data > i.value : t.data >= i.value) && (n = this._getOrReturnCtx(t, n),
            K(n, {
                code: U.too_big,
                maximum: i.value,
                type: "number",
                inclusive: i.inclusive,
                exact: !1,
                message: i.message
            }),
            s.dirty()) : i.kind === "multipleOf" ? RC(t.data, i.value) !== 0 && (n = this._getOrReturnCtx(t, n),
            K(n, {
                code: U.not_multiple_of,
                multipleOf: i.value,
                message: i.message
            }),
            s.dirty()) : i.kind === "finite" ? Number.isFinite(t.data) || (n = this._getOrReturnCtx(t, n),
            K(n, {
                code: U.not_finite,
                message: i.message
            }),
            s.dirty()) : Oe.assertNever(i);
        return {
            status: s.value,
            value: t.data
        }
    }
    gte(t, r) {
        return this.setLimit("min", t, !0, ie.toString(r))
    }
    gt(t, r) {
        return this.setLimit("min", t, !1, ie.toString(r))
    }
    lte(t, r) {
        return this.setLimit("max", t, !0, ie.toString(r))
    }
    lt(t, r) {
        return this.setLimit("max", t, !1, ie.toString(r))
    }
    setLimit(t, r, n, s) {
        return new ui({
            ...this._def,
            checks: [...this._def.checks, {
                kind: t,
                value: r,
                inclusive: n,
                message: ie.toString(s)
            }]
        })
    }
    _addCheck(t) {
        return new ui({
            ...this._def,
            checks: [...this._def.checks, t]
        })
    }
    int(t) {
        return this._addCheck({
            kind: "int",
            message: ie.toString(t)
        })
    }
    positive(t) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: !1,
            message: ie.toString(t)
        })
    }
    negative(t) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: !1,
            message: ie.toString(t)
        })
    }
    nonpositive(t) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: !0,
            message: ie.toString(t)
        })
    }
    nonnegative(t) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: !0,
            message: ie.toString(t)
        })
    }
    multipleOf(t, r) {
        return this._addCheck({
            kind: "multipleOf",
            value: t,
            message: ie.toString(r)
        })
    }
    finite(t) {
        return this._addCheck({
            kind: "finite",
            message: ie.toString(t)
        })
    }
    safe(t) {
        return this._addCheck({
            kind: "min",
            inclusive: !0,
            value: Number.MIN_SAFE_INTEGER,
            message: ie.toString(t)
        })._addCheck({
            kind: "max",
            inclusive: !0,
            value: Number.MAX_SAFE_INTEGER,
            message: ie.toString(t)
        })
    }
    get minValue() {
        let t = null;
        for (const r of this._def.checks)
            r.kind === "min" && (t === null || r.value > t) && (t = r.value);
        return t
    }
    get maxValue() {
        let t = null;
        for (const r of this._def.checks)
            r.kind === "max" && (t === null || r.value < t) && (t = r.value);
        return t
    }
    get isInt() {
        return !!this._def.checks.find(t => t.kind === "int" || t.kind === "multipleOf" && Oe.isInteger(t.value))
    }
    get isFinite() {
        let t = null
          , r = null;
        for (const n of this._def.checks) {
            if (n.kind === "finite" || n.kind === "int" || n.kind === "multipleOf")
                return !0;
            n.kind === "min" ? (r === null || n.value > r) && (r = n.value) : n.kind === "max" && (t === null || n.value < t) && (t = n.value)
        }
        return Number.isFinite(r) && Number.isFinite(t)
    }
}
ui.create = e => new ui({
    checks: [],
    typeName: pe.ZodNumber,
    coerce: (e == null ? void 0 : e.coerce) || !1,
    ...Te(e)
});
class ci extends $e {
    constructor() {
        super(...arguments),
        this.min = this.gte,
        this.max = this.lte
    }
    _parse(t) {
        if (this._def.coerce)
            try {
                t.data = BigInt(t.data)
            } catch {
                return this._getInvalidInput(t)
            }
        if (this._getType(t) !== X.bigint)
            return this._getInvalidInput(t);
        let n;
        const s = new nr;
        for (const i of this._def.checks)
            i.kind === "min" ? (i.inclusive ? t.data < i.value : t.data <= i.value) && (n = this._getOrReturnCtx(t, n),
            K(n, {
                code: U.too_small,
                type: "bigint",
                minimum: i.value,
                inclusive: i.inclusive,
                message: i.message
            }),
            s.dirty()) : i.kind === "max" ? (i.inclusive ? t.data > i.value : t.data >= i.value) && (n = this._getOrReturnCtx(t, n),
            K(n, {
                code: U.too_big,
                type: "bigint",
                maximum: i.value,
                inclusive: i.inclusive,
                message: i.message
            }),
            s.dirty()) : i.kind === "multipleOf" ? t.data % i.value !== BigInt(0) && (n = this._getOrReturnCtx(t, n),
            K(n, {
                code: U.not_multiple_of,
                multipleOf: i.value,
                message: i.message
            }),
            s.dirty()) : Oe.assertNever(i);
        return {
            status: s.value,
            value: t.data
        }
    }
    _getInvalidInput(t) {
        const r = this._getOrReturnCtx(t);
        return K(r, {
            code: U.invalid_type,
            expected: X.bigint,
            received: r.parsedType
        }),
        ye
    }
    gte(t, r) {
        return this.setLimit("min", t, !0, ie.toString(r))
    }
    gt(t, r) {
        return this.setLimit("min", t, !1, ie.toString(r))
    }
    lte(t, r) {
        return this.setLimit("max", t, !0, ie.toString(r))
    }
    lt(t, r) {
        return this.setLimit("max", t, !1, ie.toString(r))
    }
    setLimit(t, r, n, s) {
        return new ci({
            ...this._def,
            checks: [...this._def.checks, {
                kind: t,
                value: r,
                inclusive: n,
                message: ie.toString(s)
            }]
        })
    }
    _addCheck(t) {
        return new ci({
            ...this._def,
            checks: [...this._def.checks, t]
        })
    }
    positive(t) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: !1,
            message: ie.toString(t)
        })
    }
    negative(t) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: !1,
            message: ie.toString(t)
        })
    }
    nonpositive(t) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: !0,
            message: ie.toString(t)
        })
    }
    nonnegative(t) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: !0,
            message: ie.toString(t)
        })
    }
    multipleOf(t, r) {
        return this._addCheck({
            kind: "multipleOf",
            value: t,
            message: ie.toString(r)
        })
    }
    get minValue() {
        let t = null;
        for (const r of this._def.checks)
            r.kind === "min" && (t === null || r.value > t) && (t = r.value);
        return t
    }
    get maxValue() {
        let t = null;
        for (const r of this._def.checks)
            r.kind === "max" && (t === null || r.value < t) && (t = r.value);
        return t
    }
}
ci.create = e => {
    var t;
    return new ci({
        checks: [],
        typeName: pe.ZodBigInt,
        coerce: (t = e == null ? void 0 : e.coerce) !== null && t !== void 0 ? t : !1,
        ...Te(e)
    })
}
;
class iu extends $e {
    _parse(t) {
        if (this._def.coerce && (t.data = !!t.data),
        this._getType(t) !== X.boolean) {
            const n = this._getOrReturnCtx(t);
            return K(n, {
                code: U.invalid_type,
                expected: X.boolean,
                received: n.parsedType
            }),
            ye
        }
        return gr(t.data)
    }
}
iu.create = e => new iu({
    typeName: pe.ZodBoolean,
    coerce: (e == null ? void 0 : e.coerce) || !1,
    ...Te(e)
});
class ia extends $e {
    _parse(t) {
        if (this._def.coerce && (t.data = new Date(t.data)),
        this._getType(t) !== X.date) {
            const i = this._getOrReturnCtx(t);
            return K(i, {
                code: U.invalid_type,
                expected: X.date,
                received: i.parsedType
            }),
            ye
        }
        if (isNaN(t.data.getTime())) {
            const i = this._getOrReturnCtx(t);
            return K(i, {
                code: U.invalid_date
            }),
            ye
        }
        const n = new nr;
        let s;
        for (const i of this._def.checks)
            i.kind === "min" ? t.data.getTime() < i.value && (s = this._getOrReturnCtx(t, s),
            K(s, {
                code: U.too_small,
                message: i.message,
                inclusive: !0,
                exact: !1,
                minimum: i.value,
                type: "date"
            }),
            n.dirty()) : i.kind === "max" ? t.data.getTime() > i.value && (s = this._getOrReturnCtx(t, s),
            K(s, {
                code: U.too_big,
                message: i.message,
                inclusive: !0,
                exact: !1,
                maximum: i.value,
                type: "date"
            }),
            n.dirty()) : Oe.assertNever(i);
        return {
            status: n.value,
            value: new Date(t.data.getTime())
        }
    }
    _addCheck(t) {
        return new ia({
            ...this._def,
            checks: [...this._def.checks, t]
        })
    }
    min(t, r) {
        return this._addCheck({
            kind: "min",
            value: t.getTime(),
            message: ie.toString(r)
        })
    }
    max(t, r) {
        return this._addCheck({
            kind: "max",
            value: t.getTime(),
            message: ie.toString(r)
        })
    }
    get minDate() {
        let t = null;
        for (const r of this._def.checks)
            r.kind === "min" && (t === null || r.value > t) && (t = r.value);
        return t != null ? new Date(t) : null
    }
    get maxDate() {
        let t = null;
        for (const r of this._def.checks)
            r.kind === "max" && (t === null || r.value < t) && (t = r.value);
        return t != null ? new Date(t) : null
    }
}
ia.create = e => new ia({
    checks: [],
    coerce: (e == null ? void 0 : e.coerce) || !1,
    typeName: pe.ZodDate,
    ...Te(e)
});
class Ad extends $e {
    _parse(t) {
        if (this._getType(t) !== X.symbol) {
            const n = this._getOrReturnCtx(t);
            return K(n, {
                code: U.invalid_type,
                expected: X.symbol,
                received: n.parsedType
            }),
            ye
        }
        return gr(t.data)
    }
}
Ad.create = e => new Ad({
    typeName: pe.ZodSymbol,
    ...Te(e)
});
class au extends $e {
    _parse(t) {
        if (this._getType(t) !== X.undefined) {
            const n = this._getOrReturnCtx(t);
            return K(n, {
                code: U.invalid_type,
                expected: X.undefined,
                received: n.parsedType
            }),
            ye
        }
        return gr(t.data)
    }
}
au.create = e => new au({
    typeName: pe.ZodUndefined,
    ...Te(e)
});
class ou extends $e {
    _parse(t) {
        if (this._getType(t) !== X.null) {
            const n = this._getOrReturnCtx(t);
            return K(n, {
                code: U.invalid_type,
                expected: X.null,
                received: n.parsedType
            }),
            ye
        }
        return gr(t.data)
    }
}
ou.create = e => new ou({
    typeName: pe.ZodNull,
    ...Te(e)
});
class $o extends $e {
    constructor() {
        super(...arguments),
        this._any = !0
    }
    _parse(t) {
        return gr(t.data)
    }
}
$o.create = e => new $o({
    typeName: pe.ZodAny,
    ...Te(e)
});
class Ji extends $e {
    constructor() {
        super(...arguments),
        this._unknown = !0
    }
    _parse(t) {
        return gr(t.data)
    }
}
Ji.create = e => new Ji({
    typeName: pe.ZodUnknown,
    ...Te(e)
});
class os extends $e {
    _parse(t) {
        const r = this._getOrReturnCtx(t);
        return K(r, {
            code: U.invalid_type,
            expected: X.never,
            received: r.parsedType
        }),
        ye
    }
}
os.create = e => new os({
    typeName: pe.ZodNever,
    ...Te(e)
});
class Ld extends $e {
    _parse(t) {
        if (this._getType(t) !== X.undefined) {
            const n = this._getOrReturnCtx(t);
            return K(n, {
                code: U.invalid_type,
                expected: X.void,
                received: n.parsedType
            }),
            ye
        }
        return gr(t.data)
    }
}
Ld.create = e => new Ld({
    typeName: pe.ZodVoid,
    ...Te(e)
});
class bn extends $e {
    _parse(t) {
        const {ctx: r, status: n} = this._processInputParams(t)
          , s = this._def;
        if (r.parsedType !== X.array)
            return K(r, {
                code: U.invalid_type,
                expected: X.array,
                received: r.parsedType
            }),
            ye;
        if (s.exactLength !== null) {
            const a = r.data.length > s.exactLength.value
              , o = r.data.length < s.exactLength.value;
            (a || o) && (K(r, {
                code: a ? U.too_big : U.too_small,
                minimum: o ? s.exactLength.value : void 0,
                maximum: a ? s.exactLength.value : void 0,
                type: "array",
                inclusive: !0,
                exact: !0,
                message: s.exactLength.message
            }),
            n.dirty())
        }
        if (s.minLength !== null && r.data.length < s.minLength.value && (K(r, {
            code: U.too_small,
            minimum: s.minLength.value,
            type: "array",
            inclusive: !0,
            exact: !1,
            message: s.minLength.message
        }),
        n.dirty()),
        s.maxLength !== null && r.data.length > s.maxLength.value && (K(r, {
            code: U.too_big,
            maximum: s.maxLength.value,
            type: "array",
            inclusive: !0,
            exact: !1,
            message: s.maxLength.message
        }),
        n.dirty()),
        r.common.async)
            return Promise.all([...r.data].map( (a, o) => s.type._parseAsync(new Vn(r,a,r.path,o)))).then(a => nr.mergeArray(n, a));
        const i = [...r.data].map( (a, o) => s.type._parseSync(new Vn(r,a,r.path,o)));
        return nr.mergeArray(n, i)
    }
    get element() {
        return this._def.type
    }
    min(t, r) {
        return new bn({
            ...this._def,
            minLength: {
                value: t,
                message: ie.toString(r)
            }
        })
    }
    max(t, r) {
        return new bn({
            ...this._def,
            maxLength: {
                value: t,
                message: ie.toString(r)
            }
        })
    }
    length(t, r) {
        return new bn({
            ...this._def,
            exactLength: {
                value: t,
                message: ie.toString(r)
            }
        })
    }
    nonempty(t) {
        return this.min(1, t)
    }
}
bn.create = (e, t) => new bn({
    type: e,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: pe.ZodArray,
    ...Te(t)
});
function La(e) {
    if (e instanceof ot) {
        const t = {};
        for (const r in e.shape) {
            const n = e.shape[r];
            t[r] = Fn.create(La(n))
        }
        return new ot({
            ...e._def,
            shape: () => t
        })
    } else
        return e instanceof bn ? new bn({
            ...e._def,
            type: La(e.element)
        }) : e instanceof Fn ? Fn.create(La(e.unwrap())) : e instanceof fi ? fi.create(La(e.unwrap())) : e instanceof Bn ? Bn.create(e.items.map(t => La(t))) : e
}
class ot extends $e {
    constructor() {
        super(...arguments),
        this._cached = null,
        this.nonstrict = this.passthrough,
        this.augment = this.extend
    }
    _getCached() {
        if (this._cached !== null)
            return this._cached;
        const t = this._def.shape()
          , r = Oe.objectKeys(t);
        return this._cached = {
            shape: t,
            keys: r
        }
    }
    _parse(t) {
        if (this._getType(t) !== X.object) {
            const c = this._getOrReturnCtx(t);
            return K(c, {
                code: U.invalid_type,
                expected: X.object,
                received: c.parsedType
            }),
            ye
        }
        const {status: n, ctx: s} = this._processInputParams(t)
          , {shape: i, keys: a} = this._getCached()
          , o = [];
        if (!(this._def.catchall instanceof os && this._def.unknownKeys === "strip"))
            for (const c in s.data)
                a.includes(c) || o.push(c);
        const l = [];
        for (const c of a) {
            const f = i[c]
              , h = s.data[c];
            l.push({
                key: {
                    status: "valid",
                    value: c
                },
                value: f._parse(new Vn(s,h,s.path,c)),
                alwaysSet: c in s.data
            })
        }
        if (this._def.catchall instanceof os) {
            const c = this._def.unknownKeys;
            if (c === "passthrough")
                for (const f of o)
                    l.push({
                        key: {
                            status: "valid",
                            value: f
                        },
                        value: {
                            status: "valid",
                            value: s.data[f]
                        }
                    });
            else if (c === "strict")
                o.length > 0 && (K(s, {
                    code: U.unrecognized_keys,
                    keys: o
                }),
                n.dirty());
            else if (c !== "strip")
                throw new Error("Internal ZodObject error: invalid unknownKeys value.")
        } else {
            const c = this._def.catchall;
            for (const f of o) {
                const h = s.data[f];
                l.push({
                    key: {
                        status: "valid",
                        value: f
                    },
                    value: c._parse(new Vn(s,h,s.path,f)),
                    alwaysSet: f in s.data
                })
            }
        }
        return s.common.async ? Promise.resolve().then(async () => {
            const c = [];
            for (const f of l) {
                const h = await f.key
                  , m = await f.value;
                c.push({
                    key: h,
                    value: m,
                    alwaysSet: f.alwaysSet
                })
            }
            return c
        }
        ).then(c => nr.mergeObjectSync(n, c)) : nr.mergeObjectSync(n, l)
    }
    get shape() {
        return this._def.shape()
    }
    strict(t) {
        return ie.errToObj,
        new ot({
            ...this._def,
            unknownKeys: "strict",
            ...t !== void 0 ? {
                errorMap: (r, n) => {
                    var s, i, a, o;
                    const l = (a = (i = (s = this._def).errorMap) === null || i === void 0 ? void 0 : i.call(s, r, n).message) !== null && a !== void 0 ? a : n.defaultError;
                    return r.code === "unrecognized_keys" ? {
                        message: (o = ie.errToObj(t).message) !== null && o !== void 0 ? o : l
                    } : {
                        message: l
                    }
                }
            } : {}
        })
    }
    strip() {
        return new ot({
            ...this._def,
            unknownKeys: "strip"
        })
    }
    passthrough() {
        return new ot({
            ...this._def,
            unknownKeys: "passthrough"
        })
    }
    extend(t) {
        return new ot({
            ...this._def,
            shape: () => ({
                ...this._def.shape(),
                ...t
            })
        })
    }
    merge(t) {
        return new ot({
            unknownKeys: t._def.unknownKeys,
            catchall: t._def.catchall,
            shape: () => ({
                ...this._def.shape(),
                ...t._def.shape()
            }),
            typeName: pe.ZodObject
        })
    }
    setKey(t, r) {
        return this.augment({
            [t]: r
        })
    }
    catchall(t) {
        return new ot({
            ...this._def,
            catchall: t
        })
    }
    pick(t) {
        const r = {};
        return Oe.objectKeys(t).forEach(n => {
            t[n] && this.shape[n] && (r[n] = this.shape[n])
        }
        ),
        new ot({
            ...this._def,
            shape: () => r
        })
    }
    omit(t) {
        const r = {};
        return Oe.objectKeys(this.shape).forEach(n => {
            t[n] || (r[n] = this.shape[n])
        }
        ),
        new ot({
            ...this._def,
            shape: () => r
        })
    }
    deepPartial() {
        return La(this)
    }
    partial(t) {
        const r = {};
        return Oe.objectKeys(this.shape).forEach(n => {
            const s = this.shape[n];
            t && !t[n] ? r[n] = s : r[n] = s.optional()
        }
        ),
        new ot({
            ...this._def,
            shape: () => r
        })
    }
    required(t) {
        const r = {};
        return Oe.objectKeys(this.shape).forEach(n => {
            if (t && !t[n])
                r[n] = this.shape[n];
            else {
                let i = this.shape[n];
                for (; i instanceof Fn; )
                    i = i._def.innerType;
                r[n] = i
            }
        }
        ),
        new ot({
            ...this._def,
            shape: () => r
        })
    }
    keyof() {
        return fw(Oe.objectKeys(this.shape))
    }
}
ot.create = (e, t) => new ot({
    shape: () => e,
    unknownKeys: "strip",
    catchall: os.create(),
    typeName: pe.ZodObject,
    ...Te(t)
});
ot.strictCreate = (e, t) => new ot({
    shape: () => e,
    unknownKeys: "strict",
    catchall: os.create(),
    typeName: pe.ZodObject,
    ...Te(t)
});
ot.lazycreate = (e, t) => new ot({
    shape: e,
    unknownKeys: "strip",
    catchall: os.create(),
    typeName: pe.ZodObject,
    ...Te(t)
});
class lu extends $e {
    _parse(t) {
        const {ctx: r} = this._processInputParams(t)
          , n = this._def.options;
        function s(i) {
            for (const o of i)
                if (o.result.status === "valid")
                    return o.result;
            for (const o of i)
                if (o.result.status === "dirty")
                    return r.common.issues.push(...o.ctx.common.issues),
                    o.result;
            const a = i.map(o => new Ar(o.ctx.common.issues));
            return K(r, {
                code: U.invalid_union,
                unionErrors: a
            }),
            ye
        }
        if (r.common.async)
            return Promise.all(n.map(async i => {
                const a = {
                    ...r,
                    common: {
                        ...r.common,
                        issues: []
                    },
                    parent: null
                };
                return {
                    result: await i._parseAsync({
                        data: r.data,
                        path: r.path,
                        parent: a
                    }),
                    ctx: a
                }
            }
            )).then(s);
        {
            let i;
            const a = [];
            for (const l of n) {
                const c = {
                    ...r,
                    common: {
                        ...r.common,
                        issues: []
                    },
                    parent: null
                }
                  , f = l._parseSync({
                    data: r.data,
                    path: r.path,
                    parent: c
                });
                if (f.status === "valid")
                    return f;
                f.status === "dirty" && !i && (i = {
                    result: f,
                    ctx: c
                }),
                c.common.issues.length && a.push(c.common.issues)
            }
            if (i)
                return r.common.issues.push(...i.ctx.common.issues),
                i.result;
            const o = a.map(l => new Ar(l));
            return K(r, {
                code: U.invalid_union,
                unionErrors: o
            }),
            ye
        }
    }
    get options() {
        return this._def.options
    }
}
lu.create = (e, t) => new lu({
    options: e,
    typeName: pe.ZodUnion,
    ...Te(t)
});
const Kn = e => e instanceof du ? Kn(e.schema) : e instanceof Sn ? Kn(e.innerType()) : e instanceof fu ? [e.value] : e instanceof di ? e.options : e instanceof hu ? Oe.objectValues(e.enum) : e instanceof mu ? Kn(e._def.innerType) : e instanceof au ? [void 0] : e instanceof ou ? [null] : e instanceof Fn ? [void 0, ...Kn(e.unwrap())] : e instanceof fi ? [null, ...Kn(e.unwrap())] : e instanceof Ly || e instanceof yu ? Kn(e.unwrap()) : e instanceof pu ? Kn(e._def.innerType) : [];
class zf extends $e {
    _parse(t) {
        const {ctx: r} = this._processInputParams(t);
        if (r.parsedType !== X.object)
            return K(r, {
                code: U.invalid_type,
                expected: X.object,
                received: r.parsedType
            }),
            ye;
        const n = this.discriminator
          , s = r.data[n]
          , i = this.optionsMap.get(s);
        return i ? r.common.async ? i._parseAsync({
            data: r.data,
            path: r.path,
            parent: r
        }) : i._parseSync({
            data: r.data,
            path: r.path,
            parent: r
        }) : (K(r, {
            code: U.invalid_union_discriminator,
            options: Array.from(this.optionsMap.keys()),
            path: [n]
        }),
        ye)
    }
    get discriminator() {
        return this._def.discriminator
    }
    get options() {
        return this._def.options
    }
    get optionsMap() {
        return this._def.optionsMap
    }
    static create(t, r, n) {
        const s = new Map;
        for (const i of r) {
            const a = Kn(i.shape[t]);
            if (!a.length)
                throw new Error(`A discriminator value for key \`${t}\` could not be extracted from all schema options`);
            for (const o of a) {
                if (s.has(o))
                    throw new Error(`Discriminator property ${String(t)} has duplicate value ${String(o)}`);
                s.set(o, i)
            }
        }
        return new zf({
            typeName: pe.ZodDiscriminatedUnion,
            discriminator: t,
            options: r,
            optionsMap: s,
            ...Te(n)
        })
    }
}
function Dm(e, t) {
    const r = Yn(e)
      , n = Yn(t);
    if (e === t)
        return {
            valid: !0,
            data: e
        };
    if (r === X.object && n === X.object) {
        const s = Oe.objectKeys(t)
          , i = Oe.objectKeys(e).filter(o => s.indexOf(o) !== -1)
          , a = {
            ...e,
            ...t
        };
        for (const o of i) {
            const l = Dm(e[o], t[o]);
            if (!l.valid)
                return {
                    valid: !1
                };
            a[o] = l.data
        }
        return {
            valid: !0,
            data: a
        }
    } else if (r === X.array && n === X.array) {
        if (e.length !== t.length)
            return {
                valid: !1
            };
        const s = [];
        for (let i = 0; i < e.length; i++) {
            const a = e[i]
              , o = t[i]
              , l = Dm(a, o);
            if (!l.valid)
                return {
                    valid: !1
                };
            s.push(l.data)
        }
        return {
            valid: !0,
            data: s
        }
    } else
        return r === X.date && n === X.date && +e == +t ? {
            valid: !0,
            data: e
        } : {
            valid: !1
        }
}
class uu extends $e {
    _parse(t) {
        const {status: r, ctx: n} = this._processInputParams(t)
          , s = (i, a) => {
            if (Am(i) || Am(a))
                return ye;
            const o = Dm(i.value, a.value);
            return o.valid ? ((Lm(i) || Lm(a)) && r.dirty(),
            {
                status: r.value,
                value: o.data
            }) : (K(n, {
                code: U.invalid_intersection_types
            }),
            ye)
        }
        ;
        return n.common.async ? Promise.all([this._def.left._parseAsync({
            data: n.data,
            path: n.path,
            parent: n
        }), this._def.right._parseAsync({
            data: n.data,
            path: n.path,
            parent: n
        })]).then( ([i,a]) => s(i, a)) : s(this._def.left._parseSync({
            data: n.data,
            path: n.path,
            parent: n
        }), this._def.right._parseSync({
            data: n.data,
            path: n.path,
            parent: n
        }))
    }
}
uu.create = (e, t, r) => new uu({
    left: e,
    right: t,
    typeName: pe.ZodIntersection,
    ...Te(r)
});
class Bn extends $e {
    _parse(t) {
        const {status: r, ctx: n} = this._processInputParams(t);
        if (n.parsedType !== X.array)
            return K(n, {
                code: U.invalid_type,
                expected: X.array,
                received: n.parsedType
            }),
            ye;
        if (n.data.length < this._def.items.length)
            return K(n, {
                code: U.too_small,
                minimum: this._def.items.length,
                inclusive: !0,
                exact: !1,
                type: "array"
            }),
            ye;
        !this._def.rest && n.data.length > this._def.items.length && (K(n, {
            code: U.too_big,
            maximum: this._def.items.length,
            inclusive: !0,
            exact: !1,
            type: "array"
        }),
        r.dirty());
        const i = [...n.data].map( (a, o) => {
            const l = this._def.items[o] || this._def.rest;
            return l ? l._parse(new Vn(n,a,n.path,o)) : null
        }
        ).filter(a => !!a);
        return n.common.async ? Promise.all(i).then(a => nr.mergeArray(r, a)) : nr.mergeArray(r, i)
    }
    get items() {
        return this._def.items
    }
    rest(t) {
        return new Bn({
            ...this._def,
            rest: t
        })
    }
}
Bn.create = (e, t) => {
    if (!Array.isArray(e))
        throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    return new Bn({
        items: e,
        typeName: pe.ZodTuple,
        rest: null,
        ...Te(t)
    })
}
;
class cu extends $e {
    get keySchema() {
        return this._def.keyType
    }
    get valueSchema() {
        return this._def.valueType
    }
    _parse(t) {
        const {status: r, ctx: n} = this._processInputParams(t);
        if (n.parsedType !== X.object)
            return K(n, {
                code: U.invalid_type,
                expected: X.object,
                received: n.parsedType
            }),
            ye;
        const s = []
          , i = this._def.keyType
          , a = this._def.valueType;
        for (const o in n.data)
            s.push({
                key: i._parse(new Vn(n,o,n.path,o)),
                value: a._parse(new Vn(n,n.data[o],n.path,o)),
                alwaysSet: o in n.data
            });
        return n.common.async ? nr.mergeObjectAsync(r, s) : nr.mergeObjectSync(r, s)
    }
    get element() {
        return this._def.valueType
    }
    static create(t, r, n) {
        return r instanceof $e ? new cu({
            keyType: t,
            valueType: r,
            typeName: pe.ZodRecord,
            ...Te(n)
        }) : new cu({
            keyType: yn.create(),
            valueType: t,
            typeName: pe.ZodRecord,
            ...Te(r)
        })
    }
}
class Dd extends $e {
    get keySchema() {
        return this._def.keyType
    }
    get valueSchema() {
        return this._def.valueType
    }
    _parse(t) {
        const {status: r, ctx: n} = this._processInputParams(t);
        if (n.parsedType !== X.map)
            return K(n, {
                code: U.invalid_type,
                expected: X.map,
                received: n.parsedType
            }),
            ye;
        const s = this._def.keyType
          , i = this._def.valueType
          , a = [...n.data.entries()].map( ([o,l], c) => ({
            key: s._parse(new Vn(n,o,n.path,[c, "key"])),
            value: i._parse(new Vn(n,l,n.path,[c, "value"]))
        }));
        if (n.common.async) {
            const o = new Map;
            return Promise.resolve().then(async () => {
                for (const l of a) {
                    const c = await l.key
                      , f = await l.value;
                    if (c.status === "aborted" || f.status === "aborted")
                        return ye;
                    (c.status === "dirty" || f.status === "dirty") && r.dirty(),
                    o.set(c.value, f.value)
                }
                return {
                    status: r.value,
                    value: o
                }
            }
            )
        } else {
            const o = new Map;
            for (const l of a) {
                const c = l.key
                  , f = l.value;
                if (c.status === "aborted" || f.status === "aborted")
                    return ye;
                (c.status === "dirty" || f.status === "dirty") && r.dirty(),
                o.set(c.value, f.value)
            }
            return {
                status: r.value,
                value: o
            }
        }
    }
}
Dd.create = (e, t, r) => new Dd({
    valueType: t,
    keyType: e,
    typeName: pe.ZodMap,
    ...Te(r)
});
class aa extends $e {
    _parse(t) {
        const {status: r, ctx: n} = this._processInputParams(t);
        if (n.parsedType !== X.set)
            return K(n, {
                code: U.invalid_type,
                expected: X.set,
                received: n.parsedType
            }),
            ye;
        const s = this._def;
        s.minSize !== null && n.data.size < s.minSize.value && (K(n, {
            code: U.too_small,
            minimum: s.minSize.value,
            type: "set",
            inclusive: !0,
            exact: !1,
            message: s.minSize.message
        }),
        r.dirty()),
        s.maxSize !== null && n.data.size > s.maxSize.value && (K(n, {
            code: U.too_big,
            maximum: s.maxSize.value,
            type: "set",
            inclusive: !0,
            exact: !1,
            message: s.maxSize.message
        }),
        r.dirty());
        const i = this._def.valueType;
        function a(l) {
            const c = new Set;
            for (const f of l) {
                if (f.status === "aborted")
                    return ye;
                f.status === "dirty" && r.dirty(),
                c.add(f.value)
            }
            return {
                status: r.value,
                value: c
            }
        }
        const o = [...n.data.values()].map( (l, c) => i._parse(new Vn(n,l,n.path,c)));
        return n.common.async ? Promise.all(o).then(l => a(l)) : a(o)
    }
    min(t, r) {
        return new aa({
            ...this._def,
            minSize: {
                value: t,
                message: ie.toString(r)
            }
        })
    }
    max(t, r) {
        return new aa({
            ...this._def,
            maxSize: {
                value: t,
                message: ie.toString(r)
            }
        })
    }
    size(t, r) {
        return this.min(t, r).max(t, r)
    }
    nonempty(t) {
        return this.min(1, t)
    }
}
aa.create = (e, t) => new aa({
    valueType: e,
    minSize: null,
    maxSize: null,
    typeName: pe.ZodSet,
    ...Te(t)
});
class no extends $e {
    constructor() {
        super(...arguments),
        this.validate = this.implement
    }
    _parse(t) {
        const {ctx: r} = this._processInputParams(t);
        if (r.parsedType !== X.function)
            return K(r, {
                code: U.invalid_type,
                expected: X.function,
                received: r.parsedType
            }),
            ye;
        function n(o, l) {
            return Od({
                data: o,
                path: r.path,
                errorMaps: [r.common.contextualErrorMap, r.schemaErrorMap, Rd(), Po].filter(c => !!c),
                issueData: {
                    code: U.invalid_arguments,
                    argumentsError: l
                }
            })
        }
        function s(o, l) {
            return Od({
                data: o,
                path: r.path,
                errorMaps: [r.common.contextualErrorMap, r.schemaErrorMap, Rd(), Po].filter(c => !!c),
                issueData: {
                    code: U.invalid_return_type,
                    returnTypeError: l
                }
            })
        }
        const i = {
            errorMap: r.common.contextualErrorMap
        }
          , a = r.data;
        if (this._def.returns instanceof No) {
            const o = this;
            return gr(async function(...l) {
                const c = new Ar([])
                  , f = await o._def.args.parseAsync(l, i).catch(y => {
                    throw c.addIssue(n(l, y)),
                    c
                }
                )
                  , h = await Reflect.apply(a, this, f);
                return await o._def.returns._def.type.parseAsync(h, i).catch(y => {
                    throw c.addIssue(s(h, y)),
                    c
                }
                )
            })
        } else {
            const o = this;
            return gr(function(...l) {
                const c = o._def.args.safeParse(l, i);
                if (!c.success)
                    throw new Ar([n(l, c.error)]);
                const f = Reflect.apply(a, this, c.data)
                  , h = o._def.returns.safeParse(f, i);
                if (!h.success)
                    throw new Ar([s(f, h.error)]);
                return h.data
            })
        }
    }
    parameters() {
        return this._def.args
    }
    returnType() {
        return this._def.returns
    }
    args(...t) {
        return new no({
            ...this._def,
            args: Bn.create(t).rest(Ji.create())
        })
    }
    returns(t) {
        return new no({
            ...this._def,
            returns: t
        })
    }
    implement(t) {
        return this.parse(t)
    }
    strictImplement(t) {
        return this.parse(t)
    }
    static create(t, r, n) {
        return new no({
            args: t || Bn.create([]).rest(Ji.create()),
            returns: r || Ji.create(),
            typeName: pe.ZodFunction,
            ...Te(n)
        })
    }
}
class du extends $e {
    get schema() {
        return this._def.getter()
    }
    _parse(t) {
        const {ctx: r} = this._processInputParams(t);
        return this._def.getter()._parse({
            data: r.data,
            path: r.path,
            parent: r
        })
    }
}
du.create = (e, t) => new du({
    getter: e,
    typeName: pe.ZodLazy,
    ...Te(t)
});
class fu extends $e {
    _parse(t) {
        if (t.data !== this._def.value) {
            const r = this._getOrReturnCtx(t);
            return K(r, {
                received: r.data,
                code: U.invalid_literal,
                expected: this._def.value
            }),
            ye
        }
        return {
            status: "valid",
            value: t.data
        }
    }
    get value() {
        return this._def.value
    }
}
fu.create = (e, t) => new fu({
    value: e,
    typeName: pe.ZodLiteral,
    ...Te(t)
});
function fw(e, t) {
    return new di({
        values: e,
        typeName: pe.ZodEnum,
        ...Te(t)
    })
}
class di extends $e {
    constructor() {
        super(...arguments),
        Nl.set(this, void 0)
    }
    _parse(t) {
        if (typeof t.data != "string") {
            const r = this._getOrReturnCtx(t)
              , n = this._def.values;
            return K(r, {
                expected: Oe.joinValues(n),
                received: r.parsedType,
                code: U.invalid_type
            }),
            ye
        }
        if (Md(this, Nl) || lw(this, Nl, new Set(this._def.values)),
        !Md(this, Nl).has(t.data)) {
            const r = this._getOrReturnCtx(t)
              , n = this._def.values;
            return K(r, {
                received: r.data,
                code: U.invalid_enum_value,
                options: n
            }),
            ye
        }
        return gr(t.data)
    }
    get options() {
        return this._def.values
    }
    get enum() {
        const t = {};
        for (const r of this._def.values)
            t[r] = r;
        return t
    }
    get Values() {
        const t = {};
        for (const r of this._def.values)
            t[r] = r;
        return t
    }
    get Enum() {
        const t = {};
        for (const r of this._def.values)
            t[r] = r;
        return t
    }
    extract(t, r=this._def) {
        return di.create(t, {
            ...this._def,
            ...r
        })
    }
    exclude(t, r=this._def) {
        return di.create(this.options.filter(n => !t.includes(n)), {
            ...this._def,
            ...r
        })
    }
}
Nl = new WeakMap;
di.create = fw;
class hu extends $e {
    constructor() {
        super(...arguments),
        jl.set(this, void 0)
    }
    _parse(t) {
        const r = Oe.getValidEnumValues(this._def.values)
          , n = this._getOrReturnCtx(t);
        if (n.parsedType !== X.string && n.parsedType !== X.number) {
            const s = Oe.objectValues(r);
            return K(n, {
                expected: Oe.joinValues(s),
                received: n.parsedType,
                code: U.invalid_type
            }),
            ye
        }
        if (Md(this, jl) || lw(this, jl, new Set(Oe.getValidEnumValues(this._def.values))),
        !Md(this, jl).has(t.data)) {
            const s = Oe.objectValues(r);
            return K(n, {
                received: n.data,
                code: U.invalid_enum_value,
                options: s
            }),
            ye
        }
        return gr(t.data)
    }
    get enum() {
        return this._def.values
    }
}
jl = new WeakMap;
hu.create = (e, t) => new hu({
    values: e,
    typeName: pe.ZodNativeEnum,
    ...Te(t)
});
class No extends $e {
    unwrap() {
        return this._def.type
    }
    _parse(t) {
        const {ctx: r} = this._processInputParams(t);
        if (r.parsedType !== X.promise && r.common.async === !1)
            return K(r, {
                code: U.invalid_type,
                expected: X.promise,
                received: r.parsedType
            }),
            ye;
        const n = r.parsedType === X.promise ? r.data : Promise.resolve(r.data);
        return gr(n.then(s => this._def.type.parseAsync(s, {
            path: r.path,
            errorMap: r.common.contextualErrorMap
        })))
    }
}
No.create = (e, t) => new No({
    type: e,
    typeName: pe.ZodPromise,
    ...Te(t)
});
class Sn extends $e {
    innerType() {
        return this._def.schema
    }
    sourceType() {
        return this._def.schema._def.typeName === pe.ZodEffects ? this._def.schema.sourceType() : this._def.schema
    }
    _parse(t) {
        const {status: r, ctx: n} = this._processInputParams(t)
          , s = this._def.effect || null
          , i = {
            addIssue: a => {
                K(n, a),
                a.fatal ? r.abort() : r.dirty()
            }
            ,
            get path() {
                return n.path
            }
        };
        if (i.addIssue = i.addIssue.bind(i),
        s.type === "preprocess") {
            const a = s.transform(n.data, i);
            if (n.common.async)
                return Promise.resolve(a).then(async o => {
                    if (r.value === "aborted")
                        return ye;
                    const l = await this._def.schema._parseAsync({
                        data: o,
                        path: n.path,
                        parent: n
                    });
                    return l.status === "aborted" ? ye : l.status === "dirty" || r.value === "dirty" ? Va(l.value) : l
                }
                );
            {
                if (r.value === "aborted")
                    return ye;
                const o = this._def.schema._parseSync({
                    data: a,
                    path: n.path,
                    parent: n
                });
                return o.status === "aborted" ? ye : o.status === "dirty" || r.value === "dirty" ? Va(o.value) : o
            }
        }
        if (s.type === "refinement") {
            const a = o => {
                const l = s.refinement(o, i);
                if (n.common.async)
                    return Promise.resolve(l);
                if (l instanceof Promise)
                    throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
                return o
            }
            ;
            if (n.common.async === !1) {
                const o = this._def.schema._parseSync({
                    data: n.data,
                    path: n.path,
                    parent: n
                });
                return o.status === "aborted" ? ye : (o.status === "dirty" && r.dirty(),
                a(o.value),
                {
                    status: r.value,
                    value: o.value
                })
            } else
                return this._def.schema._parseAsync({
                    data: n.data,
                    path: n.path,
                    parent: n
                }).then(o => o.status === "aborted" ? ye : (o.status === "dirty" && r.dirty(),
                a(o.value).then( () => ({
                    status: r.value,
                    value: o.value
                }))))
        }
        if (s.type === "transform")
            if (n.common.async === !1) {
                const a = this._def.schema._parseSync({
                    data: n.data,
                    path: n.path,
                    parent: n
                });
                if (!sa(a))
                    return a;
                const o = s.transform(a.value, i);
                if (o instanceof Promise)
                    throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
                return {
                    status: r.value,
                    value: o
                }
            } else
                return this._def.schema._parseAsync({
                    data: n.data,
                    path: n.path,
                    parent: n
                }).then(a => sa(a) ? Promise.resolve(s.transform(a.value, i)).then(o => ({
                    status: r.value,
                    value: o
                })) : a);
        Oe.assertNever(s)
    }
}
Sn.create = (e, t, r) => new Sn({
    schema: e,
    typeName: pe.ZodEffects,
    effect: t,
    ...Te(r)
});
Sn.createWithPreprocess = (e, t, r) => new Sn({
    schema: t,
    effect: {
        type: "preprocess",
        transform: e
    },
    typeName: pe.ZodEffects,
    ...Te(r)
});
class Fn extends $e {
    _parse(t) {
        return this._getType(t) === X.undefined ? gr(void 0) : this._def.innerType._parse(t)
    }
    unwrap() {
        return this._def.innerType
    }
}
Fn.create = (e, t) => new Fn({
    innerType: e,
    typeName: pe.ZodOptional,
    ...Te(t)
});
class fi extends $e {
    _parse(t) {
        return this._getType(t) === X.null ? gr(null) : this._def.innerType._parse(t)
    }
    unwrap() {
        return this._def.innerType
    }
}
fi.create = (e, t) => new fi({
    innerType: e,
    typeName: pe.ZodNullable,
    ...Te(t)
});
class mu extends $e {
    _parse(t) {
        const {ctx: r} = this._processInputParams(t);
        let n = r.data;
        return r.parsedType === X.undefined && (n = this._def.defaultValue()),
        this._def.innerType._parse({
            data: n,
            path: r.path,
            parent: r
        })
    }
    removeDefault() {
        return this._def.innerType
    }
}
mu.create = (e, t) => new mu({
    innerType: e,
    typeName: pe.ZodDefault,
    defaultValue: typeof t.default == "function" ? t.default : () => t.default,
    ...Te(t)
});
class pu extends $e {
    _parse(t) {
        const {ctx: r} = this._processInputParams(t)
          , n = {
            ...r,
            common: {
                ...r.common,
                issues: []
            }
        }
          , s = this._def.innerType._parse({
            data: n.data,
            path: n.path,
            parent: {
                ...n
            }
        });
        return su(s) ? s.then(i => ({
            status: "valid",
            value: i.status === "valid" ? i.value : this._def.catchValue({
                get error() {
                    return new Ar(n.common.issues)
                },
                input: n.data
            })
        })) : {
            status: "valid",
            value: s.status === "valid" ? s.value : this._def.catchValue({
                get error() {
                    return new Ar(n.common.issues)
                },
                input: n.data
            })
        }
    }
    removeCatch() {
        return this._def.innerType
    }
}
pu.create = (e, t) => new pu({
    innerType: e,
    typeName: pe.ZodCatch,
    catchValue: typeof t.catch == "function" ? t.catch : () => t.catch,
    ...Te(t)
});
class Fd extends $e {
    _parse(t) {
        if (this._getType(t) !== X.nan) {
            const n = this._getOrReturnCtx(t);
            return K(n, {
                code: U.invalid_type,
                expected: X.nan,
                received: n.parsedType
            }),
            ye
        }
        return {
            status: "valid",
            value: t.data
        }
    }
}
Fd.create = e => new Fd({
    typeName: pe.ZodNaN,
    ...Te(e)
});
const OC = Symbol("zod_brand");
class Ly extends $e {
    _parse(t) {
        const {ctx: r} = this._processInputParams(t)
          , n = r.data;
        return this._def.type._parse({
            data: n,
            path: r.path,
            parent: r
        })
    }
    unwrap() {
        return this._def.type
    }
}
class Zu extends $e {
    _parse(t) {
        const {status: r, ctx: n} = this._processInputParams(t);
        if (n.common.async)
            return (async () => {
                const i = await this._def.in._parseAsync({
                    data: n.data,
                    path: n.path,
                    parent: n
                });
                return i.status === "aborted" ? ye : i.status === "dirty" ? (r.dirty(),
                Va(i.value)) : this._def.out._parseAsync({
                    data: i.value,
                    path: n.path,
                    parent: n
                })
            }
            )();
        {
            const s = this._def.in._parseSync({
                data: n.data,
                path: n.path,
                parent: n
            });
            return s.status === "aborted" ? ye : s.status === "dirty" ? (r.dirty(),
            {
                status: "dirty",
                value: s.value
            }) : this._def.out._parseSync({
                data: s.value,
                path: n.path,
                parent: n
            })
        }
    }
    static create(t, r) {
        return new Zu({
            in: t,
            out: r,
            typeName: pe.ZodPipeline
        })
    }
}
class yu extends $e {
    _parse(t) {
        const r = this._def.innerType._parse(t)
          , n = s => (sa(s) && (s.value = Object.freeze(s.value)),
        s);
        return su(r) ? r.then(s => n(s)) : n(r)
    }
    unwrap() {
        return this._def.innerType
    }
}
yu.create = (e, t) => new yu({
    innerType: e,
    typeName: pe.ZodReadonly,
    ...Te(t)
});
function n0(e, t) {
    const r = typeof e == "function" ? e(t) : typeof e == "string" ? {
        message: e
    } : e;
    return typeof r == "string" ? {
        message: r
    } : r
}
function hw(e, t={}, r) {
    return e ? $o.create().superRefine( (n, s) => {
        var i, a;
        const o = e(n);
        if (o instanceof Promise)
            return o.then(l => {
                var c, f;
                if (!l) {
                    const h = n0(t, n)
                      , m = (f = (c = h.fatal) !== null && c !== void 0 ? c : r) !== null && f !== void 0 ? f : !0;
                    s.addIssue({
                        code: "custom",
                        ...h,
                        fatal: m
                    })
                }
            }
            );
        if (!o) {
            const l = n0(t, n)
              , c = (a = (i = l.fatal) !== null && i !== void 0 ? i : r) !== null && a !== void 0 ? a : !0;
            s.addIssue({
                code: "custom",
                ...l,
                fatal: c
            })
        }
    }
    ) : $o.create()
}
const MC = {
    object: ot.lazycreate
};
var pe;
(function(e) {
    e.ZodString = "ZodString",
    e.ZodNumber = "ZodNumber",
    e.ZodNaN = "ZodNaN",
    e.ZodBigInt = "ZodBigInt",
    e.ZodBoolean = "ZodBoolean",
    e.ZodDate = "ZodDate",
    e.ZodSymbol = "ZodSymbol",
    e.ZodUndefined = "ZodUndefined",
    e.ZodNull = "ZodNull",
    e.ZodAny = "ZodAny",
    e.ZodUnknown = "ZodUnknown",
    e.ZodNever = "ZodNever",
    e.ZodVoid = "ZodVoid",
    e.ZodArray = "ZodArray",
    e.ZodObject = "ZodObject",
    e.ZodUnion = "ZodUnion",
    e.ZodDiscriminatedUnion = "ZodDiscriminatedUnion",
    e.ZodIntersection = "ZodIntersection",
    e.ZodTuple = "ZodTuple",
    e.ZodRecord = "ZodRecord",
    e.ZodMap = "ZodMap",
    e.ZodSet = "ZodSet",
    e.ZodFunction = "ZodFunction",
    e.ZodLazy = "ZodLazy",
    e.ZodLiteral = "ZodLiteral",
    e.ZodEnum = "ZodEnum",
    e.ZodEffects = "ZodEffects",
    e.ZodNativeEnum = "ZodNativeEnum",
    e.ZodOptional = "ZodOptional",
    e.ZodNullable = "ZodNullable",
    e.ZodDefault = "ZodDefault",
    e.ZodCatch = "ZodCatch",
    e.ZodPromise = "ZodPromise",
    e.ZodBranded = "ZodBranded",
    e.ZodPipeline = "ZodPipeline",
    e.ZodReadonly = "ZodReadonly"
}
)(pe || (pe = {}));
const AC = (e, t={
    message: `Input not instance of ${e.name}`
}) => hw(r => r instanceof e, t)
  , mw = yn.create
  , pw = ui.create
  , LC = Fd.create
  , DC = ci.create
  , yw = iu.create
  , FC = ia.create
  , zC = Ad.create
  , UC = au.create
  , VC = ou.create
  , BC = $o.create
  , WC = Ji.create
  , qC = os.create
  , HC = Ld.create
  , ZC = bn.create
  , KC = ot.create
  , QC = ot.strictCreate
  , GC = lu.create
  , YC = zf.create
  , JC = uu.create
  , XC = Bn.create
  , eP = cu.create
  , tP = Dd.create
  , rP = aa.create
  , nP = no.create
  , sP = du.create
  , iP = fu.create
  , aP = di.create
  , oP = hu.create
  , lP = No.create
  , s0 = Sn.create
  , uP = Fn.create
  , cP = fi.create
  , dP = Sn.createWithPreprocess
  , fP = Zu.create
  , hP = () => mw().optional()
  , mP = () => pw().optional()
  , pP = () => yw().optional()
  , yP = {
    string: e => yn.create({
        ...e,
        coerce: !0
    }),
    number: e => ui.create({
        ...e,
        coerce: !0
    }),
    boolean: e => iu.create({
        ...e,
        coerce: !0
    }),
    bigint: e => ci.create({
        ...e,
        coerce: !0
    }),
    date: e => ia.create({
        ...e,
        coerce: !0
    })
}
  , gP = ye;
var u = Object.freeze({
    __proto__: null,
    defaultErrorMap: Po,
    setErrorMap: dC,
    getErrorMap: Rd,
    makeIssue: Od,
    EMPTY_PATH: fC,
    addIssueToContext: K,
    ParseStatus: nr,
    INVALID: ye,
    DIRTY: Va,
    OK: gr,
    isAborted: Am,
    isDirty: Lm,
    isValid: sa,
    isAsync: su,
    get util() {
        return Oe
    },
    get objectUtil() {
        return Mm
    },
    ZodParsedType: X,
    getParsedType: Yn,
    ZodType: $e,
    datetimeRegex: dw,
    ZodString: yn,
    ZodNumber: ui,
    ZodBigInt: ci,
    ZodBoolean: iu,
    ZodDate: ia,
    ZodSymbol: Ad,
    ZodUndefined: au,
    ZodNull: ou,
    ZodAny: $o,
    ZodUnknown: Ji,
    ZodNever: os,
    ZodVoid: Ld,
    ZodArray: bn,
    ZodObject: ot,
    ZodUnion: lu,
    ZodDiscriminatedUnion: zf,
    ZodIntersection: uu,
    ZodTuple: Bn,
    ZodRecord: cu,
    ZodMap: Dd,
    ZodSet: aa,
    ZodFunction: no,
    ZodLazy: du,
    ZodLiteral: fu,
    ZodEnum: di,
    ZodNativeEnum: hu,
    ZodPromise: No,
    ZodEffects: Sn,
    ZodTransformer: Sn,
    ZodOptional: Fn,
    ZodNullable: fi,
    ZodDefault: mu,
    ZodCatch: pu,
    ZodNaN: Fd,
    BRAND: OC,
    ZodBranded: Ly,
    ZodPipeline: Zu,
    ZodReadonly: yu,
    custom: hw,
    Schema: $e,
    ZodSchema: $e,
    late: MC,
    get ZodFirstPartyTypeKind() {
        return pe
    },
    coerce: yP,
    any: BC,
    array: ZC,
    bigint: DC,
    boolean: yw,
    date: FC,
    discriminatedUnion: YC,
    effect: s0,
    enum: aP,
    function: nP,
    instanceof: AC,
    intersection: JC,
    lazy: sP,
    literal: iP,
    map: tP,
    nan: LC,
    nativeEnum: oP,
    never: qC,
    null: VC,
    nullable: cP,
    number: pw,
    object: KC,
    oboolean: pP,
    onumber: mP,
    optional: uP,
    ostring: hP,
    pipeline: fP,
    preprocess: dP,
    promise: lP,
    record: eP,
    set: rP,
    strictObject: QC,
    string: mw,
    symbol: zC,
    transformer: s0,
    tuple: XC,
    undefined: UC,
    union: GC,
    unknown: WC,
    void: HC,
    NEVER: gP,
    ZodIssueCode: U,
    quotelessJson: cC,
    ZodError: Ar
});
const vP = u.union([u.object({
    type: u.literal("command:navigate"),
    attrs: u.object({
        path: u.string()
    })
}), u.object({
    type: u.literal("command:invalidate_cache")
}), u.object({
    type: u.literal("avatar_equipped"),
    attrs: u.object({
        avatarId: u.string()
    })
}), u.object({
    type: u.literal("blob_mutex"),
    attrs: u.object({
        id: u.string(),
        action: u.enum(["LOCK", "UNLOCK"])
    })
}), u.object({
    type: u.literal("avatar_edited")
}), u.object({
    type: u.literal("building_removed")
}), u.object({
    type: u.literal("building_edited")
}), u.object({
    type: u.literal("sync:store"),
    attrs: u.object({
        balance: u.number().optional()
    })
}), u.object({
    type: u.literal("sync:room_users"),
    attrs: u.object({
        userIds: u.string().array()
    })
}), u.object({
    type: u.literal("sync:ws_message"),
    attrs: u.object({
        value: u.string()
    })
})])
  , Ve = {
    client: typeof window < "u" && "vuplex"in window && window.vuplex,
    emitter: new na,
    listen(e) {
        if (typeof window > "u")
            return;
        function t() {
            Ve.client && Ve.client.addEventListener("message", r => {
                console.log("[Vuplex.listen] Received message:", r);
                const n = vP.safeParse(JSON.parse(r.data));
                if (!n.success) {
                    console.warn("[Vuplex.listen] Message was not handled", {
                        event: r,
                        message: n
                    });
                    return
                }
                e(n.data)
            }
            )
        }
        return Ve.client ? t() : window.addEventListener("vuplexready", t),
        function() {
            window.removeEventListener("vuplexready", t)
        }
    },
    emit(e, t, r) {
        const n = {
            type: e,
            attrs: t
        };
        if (console.info("[Vuplex.emit] Attempting to send message: ", n),
        typeof window > "u" || !window.vuplex)
            return new Promise(i => i(!0));
        const s = aw();
        return !r && Ve.client ? (Ve.client.postMessage({
            id: s,
            ...n
        }),
        new Promise(i => i(!0))) : new Promise( (i, a) => {
            if (!Ve.client)
                return a("Unable to send message to vuplex.");
            const o = setTimeout( () => {
                a("Message went unacknowledged.")
            }
            , 3e3);
            Ve.emitter.once(s).then(l => {
                if (clearTimeout(o),
                !l.success)
                    return console.error("[Vuplex.emit] Message failed:", n, l.error),
                    a(l.error);
                console.info("[Vuplex.emit] Message acknowledged:", n),
                i(!0)
            }
            ),
            Ve.client.postMessage({
                id: s,
                ...n
            })
        }
        )
    }
}
  , hr = ya({
    actionsInFlight: Wt(),
    isLockingAction: !1,
    hiddenProducts: Wt(),
    lockedBlobIds: new Set
});
function gu(e=aw()) {
    return hr.actionsInFlight.add(e),
    hr.isLockingAction = !0,
    () => bP(e)
}
function bP(e) {
    hr.actionsInFlight.delete(e),
    hr.isLockingAction = hr.actionsInFlight.size > 0
}
async function er(e) {
    const t = gu();
    try {
        return await e()
    } finally {
        t()
    }
}
const i0 = 5
  , xP = 100;
async function gw(e, t) {
    try {
        if (hr.lockedBlobIds.has(e)) {
            let r = 0;
            for (; r <= i0 && hr.lockedBlobIds.has(e); ) {
                if (r === i0)
                    throw new Error("Timeout waiting for blob lock");
                r++,
                await new Promise(n => setTimeout(n, xP * r))
            }
        }
        return hr.lockedBlobIds.add(e),
        Ve.emit("blob_mutex", {
            id: e,
            action: "LOCK"
        }),
        await t()
    } finally {
        hr.lockedBlobIds.delete(e),
        Ve.emit("blob_mutex", {
            id: e,
            action: "UNLOCK"
        })
    }
}
function vw(e) {
    hr.hiddenProducts.add(e)
}
function Dy() {
    return Ay(hr)
}
function wP() {
    this.__data__ = [],
    this.size = 0
}
var SP = wP;
function kP(e, t) {
    return e === t || e !== e && t !== t
}
var bw = kP
  , EP = bw;
function _P(e, t) {
    for (var r = e.length; r--; )
        if (EP(e[r][0], t))
            return r;
    return -1
}
var Uf = _P
  , TP = Uf
  , CP = Array.prototype
  , PP = CP.splice;
function $P(e) {
    var t = this.__data__
      , r = TP(t, e);
    if (r < 0)
        return !1;
    var n = t.length - 1;
    return r == n ? t.pop() : PP.call(t, r, 1),
    --this.size,
    !0
}
var NP = $P
  , jP = Uf;
function IP(e) {
    var t = this.__data__
      , r = jP(t, e);
    return r < 0 ? void 0 : t[r][1]
}
var RP = IP
  , OP = Uf;
function MP(e) {
    return OP(this.__data__, e) > -1
}
var AP = MP
  , LP = Uf;
function DP(e, t) {
    var r = this.__data__
      , n = LP(r, e);
    return n < 0 ? (++this.size,
    r.push([e, t])) : r[n][1] = t,
    this
}
var FP = DP
  , zP = SP
  , UP = NP
  , VP = RP
  , BP = AP
  , WP = FP;
function Bo(e) {
    var t = -1
      , r = e == null ? 0 : e.length;
    for (this.clear(); ++t < r; ) {
        var n = e[t];
        this.set(n[0], n[1])
    }
}
Bo.prototype.clear = zP;
Bo.prototype.delete = UP;
Bo.prototype.get = VP;
Bo.prototype.has = BP;
Bo.prototype.set = WP;
var Vf = Bo
  , qP = Vf;
function HP() {
    this.__data__ = new qP,
    this.size = 0
}
var ZP = HP;
function KP(e) {
    var t = this.__data__
      , r = t.delete(e);
    return this.size = t.size,
    r
}
var QP = KP;
function GP(e) {
    return this.__data__.get(e)
}
var YP = GP;
function JP(e) {
    return this.__data__.has(e)
}
var XP = JP
  , e$ = typeof Sc == "object" && Sc && Sc.Object === Object && Sc
  , xw = e$
  , t$ = xw
  , r$ = typeof self == "object" && self && self.Object === Object && self
  , n$ = t$ || r$ || Function("return this")()
  , ys = n$
  , s$ = ys
  , i$ = s$.Symbol
  , Bf = i$
  , a0 = Bf
  , ww = Object.prototype
  , a$ = ww.hasOwnProperty
  , o$ = ww.toString
  , fl = a0 ? a0.toStringTag : void 0;
function l$(e) {
    var t = a$.call(e, fl)
      , r = e[fl];
    try {
        e[fl] = void 0;
        var n = !0
    } catch {}
    var s = o$.call(e);
    return n && (t ? e[fl] = r : delete e[fl]),
    s
}
var u$ = l$
  , c$ = Object.prototype
  , d$ = c$.toString;
function f$(e) {
    return d$.call(e)
}
var h$ = f$
  , o0 = Bf
  , m$ = u$
  , p$ = h$
  , y$ = "[object Null]"
  , g$ = "[object Undefined]"
  , l0 = o0 ? o0.toStringTag : void 0;
function v$(e) {
    return e == null ? e === void 0 ? g$ : y$ : l0 && l0 in Object(e) ? m$(e) : p$(e)
}
var Ku = v$;
function b$(e) {
    var t = typeof e;
    return e != null && (t == "object" || t == "function")
}
var Fy = b$
  , x$ = Ku
  , w$ = Fy
  , S$ = "[object AsyncFunction]"
  , k$ = "[object Function]"
  , E$ = "[object GeneratorFunction]"
  , _$ = "[object Proxy]";
function T$(e) {
    if (!w$(e))
        return !1;
    var t = x$(e);
    return t == k$ || t == E$ || t == S$ || t == _$
}
var Sw = T$
  , C$ = ys
  , P$ = C$["__core-js_shared__"]
  , $$ = P$
  , Ih = $$
  , u0 = function() {
    var e = /[^.]+$/.exec(Ih && Ih.keys && Ih.keys.IE_PROTO || "");
    return e ? "Symbol(src)_1." + e : ""
}();
function N$(e) {
    return !!u0 && u0 in e
}
var j$ = N$
  , I$ = Function.prototype
  , R$ = I$.toString;
function O$(e) {
    if (e != null) {
        try {
            return R$.call(e)
        } catch {}
        try {
            return e + ""
        } catch {}
    }
    return ""
}
var kw = O$
  , M$ = Sw
  , A$ = j$
  , L$ = Fy
  , D$ = kw
  , F$ = /[\\^$.*+?()[\]{}|]/g
  , z$ = /^\[object .+?Constructor\]$/
  , U$ = Function.prototype
  , V$ = Object.prototype
  , B$ = U$.toString
  , W$ = V$.hasOwnProperty
  , q$ = RegExp("^" + B$.call(W$).replace(F$, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function H$(e) {
    if (!L$(e) || A$(e))
        return !1;
    var t = M$(e) ? q$ : z$;
    return t.test(D$(e))
}
var Z$ = H$;
function K$(e, t) {
    return e == null ? void 0 : e[t]
}
var Q$ = K$
  , G$ = Z$
  , Y$ = Q$;
function J$(e, t) {
    var r = Y$(e, t);
    return G$(r) ? r : void 0
}
var Wo = J$
  , X$ = Wo
  , eN = ys
  , tN = X$(eN, "Map")
  , zy = tN
  , rN = Wo
  , nN = rN(Object, "create")
  , Wf = nN
  , c0 = Wf;
function sN() {
    this.__data__ = c0 ? c0(null) : {},
    this.size = 0
}
var iN = sN;
function aN(e) {
    var t = this.has(e) && delete this.__data__[e];
    return this.size -= t ? 1 : 0,
    t
}
var oN = aN
  , lN = Wf
  , uN = "__lodash_hash_undefined__"
  , cN = Object.prototype
  , dN = cN.hasOwnProperty;
function fN(e) {
    var t = this.__data__;
    if (lN) {
        var r = t[e];
        return r === uN ? void 0 : r
    }
    return dN.call(t, e) ? t[e] : void 0
}
var hN = fN
  , mN = Wf
  , pN = Object.prototype
  , yN = pN.hasOwnProperty;
function gN(e) {
    var t = this.__data__;
    return mN ? t[e] !== void 0 : yN.call(t, e)
}
var vN = gN
  , bN = Wf
  , xN = "__lodash_hash_undefined__";
function wN(e, t) {
    var r = this.__data__;
    return this.size += this.has(e) ? 0 : 1,
    r[e] = bN && t === void 0 ? xN : t,
    this
}
var SN = wN
  , kN = iN
  , EN = oN
  , _N = hN
  , TN = vN
  , CN = SN;
function qo(e) {
    var t = -1
      , r = e == null ? 0 : e.length;
    for (this.clear(); ++t < r; ) {
        var n = e[t];
        this.set(n[0], n[1])
    }
}
qo.prototype.clear = kN;
qo.prototype.delete = EN;
qo.prototype.get = _N;
qo.prototype.has = TN;
qo.prototype.set = CN;
var PN = qo
  , d0 = PN
  , $N = Vf
  , NN = zy;
function jN() {
    this.size = 0,
    this.__data__ = {
        hash: new d0,
        map: new (NN || $N),
        string: new d0
    }
}
var IN = jN;
function RN(e) {
    var t = typeof e;
    return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? e !== "__proto__" : e === null
}
var ON = RN
  , MN = ON;
function AN(e, t) {
    var r = e.__data__;
    return MN(t) ? r[typeof t == "string" ? "string" : "hash"] : r.map
}
var qf = AN
  , LN = qf;
function DN(e) {
    var t = LN(this, e).delete(e);
    return this.size -= t ? 1 : 0,
    t
}
var FN = DN
  , zN = qf;
function UN(e) {
    return zN(this, e).get(e)
}
var VN = UN
  , BN = qf;
function WN(e) {
    return BN(this, e).has(e)
}
var qN = WN
  , HN = qf;
function ZN(e, t) {
    var r = HN(this, e)
      , n = r.size;
    return r.set(e, t),
    this.size += r.size == n ? 0 : 1,
    this
}
var KN = ZN
  , QN = IN
  , GN = FN
  , YN = VN
  , JN = qN
  , XN = KN;
function Ho(e) {
    var t = -1
      , r = e == null ? 0 : e.length;
    for (this.clear(); ++t < r; ) {
        var n = e[t];
        this.set(n[0], n[1])
    }
}
Ho.prototype.clear = QN;
Ho.prototype.delete = GN;
Ho.prototype.get = YN;
Ho.prototype.has = JN;
Ho.prototype.set = XN;
var Uy = Ho
  , ej = Vf
  , tj = zy
  , rj = Uy
  , nj = 200;
function sj(e, t) {
    var r = this.__data__;
    if (r instanceof ej) {
        var n = r.__data__;
        if (!tj || n.length < nj - 1)
            return n.push([e, t]),
            this.size = ++r.size,
            this;
        r = this.__data__ = new rj(n)
    }
    return r.set(e, t),
    this.size = r.size,
    this
}
var ij = sj
  , aj = Vf
  , oj = ZP
  , lj = QP
  , uj = YP
  , cj = XP
  , dj = ij;
function Zo(e) {
    var t = this.__data__ = new aj(e);
    this.size = t.size
}
Zo.prototype.clear = oj;
Zo.prototype.delete = lj;
Zo.prototype.get = uj;
Zo.prototype.has = cj;
Zo.prototype.set = dj;
var Ew = Zo
  , fj = "__lodash_hash_undefined__";
function hj(e) {
    return this.__data__.set(e, fj),
    this
}
var mj = hj;
function pj(e) {
    return this.__data__.has(e)
}
var yj = pj
  , gj = Uy
  , vj = mj
  , bj = yj;
function zd(e) {
    var t = -1
      , r = e == null ? 0 : e.length;
    for (this.__data__ = new gj; ++t < r; )
        this.add(e[t])
}
zd.prototype.add = zd.prototype.push = vj;
zd.prototype.has = bj;
var _w = zd;
function xj(e, t) {
    for (var r = -1, n = e == null ? 0 : e.length; ++r < n; )
        if (t(e[r], r, e))
            return !0;
    return !1
}
var wj = xj;
function Sj(e, t) {
    return e.has(t)
}
var Tw = Sj
  , kj = _w
  , Ej = wj
  , _j = Tw
  , Tj = 1
  , Cj = 2;
function Pj(e, t, r, n, s, i) {
    var a = r & Tj
      , o = e.length
      , l = t.length;
    if (o != l && !(a && l > o))
        return !1;
    var c = i.get(e)
      , f = i.get(t);
    if (c && f)
        return c == t && f == e;
    var h = -1
      , m = !0
      , y = r & Cj ? new kj : void 0;
    for (i.set(e, t),
    i.set(t, e); ++h < o; ) {
        var k = e[h]
          , x = t[h];
        if (n)
            var w = a ? n(x, k, h, t, e, i) : n(k, x, h, e, t, i);
        if (w !== void 0) {
            if (w)
                continue;
            m = !1;
            break
        }
        if (y) {
            if (!Ej(t, function(v, p) {
                if (!_j(y, p) && (k === v || s(k, v, r, n, i)))
                    return y.push(p)
            })) {
                m = !1;
                break
            }
        } else if (!(k === x || s(k, x, r, n, i))) {
            m = !1;
            break
        }
    }
    return i.delete(e),
    i.delete(t),
    m
}
var Cw = Pj
  , $j = ys
  , Nj = $j.Uint8Array
  , jj = Nj;
function Ij(e) {
    var t = -1
      , r = Array(e.size);
    return e.forEach(function(n, s) {
        r[++t] = [s, n]
    }),
    r
}
var Rj = Ij;
function Oj(e) {
    var t = -1
      , r = Array(e.size);
    return e.forEach(function(n) {
        r[++t] = n
    }),
    r
}
var Vy = Oj
  , f0 = Bf
  , h0 = jj
  , Mj = bw
  , Aj = Cw
  , Lj = Rj
  , Dj = Vy
  , Fj = 1
  , zj = 2
  , Uj = "[object Boolean]"
  , Vj = "[object Date]"
  , Bj = "[object Error]"
  , Wj = "[object Map]"
  , qj = "[object Number]"
  , Hj = "[object RegExp]"
  , Zj = "[object Set]"
  , Kj = "[object String]"
  , Qj = "[object Symbol]"
  , Gj = "[object ArrayBuffer]"
  , Yj = "[object DataView]"
  , m0 = f0 ? f0.prototype : void 0
  , Rh = m0 ? m0.valueOf : void 0;
function Jj(e, t, r, n, s, i, a) {
    switch (r) {
    case Yj:
        if (e.byteLength != t.byteLength || e.byteOffset != t.byteOffset)
            return !1;
        e = e.buffer,
        t = t.buffer;
    case Gj:
        return !(e.byteLength != t.byteLength || !i(new h0(e), new h0(t)));
    case Uj:
    case Vj:
    case qj:
        return Mj(+e, +t);
    case Bj:
        return e.name == t.name && e.message == t.message;
    case Hj:
    case Kj:
        return e == t + "";
    case Wj:
        var o = Lj;
    case Zj:
        var l = n & Fj;
        if (o || (o = Dj),
        e.size != t.size && !l)
            return !1;
        var c = a.get(e);
        if (c)
            return c == t;
        n |= zj,
        a.set(e, t);
        var f = Aj(o(e), o(t), n, s, i, a);
        return a.delete(e),
        f;
    case Qj:
        if (Rh)
            return Rh.call(e) == Rh.call(t)
    }
    return !1
}
var Xj = Jj;
function e4(e, t) {
    for (var r = -1, n = t.length, s = e.length; ++r < n; )
        e[s + r] = t[r];
    return e
}
var t4 = e4
  , r4 = Array.isArray
  , yi = r4
  , n4 = t4
  , s4 = yi;
function i4(e, t, r) {
    var n = t(e);
    return s4(e) ? n : n4(n, r(e))
}
var a4 = i4;
function o4(e, t) {
    for (var r = -1, n = e == null ? 0 : e.length, s = 0, i = []; ++r < n; ) {
        var a = e[r];
        t(a, r, e) && (i[s++] = a)
    }
    return i
}
var l4 = o4;
function u4() {
    return []
}
var c4 = u4
  , d4 = l4
  , f4 = c4
  , h4 = Object.prototype
  , m4 = h4.propertyIsEnumerable
  , p0 = Object.getOwnPropertySymbols
  , p4 = p0 ? function(e) {
    return e == null ? [] : (e = Object(e),
    d4(p0(e), function(t) {
        return m4.call(e, t)
    }))
}
: f4
  , y4 = p4;
function g4(e, t) {
    for (var r = -1, n = Array(e); ++r < e; )
        n[r] = t(r);
    return n
}
var v4 = g4;
function b4(e) {
    return e != null && typeof e == "object"
}
var Qu = b4
  , x4 = Ku
  , w4 = Qu
  , S4 = "[object Arguments]";
function k4(e) {
    return w4(e) && x4(e) == S4
}
var E4 = k4
  , y0 = E4
  , _4 = Qu
  , Pw = Object.prototype
  , T4 = Pw.hasOwnProperty
  , C4 = Pw.propertyIsEnumerable
  , P4 = y0(function() {
    return arguments
}()) ? y0 : function(e) {
    return _4(e) && T4.call(e, "callee") && !C4.call(e, "callee")
}
  , $w = P4
  , Ud = {
    exports: {}
};
function $4() {
    return !1
}
var N4 = $4;
Ud.exports;
(function(e, t) {
    var r = ys
      , n = N4
      , s = t && !t.nodeType && t
      , i = s && !0 && e && !e.nodeType && e
      , a = i && i.exports === s
      , o = a ? r.Buffer : void 0
      , l = o ? o.isBuffer : void 0
      , c = l || n;
    e.exports = c
}
)(Ud, Ud.exports);
var Nw = Ud.exports
  , j4 = 9007199254740991
  , I4 = /^(?:0|[1-9]\d*)$/;
function R4(e, t) {
    var r = typeof e;
    return t = t ?? j4,
    !!t && (r == "number" || r != "symbol" && I4.test(e)) && e > -1 && e % 1 == 0 && e < t
}
var jw = R4
  , O4 = 9007199254740991;
function M4(e) {
    return typeof e == "number" && e > -1 && e % 1 == 0 && e <= O4
}
var By = M4
  , A4 = Ku
  , L4 = By
  , D4 = Qu
  , F4 = "[object Arguments]"
  , z4 = "[object Array]"
  , U4 = "[object Boolean]"
  , V4 = "[object Date]"
  , B4 = "[object Error]"
  , W4 = "[object Function]"
  , q4 = "[object Map]"
  , H4 = "[object Number]"
  , Z4 = "[object Object]"
  , K4 = "[object RegExp]"
  , Q4 = "[object Set]"
  , G4 = "[object String]"
  , Y4 = "[object WeakMap]"
  , J4 = "[object ArrayBuffer]"
  , X4 = "[object DataView]"
  , eI = "[object Float32Array]"
  , tI = "[object Float64Array]"
  , rI = "[object Int8Array]"
  , nI = "[object Int16Array]"
  , sI = "[object Int32Array]"
  , iI = "[object Uint8Array]"
  , aI = "[object Uint8ClampedArray]"
  , oI = "[object Uint16Array]"
  , lI = "[object Uint32Array]"
  , tt = {};
tt[eI] = tt[tI] = tt[rI] = tt[nI] = tt[sI] = tt[iI] = tt[aI] = tt[oI] = tt[lI] = !0;
tt[F4] = tt[z4] = tt[J4] = tt[U4] = tt[X4] = tt[V4] = tt[B4] = tt[W4] = tt[q4] = tt[H4] = tt[Z4] = tt[K4] = tt[Q4] = tt[G4] = tt[Y4] = !1;
function uI(e) {
    return D4(e) && L4(e.length) && !!tt[A4(e)]
}
var cI = uI;
function dI(e) {
    return function(t) {
        return e(t)
    }
}
var fI = dI
  , Vd = {
    exports: {}
};
Vd.exports;
(function(e, t) {
    var r = xw
      , n = t && !t.nodeType && t
      , s = n && !0 && e && !e.nodeType && e
      , i = s && s.exports === n
      , a = i && r.process
      , o = function() {
        try {
            var l = s && s.require && s.require("util").types;
            return l || a && a.binding && a.binding("util")
        } catch {}
    }();
    e.exports = o
}
)(Vd, Vd.exports);
var hI = Vd.exports
  , mI = cI
  , pI = fI
  , g0 = hI
  , v0 = g0 && g0.isTypedArray
  , yI = v0 ? pI(v0) : mI
  , Iw = yI
  , gI = v4
  , vI = $w
  , bI = yi
  , xI = Nw
  , wI = jw
  , SI = Iw
  , kI = Object.prototype
  , EI = kI.hasOwnProperty;
function _I(e, t) {
    var r = bI(e)
      , n = !r && vI(e)
      , s = !r && !n && xI(e)
      , i = !r && !n && !s && SI(e)
      , a = r || n || s || i
      , o = a ? gI(e.length, String) : []
      , l = o.length;
    for (var c in e)
        (t || EI.call(e, c)) && !(a && (c == "length" || s && (c == "offset" || c == "parent") || i && (c == "buffer" || c == "byteLength" || c == "byteOffset") || wI(c, l))) && o.push(c);
    return o
}
var TI = _I
  , CI = Object.prototype;
function PI(e) {
    var t = e && e.constructor
      , r = typeof t == "function" && t.prototype || CI;
    return e === r
}
var $I = PI;
function NI(e, t) {
    return function(r) {
        return e(t(r))
    }
}
var jI = NI
  , II = jI
  , RI = II(Object.keys, Object)
  , OI = RI
  , MI = $I
  , AI = OI
  , LI = Object.prototype
  , DI = LI.hasOwnProperty;
function FI(e) {
    if (!MI(e))
        return AI(e);
    var t = [];
    for (var r in Object(e))
        DI.call(e, r) && r != "constructor" && t.push(r);
    return t
}
var zI = FI
  , UI = Sw
  , VI = By;
function BI(e) {
    return e != null && VI(e.length) && !UI(e)
}
var WI = BI
  , qI = TI
  , HI = zI
  , ZI = WI;
function KI(e) {
    return ZI(e) ? qI(e) : HI(e)
}
var Rw = KI
  , QI = a4
  , GI = y4
  , YI = Rw;
function JI(e) {
    return QI(e, YI, GI)
}
var XI = JI
  , b0 = XI
  , e3 = 1
  , t3 = Object.prototype
  , r3 = t3.hasOwnProperty;
function n3(e, t, r, n, s, i) {
    var a = r & e3
      , o = b0(e)
      , l = o.length
      , c = b0(t)
      , f = c.length;
    if (l != f && !a)
        return !1;
    for (var h = l; h--; ) {
        var m = o[h];
        if (!(a ? m in t : r3.call(t, m)))
            return !1
    }
    var y = i.get(e)
      , k = i.get(t);
    if (y && k)
        return y == t && k == e;
    var x = !0;
    i.set(e, t),
    i.set(t, e);
    for (var w = a; ++h < l; ) {
        m = o[h];
        var v = e[m]
          , p = t[m];
        if (n)
            var S = a ? n(p, v, m, t, e, i) : n(v, p, m, e, t, i);
        if (!(S === void 0 ? v === p || s(v, p, r, n, i) : S)) {
            x = !1;
            break
        }
        w || (w = m == "constructor")
    }
    if (x && !w) {
        var P = e.constructor
          , j = t.constructor;
        P != j && "constructor"in e && "constructor"in t && !(typeof P == "function" && P instanceof P && typeof j == "function" && j instanceof j) && (x = !1)
    }
    return i.delete(e),
    i.delete(t),
    x
}
var s3 = n3
  , i3 = Wo
  , a3 = ys
  , o3 = i3(a3, "DataView")
  , l3 = o3
  , u3 = Wo
  , c3 = ys
  , d3 = u3(c3, "Promise")
  , f3 = d3
  , h3 = Wo
  , m3 = ys
  , p3 = h3(m3, "Set")
  , Ow = p3
  , y3 = Wo
  , g3 = ys
  , v3 = y3(g3, "WeakMap")
  , b3 = v3
  , Fm = l3
  , zm = zy
  , Um = f3
  , Vm = Ow
  , Bm = b3
  , Mw = Ku
  , Ko = kw
  , x0 = "[object Map]"
  , x3 = "[object Object]"
  , w0 = "[object Promise]"
  , S0 = "[object Set]"
  , k0 = "[object WeakMap]"
  , E0 = "[object DataView]"
  , w3 = Ko(Fm)
  , S3 = Ko(zm)
  , k3 = Ko(Um)
  , E3 = Ko(Vm)
  , _3 = Ko(Bm)
  , Ii = Mw;
(Fm && Ii(new Fm(new ArrayBuffer(1))) != E0 || zm && Ii(new zm) != x0 || Um && Ii(Um.resolve()) != w0 || Vm && Ii(new Vm) != S0 || Bm && Ii(new Bm) != k0) && (Ii = function(e) {
    var t = Mw(e)
      , r = t == x3 ? e.constructor : void 0
      , n = r ? Ko(r) : "";
    if (n)
        switch (n) {
        case w3:
            return E0;
        case S3:
            return x0;
        case k3:
            return w0;
        case E3:
            return S0;
        case _3:
            return k0
        }
    return t
}
);
var T3 = Ii
  , Oh = Ew
  , C3 = Cw
  , P3 = Xj
  , $3 = s3
  , _0 = T3
  , T0 = yi
  , C0 = Nw
  , N3 = Iw
  , j3 = 1
  , P0 = "[object Arguments]"
  , $0 = "[object Array]"
  , Pc = "[object Object]"
  , I3 = Object.prototype
  , N0 = I3.hasOwnProperty;
function R3(e, t, r, n, s, i) {
    var a = T0(e)
      , o = T0(t)
      , l = a ? $0 : _0(e)
      , c = o ? $0 : _0(t);
    l = l == P0 ? Pc : l,
    c = c == P0 ? Pc : c;
    var f = l == Pc
      , h = c == Pc
      , m = l == c;
    if (m && C0(e)) {
        if (!C0(t))
            return !1;
        a = !0,
        f = !1
    }
    if (m && !f)
        return i || (i = new Oh),
        a || N3(e) ? C3(e, t, r, n, s, i) : P3(e, t, l, r, n, s, i);
    if (!(r & j3)) {
        var y = f && N0.call(e, "__wrapped__")
          , k = h && N0.call(t, "__wrapped__");
        if (y || k) {
            var x = y ? e.value() : e
              , w = k ? t.value() : t;
            return i || (i = new Oh),
            s(x, w, r, n, i)
        }
    }
    return m ? (i || (i = new Oh),
    $3(e, t, r, n, s, i)) : !1
}
var O3 = R3
  , M3 = O3
  , j0 = Qu;
function Aw(e, t, r, n, s) {
    return e === t ? !0 : e == null || t == null || !j0(e) && !j0(t) ? e !== e && t !== t : M3(e, t, r, n, Aw, s)
}
var Lw = Aw
  , A3 = Ew
  , L3 = Lw
  , D3 = 1
  , F3 = 2;
function z3(e, t, r, n) {
    var s = r.length
      , i = s
      , a = !n;
    if (e == null)
        return !i;
    for (e = Object(e); s--; ) {
        var o = r[s];
        if (a && o[2] ? o[1] !== e[o[0]] : !(o[0]in e))
            return !1
    }
    for (; ++s < i; ) {
        o = r[s];
        var l = o[0]
          , c = e[l]
          , f = o[1];
        if (a && o[2]) {
            if (c === void 0 && !(l in e))
                return !1
        } else {
            var h = new A3;
            if (n)
                var m = n(c, f, l, e, t, h);
            if (!(m === void 0 ? L3(f, c, D3 | F3, n, h) : m))
                return !1
        }
    }
    return !0
}
var U3 = z3
  , V3 = Fy;
function B3(e) {
    return e === e && !V3(e)
}
var Dw = B3
  , W3 = Dw
  , q3 = Rw;
function H3(e) {
    for (var t = q3(e), r = t.length; r--; ) {
        var n = t[r]
          , s = e[n];
        t[r] = [n, s, W3(s)]
    }
    return t
}
var Z3 = H3;
function K3(e, t) {
    return function(r) {
        return r == null ? !1 : r[e] === t && (t !== void 0 || e in Object(r))
    }
}
var Fw = K3
  , Q3 = U3
  , G3 = Z3
  , Y3 = Fw;
function J3(e) {
    var t = G3(e);
    return t.length == 1 && t[0][2] ? Y3(t[0][0], t[0][1]) : function(r) {
        return r === e || Q3(r, e, t)
    }
}
var X3 = J3
  , eR = Ku
  , tR = Qu
  , rR = "[object Symbol]";
function nR(e) {
    return typeof e == "symbol" || tR(e) && eR(e) == rR
}
var Wy = nR
  , sR = yi
  , iR = Wy
  , aR = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/
  , oR = /^\w*$/;
function lR(e, t) {
    if (sR(e))
        return !1;
    var r = typeof e;
    return r == "number" || r == "symbol" || r == "boolean" || e == null || iR(e) ? !0 : oR.test(e) || !aR.test(e) || t != null && e in Object(t)
}
var qy = lR
  , zw = Uy
  , uR = "Expected a function";
function Hy(e, t) {
    if (typeof e != "function" || t != null && typeof t != "function")
        throw new TypeError(uR);
    var r = function() {
        var n = arguments
          , s = t ? t.apply(this, n) : n[0]
          , i = r.cache;
        if (i.has(s))
            return i.get(s);
        var a = e.apply(this, n);
        return r.cache = i.set(s, a) || i,
        a
    };
    return r.cache = new (Hy.Cache || zw),
    r
}
Hy.Cache = zw;
var cR = Hy
  , dR = cR
  , fR = 500;
function hR(e) {
    var t = dR(e, function(n) {
        return r.size === fR && r.clear(),
        n
    })
      , r = t.cache;
    return t
}
var mR = hR
  , pR = mR
  , yR = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g
  , gR = /\\(\\)?/g
  , vR = pR(function(e) {
    var t = [];
    return e.charCodeAt(0) === 46 && t.push(""),
    e.replace(yR, function(r, n, s, i) {
        t.push(s ? i.replace(gR, "$1") : n || r)
    }),
    t
})
  , bR = vR;
function xR(e, t) {
    for (var r = -1, n = e == null ? 0 : e.length, s = Array(n); ++r < n; )
        s[r] = t(e[r], r, e);
    return s
}
var wR = xR
  , I0 = Bf
  , SR = wR
  , kR = yi
  , ER = Wy
  , R0 = I0 ? I0.prototype : void 0
  , O0 = R0 ? R0.toString : void 0;
function Uw(e) {
    if (typeof e == "string")
        return e;
    if (kR(e))
        return SR(e, Uw) + "";
    if (ER(e))
        return O0 ? O0.call(e) : "";
    var t = e + "";
    return t == "0" && 1 / e == -1 / 0 ? "-0" : t
}
var _R = Uw
  , TR = _R;
function CR(e) {
    return e == null ? "" : TR(e)
}
var PR = CR
  , $R = yi
  , NR = qy
  , jR = bR
  , IR = PR;
function RR(e, t) {
    return $R(e) ? e : NR(e, t) ? [e] : jR(IR(e))
}
var Vw = RR
  , OR = Wy;
function MR(e) {
    if (typeof e == "string" || OR(e))
        return e;
    var t = e + "";
    return t == "0" && 1 / e == -1 / 0 ? "-0" : t
}
var Hf = MR
  , AR = Vw
  , LR = Hf;
function DR(e, t) {
    t = AR(t, e);
    for (var r = 0, n = t.length; e != null && r < n; )
        e = e[LR(t[r++])];
    return r && r == n ? e : void 0
}
var Bw = DR
  , FR = Bw;
function zR(e, t, r) {
    var n = e == null ? void 0 : FR(e, t);
    return n === void 0 ? r : n
}
var UR = zR;
function VR(e, t) {
    return e != null && t in Object(e)
}
var BR = VR
  , WR = Vw
  , qR = $w
  , HR = yi
  , ZR = jw
  , KR = By
  , QR = Hf;
function GR(e, t, r) {
    t = WR(t, e);
    for (var n = -1, s = t.length, i = !1; ++n < s; ) {
        var a = QR(t[n]);
        if (!(i = e != null && r(e, a)))
            break;
        e = e[a]
    }
    return i || ++n != s ? i : (s = e == null ? 0 : e.length,
    !!s && KR(s) && ZR(a, s) && (HR(e) || qR(e)))
}
var YR = GR
  , JR = BR
  , XR = YR;
function eO(e, t) {
    return e != null && XR(e, t, JR)
}
var tO = eO
  , rO = Lw
  , nO = UR
  , sO = tO
  , iO = qy
  , aO = Dw
  , oO = Fw
  , lO = Hf
  , uO = 1
  , cO = 2;
function dO(e, t) {
    return iO(e) && aO(t) ? oO(lO(e), t) : function(r) {
        var n = nO(r, e);
        return n === void 0 && n === t ? sO(r, e) : rO(t, n, uO | cO)
    }
}
var fO = dO;
function hO(e) {
    return e
}
var mO = hO;
function pO(e) {
    return function(t) {
        return t == null ? void 0 : t[e]
    }
}
var yO = pO
  , gO = Bw;
function vO(e) {
    return function(t) {
        return gO(t, e)
    }
}
var bO = vO
  , xO = yO
  , wO = bO
  , SO = qy
  , kO = Hf;
function EO(e) {
    return SO(e) ? xO(kO(e)) : wO(e)
}
var _O = EO
  , TO = X3
  , CO = fO
  , PO = mO
  , $O = yi
  , NO = _O;
function jO(e) {
    return typeof e == "function" ? e : e == null ? PO : typeof e == "object" ? $O(e) ? CO(e[0], e[1]) : TO(e) : NO(e)
}
var IO = jO;
function RO(e, t, r, n) {
    for (var s = e.length, i = r + (n ? 1 : -1); n ? i-- : ++i < s; )
        if (t(e[i], i, e))
            return i;
    return -1
}
var OO = RO;
function MO(e) {
    return e !== e
}
var AO = MO;
function LO(e, t, r) {
    for (var n = r - 1, s = e.length; ++n < s; )
        if (e[n] === t)
            return n;
    return -1
}
var DO = LO
  , FO = OO
  , zO = AO
  , UO = DO;
function VO(e, t, r) {
    return t === t ? UO(e, t, r) : FO(e, zO, r)
}
var BO = VO
  , WO = BO;
function qO(e, t) {
    var r = e == null ? 0 : e.length;
    return !!r && WO(e, t, 0) > -1
}
var HO = qO;
function ZO(e, t, r) {
    for (var n = -1, s = e == null ? 0 : e.length; ++n < s; )
        if (r(t, e[n]))
            return !0;
    return !1
}
var KO = ZO;
function QO() {}
var GO = QO
  , Mh = Ow
  , YO = GO
  , JO = Vy
  , XO = 1 / 0
  , e5 = Mh && 1 / JO(new Mh([, -0]))[1] == XO ? function(e) {
    return new Mh(e)
}
: YO
  , t5 = e5
  , r5 = _w
  , n5 = HO
  , s5 = KO
  , i5 = Tw
  , a5 = t5
  , o5 = Vy
  , l5 = 200;
function u5(e, t, r) {
    var n = -1
      , s = n5
      , i = e.length
      , a = !0
      , o = []
      , l = o;
    if (r)
        a = !1,
        s = s5;
    else if (i >= l5) {
        var c = t ? null : a5(e);
        if (c)
            return o5(c);
        a = !1,
        s = i5,
        l = new r5
    } else
        l = t ? [] : o;
    e: for (; ++n < i; ) {
        var f = e[n]
          , h = t ? t(f) : f;
        if (f = r || f !== 0 ? f : 0,
        a && h === h) {
            for (var m = l.length; m--; )
                if (l[m] === h)
                    continue e;
            t && l.push(h),
            o.push(f)
        } else
            s(l, h, r) || (l !== o && l.push(h),
            o.push(f))
    }
    return o
}
var c5 = u5
  , d5 = IO
  , f5 = c5;
function h5(e, t) {
    return e && e.length ? f5(e, d5(t)) : []
}
var m5 = h5;
const p5 = _y(m5)
  , Ys = {
    get(e) {
        const t = localStorage.getItem(e);
        return t ? JSON.parse(t) : void 0
    },
    set(e, t) {
        return localStorage.setItem(e, JSON.stringify(t))
    },
    delete(e) {
        return localStorage.removeItem(e)
    }
}
  , M0 = Ys.get("jwt_exp")
  , y5 = {
    accessToken: Ys.get("access_token"),
    jwtExpMs: M0 ? Number(M0) : 0,
    status: "PENDING",
    currentUser: void 0,
    currentAvatarId: void 0,
    profileChangeCooldowns: {
        username: void 0,
        displayName: void 0
    },
    device: typeof window < "u" && "vuplex"in window ? "headset" : "browser",
    balance: 0,
    role: "player",
    isJoinable: !0,
    isAdmin: !1,
    isModerator: !1,
    editingAvatarId: void 0,
    recentUsers: []
}
  , Se = ya({
    ...y5
});
if (Se.device === "headset") {
    let e = "PENDING";
    iw(Se, () => {
        e !== Se.status && (e = Se.status,
        Ve.emit("webapp:auth_status", {
            status: Se.status
        }))
    }
    )
}
function Je() {
    return Ay(Se)
}
async function Zy() {
    const e = await Ww();
    return e.ok && (await Ve.emit("sync:store", {
        balance: e.value
    }),
    Se.balance = e.value),
    e
}
async function Zf() {
    try {
        const e = await I6();
        return e.ok && (Se.status = "AUTHORIZED",
        Se.currentUser = {
            id: e.value.id,
            username: e.value.username,
            displayName: e.value.displayName
        },
        Se.profileChangeCooldowns = {
            username: e.value.profileChangeCooldowns.username ? new Date(e.value.profileChangeCooldowns.username) : void 0,
            displayName: e.value.profileChangeCooldowns.displayName ? new Date(e.value.profileChangeCooldowns.displayName) : void 0
        },
        Se.currentAvatarId = e.value.currentAvatarId ?? void 0,
        Se.balance = e.value.balance,
        Se.role = e.value.role,
        Se.isJoinable = e.value.isJoinable,
        Se.isAdmin = e.value.role === "admin",
        Se.isModerator = Se.isAdmin || e.value.role === "moderator"),
        e
    } catch {
        return Se.status = "UNAUTHORIZED",
        Se.balance = 0,
        Se.role = "player",
        Se.isAdmin = !1,
        Se.isModerator = !1,
        Rm({
            code: "UNAUTHORIZED",
            message: "Unable to verify your session"
        })
    }
}
async function g5(e, t) {
    const r = await f6({
        nonce: t
    }, {
        headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${e}`
        }
    });
    r.ok && Ky(r.value)
}
async function v5(e) {
    const t = new Set(Se.recentUsers.map(s => s.id))
      , r = new Array;
    for (const s of e)
        t.has(s) || r.push(s);
    if (r.length === 0)
        return;
    const n = await qw({
        userId: r
    });
    if (n.ok && Array.isArray(n.value)) {
        const s = n.value.map(a => ({
            ...a,
            seenAt: new Date
        }))
          , i = p5([...s, ...Se.recentUsers], "id").sort( (a, o) => o.seenAt.getTime() - a.seenAt.getTime());
        Se.recentUsers = i.slice(0, 60)
    }
}
let hl;
async function A0() {
    if (hl)
        return hl;
    const e = Ys.get("refresh_token");
    if (!e)
        return {
            ok: !1,
            error: {
                code: "BAD_REQUEST",
                message: "No refresh token"
            }
        };
    hl = z6({
        headers: {
            Authorization: `Bearer ${e}`
        }
    });
    const t = await hl;
    return t.ok && Ky(t.value),
    setTimeout( () => {
        hl = void 0
    }
    , 1e4),
    t
}
function Ky(e) {
    const t = e.exp * 1e3;
    Ys.set("access_token", e.accessToken),
    Ys.set("refresh_token", e.refreshToken),
    Ys.set("jwt_exp", t),
    Se.accessToken = e.accessToken,
    Se.jwtExpMs = t
}
const b5 = 2500
  , _e = async (e, t) => {
    const r = (t == null ? void 0 : t.rateLimitedAttempt) || 0;
    if (r > 0) {
        const o = gu();
        await new Promise(l => setTimeout( () => {
            o(),
            l(!0)
        }
        , b5 * r))
    }
    let n = "";
    const s = [];
    if (e.params) {
        for (const [o,l] of Object.entries(e.params)) {
            if (Array.isArray(l)) {
                for (const c of l)
                    s.push(`${o}=${c}`);
                break
            }
            l && s.push(`${o}=${l}`)
        }
        s.length && (n = `?${s.join("&")}`)
    }
    const i = e.url !== "/sessions/vr-fork/refresh"
      , a = Se.jwtExpMs < Date.now() + 1e3 * 60 * 2;
    i && a && await A0(),
    e.headers = {
        ...Se.accessToken ? {
            Authorization: `Bearer ${Se.accessToken}`
        } : {},
        ...e.headers
    };
    try {
        const o = await fetch(`/api${e.url}${n}`, {
            ...e,
            method: e.method.toUpperCase(),
            body: JSON.stringify(e.data),
            signal: e.signal
        })
          , c = (o.headers.get("Content-Type") || "").includes("application/json") ? await o.json() : await o.text();
        if (!o.ok) {
            if (o.status === 401) {
                if (t != null && t.isAuthRetry && (await A0()).ok)
                    return _e(e, {
                        rateLimitedAttempt: r,
                        isAuthRetry: !0
                    });
                Se.status = "UNAUTHORIZED"
            }
            return r < 3 && o.status === 429 || o.status === 504 ? _e(e, {
                rateLimitedAttempt: r + 1
            }) : Rm(c)
        }
        return ra(c)
    } catch (o) {
        return Rm(o)
    }
}
;
function x5() {
    return "/admin/inventory-items"
}
async function w5(e, t={}) {
    const {client: r=_e, ...n} = t;
    return await r({
        method: "POST",
        url: x5().toString(),
        data: e,
        ...n,
        headers: {
            "Content-Type": "application/json; charset=utf-8",
            ...n.headers
        }
    })
}
function S5(e) {
    return `/admin/blobs/${e}`
}
async function k5(e, t={}) {
    const {client: r=_e, ...n} = t;
    return await r({
        method: "DELETE",
        url: S5(e).toString(),
        ...n
    })
}
function E5(e) {
    return `/admin/products/${e}`
}
async function _5(e, t={}) {
    const {client: r=_e, ...n} = t;
    return await r({
        method: "PUT",
        url: E5(e).toString(),
        ...n
    })
}
function T5(e) {
    return `/admin/reports/${e}/blob`
}
async function C5(e, t={}) {
    const {client: r=_e, ...n} = t;
    return await r({
        method: "GET",
        url: T5(e).toString(),
        ...n
    })
}
function P5(e) {
    return `/admin/reports/${e}`
}
async function $5(e, t={}) {
    const {client: r=_e, ...n} = t;
    return await r({
        method: "GET",
        url: P5(e).toString(),
        ...n
    })
}
function N5(e) {
    return `/admin/users/${e}/current-room`
}
async function j5(e, t={}) {
    const {client: r=_e, ...n} = t;
    return await r({
        method: "PUT",
        url: N5(e).toString(),
        ...n
    })
}
function I5(e) {
    return `/admin/users/${e}/inventory-items`
}
async function R5(e, t={}) {
    const {client: r=_e, ...n} = t;
    return await r({
        method: "GET",
        url: I5(e).toString(),
        ...n
    })
}
function O5(e) {
    return `/admin/users/${e}/blobs`
}
async function M5(e, t={}) {
    const {client: r=_e, ...n} = t;
    return await r({
        method: "GET",
        url: O5(e).toString(),
        ...n
    })
}
function A5() {
    return "/admin/products"
}
async function L5(e, t={}) {
    const {client: r=_e, ...n} = t;
    return await r({
        method: "GET",
        url: A5().toString(),
        params: e,
        ...n
    })
}
function D5() {
    return "/admin/reports"
}
async function F5(e, t={}) {
    const {client: r=_e, ...n} = t;
    return await r({
        method: "GET",
        url: D5().toString(),
        params: e,
        ...n
    })
}
function z5(e) {
    return `/admin/reports/${e}`
}
async function U5(e, t, r={}) {
    const {client: n=_e, ...s} = r;
    return await n({
        method: "PUT",
        url: z5(e).toString(),
        data: t,
        ...s,
        headers: {
            "Content-Type": "application/json; charset=utf-8",
            ...s.headers
        }
    })
}
function V5(e) {
    return `/admin/users/${e}/ban`
}
async function B5(e, t, r={}) {
    const {client: n=_e, ...s} = r;
    return await n({
        method: "PUT",
        url: V5(e).toString(),
        data: t,
        ...s,
        headers: {
            "Content-Type": "application/json; charset=utf-8",
            ...s.headers
        }
    })
}
function W5(e) {
    return `/blobs/${e}/reports`
}
async function q5(e, t, r={}) {
    const {client: n=_e, ...s} = r;
    return await n({
        method: "POST",
        url: W5(e).toString(),
        data: t,
        ...s,
        headers: {
            "Content-Type": "application/json; charset=utf-8",
            ...s.headers
        }
    })
}
function H5() {
    return "/users/@me/friend-requests"
}
async function Z5(e, t={}) {
    const {client: r=_e, ...n} = t;
    return await r({
        method: "POST",
        url: H5().toString(),
        data: e,
        ...n,
        headers: {
            "Content-Type": "application/json; charset=utf-8",
            ...n.headers
        }
    })
}
function K5() {
    return "/users/@me/inventory-items"
}
async function Q5(e, t={}) {
    const {client: r=_e, ...n} = t;
    return await r({
        method: "POST",
        url: K5().toString(),
        data: e,
        ...n,
        headers: {
            "Content-Type": "application/json; charset=utf-8",
            ...n.headers
        }
    })
}
function G5() {
    return "/products"
}
async function Y5(e, t={}) {
    const {client: r=_e, ...n} = t;
    return await r({
        method: "POST",
        url: G5().toString(),
        data: e,
        ...n,
        headers: {
            "Content-Type": "application/json; charset=utf-8",
            ...n.headers
        }
    })
}
function J5() {
    return "/sessions/web"
}
async function X5(e, t={}) {
    const {client: r=_e, ...n} = t;
    return await r({
        method: "POST",
        url: J5().toString(),
        data: e,
        ...n,
        headers: {
            "Content-Type": "application/json; charset=utf-8",
            ...n.headers
        }
    })
}
function e6(e) {
    return `/friendships/${e}`
}
async function t6(e, t={}) {
    const {client: r=_e, ...n} = t;
    return await r({
        method: "DELETE",
        url: e6(e).toString(),
        ...n
    })
}
function r6(e) {
    return `/inventory-items/${e}`
}
async function n6(e, t={}) {
    const {client: r=_e, ...n} = t;
    return await r({
        method: "DELETE",
        url: r6(e).toString(),
        ...n
    })
}
function s6(e) {
    return `/products/${e}`
}
async function i6(e, t={}) {
    const {client: r=_e, ...n} = t;
    return await r({
        method: "DELETE",
        url: s6(e).toString(),
        ...n
    })
}
function a6(e) {
    return `/blobs/${e}`
}
async function o6(e, t, r={}) {
    const {client: n=_e, ...s} = r;
    return await n({
        method: "GET",
        url: a6(e).toString(),
        params: t,
        ...s
    })
}
function l6(e) {
    return `/inventory-items/${e}`
}
async function Da(e, t={}) {
    const {client: r=_e, ...n} = t;
    return await r({
        method: "GET",
        url: l6(e).toString(),
        ...n
    })
}
function u6(e) {
    return `/products/${e}`
}
async function c6(e, t={}) {
    const {client: r=_e, ...n} = t;
    return await r({
        method: "GET",
        url: u6(e).toString(),
        ...n
    })
}
function d6() {
    return "/sessions/vr-fork"
}
async function f6(e, t={}) {
    const {client: r=_e, ...n} = t;
    return await r({
        method: "PUT",
        url: d6().toString(),
        data: e,
        ...n,
        headers: {
            "Content-Type": "application/json; charset=utf-8",
            ...n.headers
        }
    })
}
function h6() {
    return "/users/@me/balance"
}
async function Ww(e={}) {
    const {client: t=_e, ...r} = e;
    return await t({
        method: "GET",
        url: h6().toString(),
        ...r
    })
}
function m6() {
    return "/users/@me/inventory-limits"
}
async function p6(e={}) {
    const {client: t=_e, ...r} = e;
    return await t({
        method: "GET",
        url: m6().toString(),
        ...r
    })
}
function y6() {
    return "/users/@me/product-limits"
}
async function g6(e={}) {
    const {client: t=_e, ...r} = e;
    return await t({
        method: "GET",
        url: y6().toString(),
        ...r
    })
}
function v6(e) {
    return `/matchmaking/friends/${e}/room`
}
async function b6(e, t={}) {
    const {client: r=_e, ...n} = t;
    return await r({
        method: "PUT",
        url: v6(e).toString(),
        ...n
    })
}
function x6() {
    return "/users/@me/blobs"
}
async function w6(e={}) {
    const {client: t=_e, ...r} = e;
    return await t({
        method: "GET",
        url: x6().toString(),
        ...r
    })
}
function S6() {
    return "/users/@me/friend-requests"
}
async function k6(e, t={}) {
    const {client: r=_e, ...n} = t;
    return await r({
        method: "GET",
        url: S6().toString(),
        params: e,
        ...n
    })
}
function E6() {
    return "/users/@me/friends"
}
async function _6(e, t={}) {
    const {client: r=_e, ...n} = t;
    return await r({
        method: "GET",
        url: E6().toString(),
        params: e,
        ...n
    })
}
function T6() {
    return "/users/@me/inventory-items"
}
async function C6(e={}) {
    const {client: t=_e, ...r} = e;
    return await t({
        method: "GET",
        url: T6().toString(),
        ...r
    })
}
function P6() {
    return "/products"
}
async function $6(e, t={}) {
    const {client: r=_e, ...n} = t;
    return await r({
        method: "GET",
        url: P6().toString(),
        params: e,
        ...n
    })
}
function N6() {
    return "/users"
}
async function qw(e, t={}) {
    const {client: r=_e, ...n} = t;
    return await r({
        method: "GET",
        url: N6().toString(),
        params: e,
        ...n
    })
}
function j6() {
    return "/users/@me"
}
async function I6(e={}) {
    const {client: t=_e, ...r} = e;
    return await t({
        method: "GET",
        url: j6().toString(),
        ...r
    })
}
function R6() {
    return "/users/@me/usage/inventory"
}
async function O6(e={}) {
    const {client: t=_e, ...r} = e;
    return await t({
        method: "PUT",
        url: R6().toString(),
        ...r
    })
}
function M6(e) {
    return `/products/${e}/transactions`
}
async function A6(e, t={}) {
    const {client: r=_e, ...n} = t;
    return await r({
        method: "POST",
        url: M6(e).toString(),
        ...n
    })
}
function L6() {
    return "/users/@me/usage/products"
}
async function D6(e={}) {
    const {client: t=_e, ...r} = e;
    return await t({
        method: "PUT",
        url: L6().toString(),
        ...r
    })
}
function F6() {
    return "/sessions/vr-fork/refresh"
}
async function z6(e={}) {
    const {client: t=_e, ...r} = e;
    return await t({
        method: "PUT",
        url: F6().toString(),
        ...r
    })
}
function U6(e) {
    return `/friend-requests/${e}`
}
async function V6(e, t, r={}) {
    const {client: n=_e, ...s} = r;
    return await n({
        method: "PUT",
        url: U6(e).toString(),
        data: t,
        ...s,
        headers: {
            "Content-Type": "application/json; charset=utf-8",
            ...s.headers
        }
    })
}
function B6(e) {
    return `/products/${e}`
}
async function W6(e, t, r={}) {
    const {client: n=_e, ...s} = r;
    return await n({
        method: "PATCH",
        url: B6(e).toString(),
        data: t,
        ...s,
        headers: {
            "Content-Type": "application/json; charset=utf-8",
            ...s.headers
        }
    })
}
function q6(e) {
    return `/users/${e}`
}
async function H6(e, t, r={}) {
    const {client: n=_e, ...s} = r;
    return await n({
        method: "PATCH",
        url: q6(e).toString(),
        data: t,
        ...s,
        headers: {
            "Content-Type": "application/json; charset=utf-8",
            ...s.headers
        }
    })
}
const Xi = {
    pending: "pending",
    valid: "valid",
    invalid: "invalid"
}
  , Z6 = u.object({
    blobId: u.coerce.string()
})
  , K6 = u.enum(["CONFLICT"])
  , Qy = u.object({
    code: u.lazy( () => K6),
    message: u.coerce.string()
})
  , Q6 = u.enum(["FORBIDDEN"])
  , nt = u.object({
    code: u.lazy( () => Q6),
    message: u.coerce.string()
})
  , G6 = u.enum(["INTERNAL_SERVER_ERROR"])
  , ne = u.object({
    code: u.lazy( () => G6),
    message: u.coerce.string()
})
  , Hw = u.object({
    id: u.coerce.string(),
    createdAt: u.string().datetime(),
    ownerId: u.coerce.string(),
    blobId: u.coerce.string()
})
  , Y6 = u.enum(["UNAUTHORIZED"])
  , le = u.object({
    code: u.lazy( () => Y6),
    message: u.coerce.string()
})
  , J6 = u.lazy( () => Hw);
u.lazy( () => le);
u.lazy( () => nt);
u.lazy( () => Qy);
u.lazy( () => ne);
u.lazy( () => Z6);
u.lazy( () => J6);
u.object({
    id: u.coerce.string()
});
const X6 = u.any();
u.lazy( () => le);
u.lazy( () => nt);
u.lazy( () => ne);
u.lazy( () => X6);
u.object({
    id: u.coerce.string()
});
const eM = u.any();
u.any();
u.any();
u.lazy( () => eM);
const tM = u.object({
    id: u.coerce.string(),
    price: u.coerce.number().int()
})
  , gs = u.enum(["item", "avatar", "building"])
  , Qo = u.object({
    id: u.coerce.string(),
    createdAt: u.string().datetime(),
    updatedAt: u.string().datetime().nullable().nullish(),
    lastUsedAt: u.string().datetime(),
    modelStoragePath: u.coerce.string(),
    modelUrl: u.coerce.string(),
    thumbnailUrl: u.coerce.string().nullable().nullish(),
    loadRotation: u.array(u.coerce.string()),
    localPosition: u.array(u.coerce.string()),
    blobType: u.lazy( () => gs),
    creatorId: u.coerce.string(),
    latestOwnerId: u.coerce.string().nullable().nullish(),
    sealedAt: u.string().datetime().nullable().nullish(),
    sealedById: u.coerce.string().nullable().nullish()
})
  , ls = u.object({
    id: u.coerce.string(),
    displayName: u.coerce.string()
})
  , Gy = u.object({
    id: u.coerce.string(),
    createdAt: u.string().datetime(),
    updatedAt: u.string().datetime().nullable().nullish(),
    lastUsedAt: u.string().datetime(),
    modelStoragePath: u.coerce.string(),
    modelUrl: u.coerce.string(),
    thumbnailUrl: u.coerce.string().nullable().nullish(),
    loadRotation: u.array(u.coerce.string()),
    localPosition: u.array(u.coerce.string()),
    blobType: u.lazy( () => gs),
    creator: u.lazy( () => ls),
    latestOwner: u.lazy( () => ls).nullable().nullish(),
    sealedAt: u.string().datetime().nullable().nullish(),
    children: u.array(u.lazy( () => Qo)),
    inPersonProduct: u.lazy( () => tM).nullable().nullish()
})
  , rM = u.enum(["NOT_FOUND"])
  , Qe = u.object({
    code: u.lazy( () => rM),
    message: u.coerce.string()
});
u.object({
    id: u.coerce.string()
});
const nM = u.lazy( () => Gy);
u.lazy( () => nt);
u.lazy( () => Qe);
u.lazy( () => ne);
u.lazy( () => nM);
const Gu = u.enum(["pending", "valid", "invalid"])
  , Zw = u.enum(["blob", "profile"])
  , sM = u.object({
    id: u.coerce.string(),
    createdAt: u.string().datetime(),
    updatedAt: u.string().datetime().optional(),
    type: u.lazy( () => Zw),
    status: u.lazy( () => Gu),
    reportedById: u.coerce.string(),
    reportNotes: u.coerce.string(),
    subjectOwnerId: u.coerce.string(),
    reviewedById: u.coerce.string().optional(),
    adminNotes: u.coerce.string(),
    blobId: u.coerce.string().optional()
});
u.object({
    id: u.coerce.string()
});
const iM = u.lazy( () => sM);
u.lazy( () => nt);
u.lazy( () => Qe);
u.lazy( () => ne);
u.lazy( () => iM);
const Yu = u.object({
    id: u.coerce.number().int(),
    name: u.coerce.string(),
    scene: u.coerce.string().nullable().nullish(),
    entryPosition: u.array(u.coerce.string()),
    entryRotation: u.array(u.coerce.string()),
    isPrivate: u.boolean()
})
  , aM = u.object({
    room: u.lazy( () => Yu),
    user: u.lazy( () => ls)
});
u.object({
    username: u.coerce.string()
});
const oM = u.lazy( () => aM);
u.lazy( () => le);
u.lazy( () => nt);
u.lazy( () => Qe);
u.lazy( () => ne);
u.lazy( () => oM);
const Kw = u.object({
    id: u.coerce.string(),
    blobId: u.coerce.string(),
    blobType: u.lazy( () => gs),
    blobSealedAt: u.string().datetime().nullable().nullish(),
    thumbnailUrl: u.coerce.string().nullable().nullish()
});
u.object({
    username: u.coerce.string()
});
const lM = u.array(u.lazy( () => Kw));
u.lazy( () => le);
u.lazy( () => nt);
u.lazy( () => Qe);
u.lazy( () => ne);
u.lazy( () => lM);
u.object({
    username: u.coerce.string()
});
const uM = u.array(u.lazy( () => Qo));
u.lazy( () => le);
u.lazy( () => nt);
u.lazy( () => ne);
u.lazy( () => uM);
const cM = u.object({
    id: u.coerce.string(),
    name: u.coerce.string(),
    price: u.coerce.number().int(),
    blobId: u.coerce.string(),
    blobType: u.lazy( () => gs),
    blobSealedAt: u.string().datetime().nullable().nullish(),
    thumbnailUrl: u.coerce.string().nullable().nullish(),
    seller: u.lazy( () => ls)
})
  , Qw = u.object({
    items: u.array(u.lazy( () => cM)),
    nextCursor: u.coerce.string().optional()
});
u.object({
    limit: u.coerce.number().int().optional(),
    cursor: u.coerce.string().optional(),
    name: u.coerce.string().optional(),
    sellerId: u.coerce.string().optional(),
    sellerUsername: u.coerce.string().optional(),
    type: u.lazy( () => gs).optional(),
    blobId: u.coerce.string().optional()
}).optional();
const dM = u.lazy( () => Qw);
u.lazy( () => le);
u.lazy( () => nt);
u.lazy( () => ne);
u.lazy( () => dM);
const fM = u.object({
    id: u.coerce.string(),
    createdAt: u.string().datetime(),
    updatedAt: u.string().datetime().optional(),
    type: u.lazy( () => Zw),
    status: u.lazy( () => Gu),
    reportedById: u.coerce.string(),
    reportNotes: u.coerce.string(),
    subjectOwnerId: u.coerce.string(),
    reviewedById: u.coerce.string().optional(),
    adminNotes: u.coerce.string(),
    blobId: u.coerce.string().optional(),
    totalReports: u.coerce.number().int()
})
  , hM = u.object({
    items: u.array(u.lazy( () => fM)),
    nextCursor: u.coerce.string().optional()
});
u.object({
    limit: u.coerce.number().int().optional(),
    cursor: u.coerce.string().optional(),
    status: u.array(u.lazy( () => Gu)).optional()
}).optional();
const mM = u.lazy( () => hM);
u.lazy( () => nt);
u.lazy( () => ne);
u.lazy( () => mM);
const pM = u.object({
    status: u.lazy( () => Gu),
    adminNotes: u.coerce.string().optional()
});
u.object({
    id: u.coerce.string()
});
const yM = u.any();
u.lazy( () => nt);
u.lazy( () => Qe);
u.lazy( () => ne);
u.lazy( () => pM);
u.lazy( () => yM);
const gM = u.enum(["ALREADY_REPORTED"])
  , vM = u.object({
    code: u.lazy( () => gM),
    message: u.coerce.string()
})
  , bM = u.object({
    username: u.string().datetime().nullable().nullish(),
    displayName: u.string().datetime().nullable().nullish()
})
  , xM = u.enum(["pending", "active", "expired"])
  , Gw = u.enum(["active", "muted"])
  , wM = u.object({
    status: u.lazy( () => Gw),
    sanctionExpiryAt: u.string().datetime().nullable().nullish()
})
  , SM = u.enum(["admin", "moderator", "player"])
  , kM = u.object({
    id: u.coerce.string(),
    createdAt: u.string().datetime(),
    updatedAt: u.string().datetime().nullable().nullish(),
    rewardedAt: u.string().datetime().nullable().nullish(),
    migrationCompletedAt: u.string().datetime().nullable().nullish(),
    subscriptionExpiresAt: u.string().datetime().nullable().nullish(),
    subscriptionStatus: u.lazy( () => xM).nullable().nullish(),
    isSubscribed: u.boolean(),
    username: u.coerce.string(),
    displayName: u.coerce.string(),
    role: u.lazy( () => SM),
    balance: u.coerce.number().int(),
    inventoryLimit: u.coerce.number().int(),
    productsLimit: u.coerce.number().int(),
    currentAvatarId: u.coerce.string().nullable().nullish(),
    permissionLevel: u.coerce.number().int(),
    isJoinable: u.boolean(),
    ggwp: u.lazy( () => wM),
    profileChangeCooldowns: u.lazy( () => bM),
    isDailyRewardEligible: u.boolean()
})
  , EM = u.enum(["BAD_REQUEST"])
  , ct = u.object({
    code: u.lazy( () => EM),
    message: u.coerce.string()
})
  , _M = u.object({
    duration: u.coerce.number().int().describe("The duration of the ban in seconds").optional(),
    reason: u.coerce.string().optional()
});
u.object({
    username: u.coerce.string()
});
const TM = u.any();
u.lazy( () => nt);
u.lazy( () => Qe);
u.lazy( () => ne);
u.lazy( () => _M);
u.lazy( () => TM);
const CM = u.object({
    id: u.coerce.string(),
    createdAt: u.string().datetime(),
    creatorDisplayName: u.coerce.string(),
    thumbnailUrl: u.coerce.string().nullable().nullish(),
    sealedAt: u.string().datetime().nullable().nullish()
})
  , PM = u.object({
    updatedAt: u.string().datetime(),
    blobium10k: u.array(u.coerce.string()),
    subscription: u.array(u.coerce.string())
})
  , $M = u.any();
u.any();
u.lazy( () => $M);
u.object({
    id: u.coerce.string()
});
const NM = u.any();
u.lazy( () => ct);
u.lazy( () => le);
u.lazy( () => Qe);
u.lazy( () => ne);
u.lazy( () => NM);
const jM = u.object({
    userIds: u.array(u.coerce.string())
});
u.object({
    id: u.coerce.number().int()
});
const IM = u.any();
u.lazy( () => le);
u.lazy( () => ne);
u.lazy( () => jM);
u.lazy( () => IM);
const RM = u.enum(["INVALID_MODEL_PATH"])
  , Yw = u.object({
    code: u.lazy( () => RM),
    message: u.coerce.string()
})
  , OM = u.union([u.lazy( () => Yw), u.lazy( () => ct)])
  , MM = u.object({
    blobType: u.lazy( () => gs),
    modelStoragePath: u.coerce.string(),
    thumbnailStoragePath: u.coerce.string().nullable().nullish(),
    loadRotation: u.array(u.coerce.string()).optional(),
    localPosition: u.array(u.coerce.string()).optional(),
    createInventoryItem: u.boolean().optional(),
    fee: u.coerce.number().int().optional(),
    childBlobIds: u.array(u.coerce.string()).optional(),
    parentId: u.coerce.string().nullable().nullish()
})
  , Jw = u.object({
    reportNotes: u.coerce.string().optional()
});
u.object({
    id: u.coerce.string()
});
const AM = u.any();
u.lazy( () => vM);
u.lazy( () => le);
u.lazy( () => nt);
u.lazy( () => Qe);
u.lazy( () => ne);
u.lazy( () => Jw);
u.lazy( () => AM);
const LM = u.lazy( () => Qo);
u.lazy( () => OM);
u.lazy( () => le);
u.lazy( () => nt);
u.lazy( () => ne);
u.lazy( () => MM);
u.lazy( () => LM);
const DM = u.object({
    id: u.coerce.string(),
    username: u.coerce.string(),
    displayName: u.coerce.string(),
    failedMigration: u.boolean()
})
  , FM = u.object({
    userId: u.coerce.string()
})
  , Xw = u.object({
    id: u.coerce.string(),
    createdAt: u.string().datetime(),
    requestingUser: u.lazy( () => ls),
    requestedUser: u.lazy( () => ls)
})
  , zM = u.lazy( () => Xw);
u.lazy( () => ct);
u.lazy( () => le);
u.lazy( () => Qy);
u.lazy( () => ne);
u.lazy( () => FM);
u.lazy( () => zM);
const UM = u.enum(["INVALID_BLOB_ID"])
  , VM = u.object({
    code: u.lazy( () => UM),
    message: u.coerce.string()
})
  , BM = u.enum(["INVENTORY_FULL"])
  , eS = u.object({
    code: u.lazy( () => BM),
    message: u.coerce.string()
})
  , WM = u.union([u.lazy( () => eS), u.lazy( () => VM)])
  , qM = u.object({
    blobId: u.coerce.string()
})
  , br = u.object({
    code: u.coerce.string(),
    message: u.coerce.string()
})
  , HM = u.lazy( () => Hw);
u.lazy( () => WM);
u.lazy( () => le);
u.lazy( () => nt);
u.lazy( () => Qe);
u.lazy( () => br);
u.lazy( () => br);
u.lazy( () => qM);
u.lazy( () => HM);
const tS = u.enum(["store", "in_person"])
  , rS = u.object({
    inventoryItemId: u.coerce.string(),
    name: u.coerce.string().min(3).max(36),
    price: u.coerce.number().int().min(0).max(1e5),
    salesChannel: u.lazy( () => tS).describe('Sales channel for the product. Defaults to `"store"` for backwards compatibility.').optional()
})
  , nS = u.object({
    id: u.coerce.string(),
    createdAt: u.string().datetime(),
    updatedAt: u.string().datetime().optional(),
    price: u.coerce.number().int(),
    name: u.coerce.string(),
    blob: u.lazy( () => CM),
    seller: u.lazy( () => ls)
})
  , ZM = u.lazy( () => nS);
u.lazy( () => br);
u.lazy( () => br);
u.lazy( () => Qe);
u.lazy( () => br);
u.lazy( () => br);
u.lazy( () => rS);
u.lazy( () => ZM);
const KM = u.enum(["INSUFFICIENT_BLOBIUM"])
  , Yy = u.object({
    code: u.lazy( () => KM),
    message: u.coerce.string()
})
  , sS = u.union([u.lazy( () => Yy), u.lazy( () => eS), u.lazy( () => ct)])
  , QM = u.enum(["thumbnail", "blob"])
  , GM = u.object({
    fileType: u.lazy( () => QM),
    filename: u.coerce.string()
})
  , YM = u.object({
    url: u.coerce.string(),
    path: u.coerce.string()
})
  , JM = u.lazy( () => YM);
u.lazy( () => le);
u.lazy( () => ne);
u.lazy( () => GM);
u.lazy( () => JM);
const XM = u.object({
    firebaseIdToken: u.coerce.string().nullable().nullish()
})
  , eA = u.lazy( () => DM);
u.lazy( () => nt);
u.lazy( () => Qy);
u.lazy( () => br);
u.lazy( () => XM);
u.lazy( () => eA);
const Ju = u.object({
    accessToken: u.coerce.string(),
    refreshToken: u.coerce.string(),
    exp: u.coerce.number().int(),
    tokenNonce: u.coerce.string()
})
  , tA = u.enum(["VERSION_MISMATCH"])
  , rA = u.object({
    isReleased: u.boolean()
})
  , Kf = u.object({
    code: u.lazy( () => tA),
    message: u.coerce.string(),
    data: u.lazy( () => rA)
})
  , iS = u.object({
    token: u.coerce.string()
})
  , nA = u.lazy( () => Ju);
u.lazy( () => ct);
u.lazy( () => le);
u.lazy( () => Kf);
u.lazy( () => ne);
u.lazy( () => iS);
u.lazy( () => nA);
const aS = u.object({
    username: u.coerce.string(),
    password: u.coerce.string()
})
  , sA = u.lazy( () => Ju);
u.lazy( () => ct);
u.lazy( () => le);
u.lazy( () => ne);
u.lazy( () => aS);
u.lazy( () => sA);
u.object({
    id: u.coerce.string()
});
const iA = u.any();
u.lazy( () => le);
u.lazy( () => nt);
u.lazy( () => Qe);
u.lazy( () => ne);
u.lazy( () => iA);
u.object({
    id: u.coerce.string()
});
const aA = u.any();
u.lazy( () => le);
u.lazy( () => nt);
u.lazy( () => Qe);
u.lazy( () => ne);
u.lazy( () => aA);
u.object({
    id: u.coerce.string()
});
const oA = u.any();
u.lazy( () => br);
u.lazy( () => br);
u.lazy( () => br);
u.lazy( () => oA);
u.object({
    id: u.coerce.string()
});
const lA = u.any();
u.lazy( () => br);
u.lazy( () => br);
u.lazy( () => br);
u.lazy( () => lA);
u.object({
    blobId: u.array(u.coerce.string())
});
const uA = u.any();
u.lazy( () => ct);
u.lazy( () => le);
u.lazy( () => ne);
u.lazy( () => uA);
u.object({
    id: u.coerce.string()
});
const cA = u.any();
u.lazy( () => le);
u.lazy( () => nt);
u.lazy( () => Qe);
u.lazy( () => ne);
u.lazy( () => cA);
u.object({
    id: u.coerce.string()
});
const dA = u.any();
u.lazy( () => ct);
u.lazy( () => le);
u.lazy( () => Qe);
u.lazy( () => ne);
u.lazy( () => dA);
u.object({
    id: u.coerce.string()
});
const fA = u.any();
u.lazy( () => ct);
u.lazy( () => le);
u.lazy( () => Qe);
u.lazy( () => ne);
u.lazy( () => fA);
const hA = u.union([u.lazy( () => Yw), u.lazy( () => ct), u.lazy( () => ct)])
  , mA = u.object({
    modelStoragePath: u.coerce.string(),
    thumbnailStoragePath: u.coerce.string().nullable().nullish(),
    loadRotation: u.array(u.coerce.string()).nullable().nullish(),
    localPosition: u.array(u.coerce.string()).nullable().nullish(),
    createInventoryItem: u.boolean().nullable().nullish(),
    fee: u.coerce.number().int()
});
u.object({
    id: u.coerce.string()
});
const pA = u.lazy( () => Qo);
u.lazy( () => hA);
u.lazy( () => le);
u.lazy( () => nt);
u.lazy( () => Qe);
u.lazy( () => ne);
u.lazy( () => mA);
u.lazy( () => pA);
u.object({
    id: u.coerce.string()
});
u.object({
    includeChildren: u.boolean().optional()
}).optional();
const yA = u.lazy( () => Gy);
u.lazy( () => Qe);
u.lazy( () => ne);
u.lazy( () => yA);
const oS = u.object({
    friendshipId: u.coerce.string(),
    userId: u.coerce.string(),
    username: u.coerce.string(),
    displayName: u.coerce.string(),
    isJoinable: u.boolean(),
    currentRoomId: u.coerce.number().int().optional(),
    ggwpStatus: u.lazy( () => Gw)
});
u.object({
    id: u.coerce.string()
});
const gA = u.lazy( () => oS);
u.lazy( () => le);
u.lazy( () => Qe);
u.lazy( () => ne);
u.lazy( () => gA);
const vA = u.object({
    id: u.coerce.string(),
    createdAt: u.string().datetime(),
    owner: u.lazy( () => ls),
    blob: u.lazy( () => Gy)
});
u.object({
    id: u.coerce.string()
});
const bA = u.lazy( () => vA);
u.lazy( () => le);
u.lazy( () => nt);
u.lazy( () => Qe);
u.lazy( () => ne);
u.lazy( () => bA);
u.object({
    id: u.coerce.string()
});
const xA = u.lazy( () => nS);
u.lazy( () => le);
u.lazy( () => Qe);
u.lazy( () => br);
u.lazy( () => xA);
const lS = u.object({
    nonce: u.coerce.string()
})
  , wA = u.lazy( () => Ju);
u.lazy( () => ct);
u.lazy( () => le);
u.lazy( () => Kf);
u.lazy( () => ne);
u.lazy( () => lS);
u.lazy( () => wA);
const SA = u.lazy( () => PM);
u.lazy( () => ne);
u.lazy( () => SA);
const kA = u.coerce.number().int();
u.lazy( () => le);
u.lazy( () => ne);
u.lazy( () => kA);
const uS = u.object({
    limit: u.coerce.number().int(),
    remaining: u.coerce.number().int(),
    upgradePrice: u.coerce.number().int().nullable().nullish()
})
  , EA = u.lazy( () => uS);
u.lazy( () => le);
u.lazy( () => ne);
u.lazy( () => EA);
const _A = u.lazy( () => uS);
u.lazy( () => le);
u.lazy( () => ne);
u.lazy( () => _A);
const TA = u.object({
    inventoryLimit: u.coerce.number().int(),
    inventoryItemsRemaining: u.coerce.number().int(),
    increaseInventoryLimitPrice: u.coerce.number().int().nullable().nullish(),
    productsLimit: u.coerce.number().int(),
    productsRemaining: u.coerce.number().int(),
    increaseProductsLimitPrice: u.coerce.number().int().nullable().nullish()
})
  , CA = u.lazy( () => TA);
u.lazy( () => le);
u.lazy( () => ne);
u.lazy( () => CA);
const PA = u.object({
    value: u.coerce.number().int()
})
  , $A = u.lazy( () => PA);
u.lazy( () => le);
u.lazy( () => Qe);
u.lazy( () => ne);
u.lazy( () => $A);
const NA = u.lazy( () => lS);
u.lazy( () => ct);
u.lazy( () => le);
u.lazy( () => ne);
u.lazy( () => NA);
u.object({
    id: u.coerce.string()
});
const jA = u.lazy( () => Yu);
u.lazy( () => ct);
u.lazy( () => le);
u.lazy( () => ne);
u.lazy( () => jA);
const IA = u.object({
    inventoryLimit: u.coerce.number().int(),
    increaseInventoryLimitPrice: u.coerce.number().int().nullable().nullish()
})
  , Jy = u.object({
    scene: u.coerce.string().optional(),
    name: u.coerce.string().optional(),
    entryPosition: u.array(u.coerce.string()).optional(),
    entryRotation: u.array(u.coerce.string()).optional(),
    isPrivate: u.boolean().optional()
})
  , RA = u.lazy( () => Yu);
u.lazy( () => ct);
u.lazy( () => le);
u.lazy( () => ne);
u.lazy( () => Jy);
u.lazy( () => RA);
const OA = u.lazy( () => Yu);
u.lazy( () => ct);
u.lazy( () => le);
u.lazy( () => ne);
u.lazy( () => Jy);
u.lazy( () => OA);
const MA = u.lazy( () => Yu);
u.lazy( () => ct);
u.lazy( () => le);
u.lazy( () => ne);
u.lazy( () => Jy);
u.lazy( () => MA);
const AA = u.array(u.lazy( () => Qo));
u.lazy( () => le);
u.lazy( () => ne);
u.lazy( () => AA);
const LA = u.object({
    slug: u.coerce.string(),
    name: u.coerce.string(),
    price: u.coerce.number().int()
})
  , DA = u.object({
    items: u.array(u.lazy( () => LA))
});
u.object({
    slug: u.coerce.string()
});
const FA = u.lazy( () => DA);
u.lazy( () => Qe);
u.lazy( () => ne);
u.lazy( () => FA);
const zA = u.object({
    total: u.coerce.number().int(),
    nextCursor: u.coerce.string().optional(),
    items: u.array(u.lazy( () => Xw))
});
u.object({
    limit: u.coerce.number().int().optional(),
    cursor: u.coerce.string().optional(),
    sent: u.boolean().optional(),
    received: u.boolean().optional()
}).optional();
const UA = u.lazy( () => zA);
u.lazy( () => le);
u.lazy( () => ne);
u.lazy( () => UA);
const VA = u.object({
    total: u.coerce.number().int(),
    items: u.array(u.lazy( () => oS)),
    nextCursor: u.coerce.string().optional()
});
u.object({
    limit: u.coerce.number().int().optional(),
    cursor: u.coerce.string().optional()
}).optional();
const BA = u.lazy( () => VA);
u.lazy( () => le);
u.lazy( () => ne);
u.lazy( () => BA);
const WA = u.array(u.lazy( () => Kw));
u.lazy( () => le);
u.lazy( () => nt);
u.lazy( () => ne);
u.lazy( () => WA);
const qA = u.object({
    limit: u.coerce.number().int().optional(),
    cursor: u.coerce.string().optional(),
    name: u.coerce.string().optional(),
    sellerId: u.coerce.string().optional(),
    sellerUsername: u.coerce.string().optional(),
    isMaxBalance: u.boolean().optional(),
    type: u.lazy( () => gs).optional(),
    isSealed: u.boolean().optional(),
    blobId: u.coerce.string().optional(),
    salesChannel: u.lazy( () => tS).optional(),
    price: u.coerce.string().optional()
}).optional()
  , HA = u.lazy( () => Qw);
u.lazy( () => ct);
u.lazy( () => le);
u.lazy( () => ne);
u.lazy( () => HA);
const ZA = u.object({
    ownedMaterialSlugs: u.array(u.coerce.string()).describe("List of owned material IDs")
})
  , KA = u.lazy( () => ZA);
u.lazy( () => le);
u.lazy( () => ne);
u.lazy( () => KA);
const QA = u.object({
    name: u.coerce.string().optional(),
    excludeFriends: u.boolean().optional(),
    userId: u.array(u.coerce.string()).optional()
}).optional()
  , GA = u.array(u.lazy( () => ls));
u.lazy( () => le);
u.lazy( () => ne);
u.lazy( () => GA);
const YA = u.lazy( () => kM);
u.lazy( () => le);
u.lazy( () => ne);
u.lazy( () => YA);
const JA = u.object({
    ok: u.boolean()
})
  , XA = u.object({
    productsLimit: u.coerce.number().int(),
    increaseProductsLimitPrice: u.coerce.number().int().nullable().nullish()
})
  , eL = u.lazy( () => IA);
u.lazy( () => Yy);
u.lazy( () => le);
u.lazy( () => ne);
u.lazy( () => eL);
const cS = u.object({
    id: u.coerce.string(),
    createdAt: u.string().datetime(),
    amount: u.coerce.number().int()
});
u.object({
    material_slug: u.coerce.string()
});
const tL = u.lazy( () => cS);
u.lazy( () => sS);
u.lazy( () => le);
u.lazy( () => Qe);
u.lazy( () => ne);
u.lazy( () => tL);
const rL = u.lazy( () => XA);
u.lazy( () => Yy);
u.lazy( () => le);
u.lazy( () => ne);
u.lazy( () => rL);
u.object({
    id: u.coerce.string()
});
const nL = u.lazy( () => cS);
u.lazy( () => sS);
u.lazy( () => le);
u.lazy( () => Qe);
u.lazy( () => ne);
u.lazy( () => nL);
const sL = u.lazy( () => Ju);
u.lazy( () => ct);
u.lazy( () => le);
u.lazy( () => Kf);
u.lazy( () => ne);
u.lazy( () => sL);
const iL = u.lazy( () => Ju);
u.lazy( () => ct);
u.lazy( () => le);
u.lazy( () => Kf);
u.lazy( () => ne);
u.lazy( () => iS);
u.lazy( () => iL);
u.object({
    id: u.coerce.string()
});
const aL = u.any();
u.lazy( () => ct);
u.lazy( () => le);
u.lazy( () => Qe);
u.lazy( () => ne);
u.lazy( () => aL);
const oL = u.any();
u.any();
u.lazy( () => oL);
const lL = u.object({
    modelStoragePath: u.coerce.string().optional(),
    thumbnailStoragePath: u.coerce.string().nullable().nullish(),
    loadRotation: u.array(u.coerce.string()).optional(),
    localPosition: u.array(u.coerce.string()).optional(),
    claimBlob: u.boolean().optional(),
    createInventoryItem: u.boolean().optional(),
    childBlobIds: u.array(u.coerce.string()).describe("The blob ids that need to be deleted as they are combined into this blob.").optional(),
    parentId: u.coerce.string().describe("The parent blob id to which this blob will be attached. The parent blob must be a building.").nullable().nullish()
});
u.object({
    id: u.coerce.string()
});
const uL = u.lazy( () => Qo);
u.lazy( () => ct);
u.lazy( () => le);
u.lazy( () => nt);
u.lazy( () => Qe);
u.lazy( () => ne);
u.lazy( () => lL);
u.lazy( () => uL);
const cL = u.object({
    accepted: u.boolean()
});
u.object({
    id: u.coerce.string()
});
const dL = u.any();
u.lazy( () => le);
u.lazy( () => nt);
u.lazy( () => ne);
u.lazy( () => cL);
u.lazy( () => dL);
const fL = u.object({
    name: u.coerce.string().min(3).max(36).optional()
});
u.object({
    id: u.coerce.string()
});
const hL = u.any();
u.lazy( () => br);
u.lazy( () => le);
u.lazy( () => nt);
u.lazy( () => Qe);
u.lazy( () => ne);
u.lazy( () => fL);
u.lazy( () => hL);
const mL = u.object({
    username: u.coerce.string().min(3).max(24).optional(),
    displayName: u.coerce.string().min(3).max(24).optional(),
    password: u.coerce.string().min(6).max(256).optional(),
    currentAvatarId: u.coerce.string().nullable().nullish(),
    isJoinable: u.boolean().optional()
});
u.object({
    id: u.coerce.string()
});
const pL = u.lazy( () => JA);
u.lazy( () => ct);
u.lazy( () => le);
u.lazy( () => nt);
u.lazy( () => ne);
u.lazy( () => mL);
u.lazy( () => pL);
var Go = class {
    constructor() {
        this.listeners = new Set,
        this.subscribe = this.subscribe.bind(this)
    }
    subscribe(e) {
        return this.listeners.add(e),
        this.onSubscribe(),
        () => {
            this.listeners.delete(e),
            this.onUnsubscribe()
        }
    }
    hasListeners() {
        return this.listeners.size > 0
    }
    onSubscribe() {}
    onUnsubscribe() {}
}
  , oa = typeof window > "u" || "Deno"in globalThis;
function Wr() {}
function yL(e, t) {
    return typeof e == "function" ? e(t) : e
}
function Wm(e) {
    return typeof e == "number" && e >= 0 && e !== 1 / 0
}
function dS(e, t) {
    return Math.max(e + (t || 0) - Date.now(), 0)
}
function so(e, t) {
    return typeof e == "function" ? e(t) : e
}
function hn(e, t) {
    return typeof e == "function" ? e(t) : e
}
function L0(e, t) {
    const {type: r="all", exact: n, fetchStatus: s, predicate: i, queryKey: a, stale: o} = e;
    if (a) {
        if (n) {
            if (t.queryHash !== Xy(a, t.options))
                return !1
        } else if (!vu(t.queryKey, a))
            return !1
    }
    if (r !== "all") {
        const l = t.isActive();
        if (r === "active" && !l || r === "inactive" && l)
            return !1
    }
    return !(typeof o == "boolean" && t.isStale() !== o || s && s !== t.state.fetchStatus || i && !i(t))
}
function D0(e, t) {
    const {exact: r, status: n, predicate: s, mutationKey: i} = e;
    if (i) {
        if (!t.options.mutationKey)
            return !1;
        if (r) {
            if (la(t.options.mutationKey) !== la(i))
                return !1
        } else if (!vu(t.options.mutationKey, i))
            return !1
    }
    return !(n && t.state.status !== n || s && !s(t))
}
function Xy(e, t) {
    return ((t == null ? void 0 : t.queryKeyHashFn) || la)(e)
}
function la(e) {
    return JSON.stringify(e, (t, r) => qm(r) ? Object.keys(r).sort().reduce( (n, s) => (n[s] = r[s],
    n), {}) : r)
}
function vu(e, t) {
    return e === t ? !0 : typeof e != typeof t ? !1 : e && t && typeof e == "object" && typeof t == "object" ? !Object.keys(t).some(r => !vu(e[r], t[r])) : !1
}
function fS(e, t) {
    if (e === t)
        return e;
    const r = F0(e) && F0(t);
    if (r || qm(e) && qm(t)) {
        const n = r ? e : Object.keys(e)
          , s = n.length
          , i = r ? t : Object.keys(t)
          , a = i.length
          , o = r ? [] : {};
        let l = 0;
        for (let c = 0; c < a; c++) {
            const f = r ? c : i[c];
            (!r && n.includes(f) || r) && e[f] === void 0 && t[f] === void 0 ? (o[f] = void 0,
            l++) : (o[f] = fS(e[f], t[f]),
            o[f] === e[f] && e[f] !== void 0 && l++)
        }
        return s === a && l === s ? e : o
    }
    return t
}
function Bd(e, t) {
    if (!t || Object.keys(e).length !== Object.keys(t).length)
        return !1;
    for (const r in e)
        if (e[r] !== t[r])
            return !1;
    return !0
}
function F0(e) {
    return Array.isArray(e) && e.length === Object.keys(e).length
}
function qm(e) {
    if (!z0(e))
        return !1;
    const t = e.constructor;
    if (t === void 0)
        return !0;
    const r = t.prototype;
    return !(!z0(r) || !r.hasOwnProperty("isPrototypeOf") || Object.getPrototypeOf(e) !== Object.prototype)
}
function z0(e) {
    return Object.prototype.toString.call(e) === "[object Object]"
}
function gL(e) {
    return new Promise(t => {
        setTimeout(t, e)
    }
    )
}
function Hm(e, t, r) {
    return typeof r.structuralSharing == "function" ? r.structuralSharing(e, t) : r.structuralSharing !== !1 ? fS(e, t) : t
}
function vL(e, t, r=0) {
    const n = [...e, t];
    return r && n.length > r ? n.slice(1) : n
}
function bL(e, t, r=0) {
    const n = [t, ...e];
    return r && n.length > r ? n.slice(0, -1) : n
}
var ga = Symbol();
function hS(e, t) {
    return !e.queryFn && (t != null && t.initialPromise) ? () => t.initialPromise : !e.queryFn || e.queryFn === ga ? () => Promise.reject(new Error(`Missing queryFn: '${e.queryHash}'`)) : e.queryFn
}
var Wi, Fs, po, $1, xL = ($1 = class extends Go {
    constructor() {
        super();
        de(this, Wi);
        de(this, Fs);
        de(this, po);
        J(this, po, t => {
            if (!oa && window.addEventListener) {
                const r = () => t();
                return window.addEventListener("visibilitychange", r, !1),
                () => {
                    window.removeEventListener("visibilitychange", r)
                }
            }
        }
        )
    }
    onSubscribe() {
        _(this, Fs) || this.setEventListener(_(this, po))
    }
    onUnsubscribe() {
        var t;
        this.hasListeners() || ((t = _(this, Fs)) == null || t.call(this),
        J(this, Fs, void 0))
    }
    setEventListener(t) {
        var r;
        J(this, po, t),
        (r = _(this, Fs)) == null || r.call(this),
        J(this, Fs, t(n => {
            typeof n == "boolean" ? this.setFocused(n) : this.onFocus()
        }
        ))
    }
    setFocused(t) {
        _(this, Wi) !== t && (J(this, Wi, t),
        this.onFocus())
    }
    onFocus() {
        const t = this.isFocused();
        this.listeners.forEach(r => {
            r(t)
        }
        )
    }
    isFocused() {
        var t;
        return typeof _(this, Wi) == "boolean" ? _(this, Wi) : ((t = globalThis.document) == null ? void 0 : t.visibilityState) !== "hidden"
    }
}
,
Wi = new WeakMap,
Fs = new WeakMap,
po = new WeakMap,
$1), eg = new xL, yo, zs, go, N1, wL = (N1 = class extends Go {
    constructor() {
        super();
        de(this, yo, !0);
        de(this, zs);
        de(this, go);
        J(this, go, t => {
            if (!oa && window.addEventListener) {
                const r = () => t(!0)
                  , n = () => t(!1);
                return window.addEventListener("online", r, !1),
                window.addEventListener("offline", n, !1),
                () => {
                    window.removeEventListener("online", r),
                    window.removeEventListener("offline", n)
                }
            }
        }
        )
    }
    onSubscribe() {
        _(this, zs) || this.setEventListener(_(this, go))
    }
    onUnsubscribe() {
        var t;
        this.hasListeners() || ((t = _(this, zs)) == null || t.call(this),
        J(this, zs, void 0))
    }
    setEventListener(t) {
        var r;
        J(this, go, t),
        (r = _(this, zs)) == null || r.call(this),
        J(this, zs, t(this.setOnline.bind(this)))
    }
    setOnline(t) {
        _(this, yo) !== t && (J(this, yo, t),
        this.listeners.forEach(n => {
            n(t)
        }
        ))
    }
    isOnline() {
        return _(this, yo)
    }
}
,
yo = new WeakMap,
zs = new WeakMap,
go = new WeakMap,
N1), Wd = new wL;
function Zm() {
    let e, t;
    const r = new Promise( (s, i) => {
        e = s,
        t = i
    }
    );
    r.status = "pending",
    r.catch( () => {}
    );
    function n(s) {
        Object.assign(r, s),
        delete r.resolve,
        delete r.reject
    }
    return r.resolve = s => {
        n({
            status: "fulfilled",
            value: s
        }),
        e(s)
    }
    ,
    r.reject = s => {
        n({
            status: "rejected",
            reason: s
        }),
        t(s)
    }
    ,
    r
}
function SL(e) {
    return Math.min(1e3 * 2 ** e, 3e4)
}
function mS(e) {
    return (e ?? "online") === "online" ? Wd.isOnline() : !0
}
var pS = class extends Error {
    constructor(e) {
        super("CancelledError"),
        this.revert = e == null ? void 0 : e.revert,
        this.silent = e == null ? void 0 : e.silent
    }
}
;
function Ah(e) {
    return e instanceof pS
}
function yS(e) {
    let t = !1, r = 0, n = !1, s;
    const i = Zm()
      , a = x => {
        var w;
        n || (m(new pS(x)),
        (w = e.abort) == null || w.call(e))
    }
      , o = () => {
        t = !0
    }
      , l = () => {
        t = !1
    }
      , c = () => eg.isFocused() && (e.networkMode === "always" || Wd.isOnline()) && e.canRun()
      , f = () => mS(e.networkMode) && e.canRun()
      , h = x => {
        var w;
        n || (n = !0,
        (w = e.onSuccess) == null || w.call(e, x),
        s == null || s(),
        i.resolve(x))
    }
      , m = x => {
        var w;
        n || (n = !0,
        (w = e.onError) == null || w.call(e, x),
        s == null || s(),
        i.reject(x))
    }
      , y = () => new Promise(x => {
        var w;
        s = v => {
            (n || c()) && x(v)
        }
        ,
        (w = e.onPause) == null || w.call(e)
    }
    ).then( () => {
        var x;
        s = void 0,
        n || (x = e.onContinue) == null || x.call(e)
    }
    )
      , k = () => {
        if (n)
            return;
        let x;
        const w = r === 0 ? e.initialPromise : void 0;
        try {
            x = w ?? e.fn()
        } catch (v) {
            x = Promise.reject(v)
        }
        Promise.resolve(x).then(h).catch(v => {
            var L;
            if (n)
                return;
            const p = e.retry ?? (oa ? 0 : 3)
              , S = e.retryDelay ?? SL
              , P = typeof S == "function" ? S(r, v) : S
              , j = p === !0 || typeof p == "number" && r < p || typeof p == "function" && p(r, v);
            if (t || !j) {
                m(v);
                return
            }
            r++,
            (L = e.onFail) == null || L.call(e, r, v),
            gL(P).then( () => c() ? void 0 : y()).then( () => {
                t ? m(v) : k()
            }
            )
        }
        )
    }
    ;
    return {
        promise: i,
        cancel: a,
        continue: () => (s == null || s(),
        i),
        cancelRetry: o,
        continueRetry: l,
        canStart: f,
        start: () => (f() ? k() : y().then(k),
        i)
    }
}
function kL() {
    let e = []
      , t = 0
      , r = o => {
        o()
    }
      , n = o => {
        o()
    }
      , s = o => setTimeout(o, 0);
    const i = o => {
        t ? e.push(o) : s( () => {
            r(o)
        }
        )
    }
      , a = () => {
        const o = e;
        e = [],
        o.length && s( () => {
            n( () => {
                o.forEach(l => {
                    r(l)
                }
                )
            }
            )
        }
        )
    }
    ;
    return {
        batch: o => {
            let l;
            t++;
            try {
                l = o()
            } finally {
                t--,
                t || a()
            }
            return l
        }
        ,
        batchCalls: o => (...l) => {
            i( () => {
                o(...l)
            }
            )
        }
        ,
        schedule: i,
        setNotifyFunction: o => {
            r = o
        }
        ,
        setBatchNotifyFunction: o => {
            n = o
        }
        ,
        setScheduler: o => {
            s = o
        }
    }
}
var Mt = kL(), qi, j1, gS = (j1 = class {
    constructor() {
        de(this, qi)
    }
    destroy() {
        this.clearGcTimeout()
    }
    scheduleGc() {
        this.clearGcTimeout(),
        Wm(this.gcTime) && J(this, qi, setTimeout( () => {
            this.optionalRemove()
        }
        , this.gcTime))
    }
    updateGcTime(e) {
        this.gcTime = Math.max(this.gcTime || 0, e ?? (oa ? 1 / 0 : 5 * 60 * 1e3))
    }
    clearGcTimeout() {
        _(this, qi) && (clearTimeout(_(this, qi)),
        J(this, qi, void 0))
    }
}
,
qi = new WeakMap,
j1), vo, bo, Br, Hi, Jt, Vu, Zi, un, Qn, I1, EL = (I1 = class extends gS {
    constructor(t) {
        super();
        de(this, un);
        de(this, vo);
        de(this, bo);
        de(this, Br);
        de(this, Hi);
        de(this, Jt);
        de(this, Vu);
        de(this, Zi);
        J(this, Zi, !1),
        J(this, Vu, t.defaultOptions),
        this.setOptions(t.options),
        this.observers = [],
        J(this, Hi, t.client),
        J(this, Br, _(this, Hi).getQueryCache()),
        this.queryKey = t.queryKey,
        this.queryHash = t.queryHash,
        J(this, vo, _L(this.options)),
        this.state = t.state ?? _(this, vo),
        this.scheduleGc()
    }
    get meta() {
        return this.options.meta
    }
    get promise() {
        var t;
        return (t = _(this, Jt)) == null ? void 0 : t.promise
    }
    setOptions(t) {
        this.options = {
            ..._(this, Vu),
            ...t
        },
        this.updateGcTime(this.options.gcTime)
    }
    optionalRemove() {
        !this.observers.length && this.state.fetchStatus === "idle" && _(this, Br).remove(this)
    }
    setData(t, r) {
        const n = Hm(this.state.data, t, this.options);
        return Pe(this, un, Qn).call(this, {
            data: n,
            type: "success",
            dataUpdatedAt: r == null ? void 0 : r.updatedAt,
            manual: r == null ? void 0 : r.manual
        }),
        n
    }
    setState(t, r) {
        Pe(this, un, Qn).call(this, {
            type: "setState",
            state: t,
            setStateOptions: r
        })
    }
    cancel(t) {
        var n, s;
        const r = (n = _(this, Jt)) == null ? void 0 : n.promise;
        return (s = _(this, Jt)) == null || s.cancel(t),
        r ? r.then(Wr).catch(Wr) : Promise.resolve()
    }
    destroy() {
        super.destroy(),
        this.cancel({
            silent: !0
        })
    }
    reset() {
        this.destroy(),
        this.setState(_(this, vo))
    }
    isActive() {
        return this.observers.some(t => hn(t.options.enabled, this) !== !1)
    }
    isDisabled() {
        return this.getObserversCount() > 0 ? !this.isActive() : this.options.queryFn === ga || this.state.dataUpdateCount + this.state.errorUpdateCount === 0
    }
    isStale() {
        return this.state.isInvalidated ? !0 : this.getObserversCount() > 0 ? this.observers.some(t => t.getCurrentResult().isStale) : this.state.data === void 0
    }
    isStaleByTime(t=0) {
        return this.state.isInvalidated || this.state.data === void 0 || !dS(this.state.dataUpdatedAt, t)
    }
    onFocus() {
        var r;
        const t = this.observers.find(n => n.shouldFetchOnWindowFocus());
        t == null || t.refetch({
            cancelRefetch: !1
        }),
        (r = _(this, Jt)) == null || r.continue()
    }
    onOnline() {
        var r;
        const t = this.observers.find(n => n.shouldFetchOnReconnect());
        t == null || t.refetch({
            cancelRefetch: !1
        }),
        (r = _(this, Jt)) == null || r.continue()
    }
    addObserver(t) {
        this.observers.includes(t) || (this.observers.push(t),
        this.clearGcTimeout(),
        _(this, Br).notify({
            type: "observerAdded",
            query: this,
            observer: t
        }))
    }
    removeObserver(t) {
        this.observers.includes(t) && (this.observers = this.observers.filter(r => r !== t),
        this.observers.length || (_(this, Jt) && (_(this, Zi) ? _(this, Jt).cancel({
            revert: !0
        }) : _(this, Jt).cancelRetry()),
        this.scheduleGc()),
        _(this, Br).notify({
            type: "observerRemoved",
            query: this,
            observer: t
        }))
    }
    getObserversCount() {
        return this.observers.length
    }
    invalidate() {
        this.state.isInvalidated || Pe(this, un, Qn).call(this, {
            type: "invalidate"
        })
    }
    fetch(t, r) {
        var l, c, f;
        if (this.state.fetchStatus !== "idle") {
            if (this.state.data !== void 0 && (r != null && r.cancelRefetch))
                this.cancel({
                    silent: !0
                });
            else if (_(this, Jt))
                return _(this, Jt).continueRetry(),
                _(this, Jt).promise
        }
        if (t && this.setOptions(t),
        !this.options.queryFn) {
            const h = this.observers.find(m => m.options.queryFn);
            h && this.setOptions(h.options)
        }
        const n = new AbortController
          , s = h => {
            Object.defineProperty(h, "signal", {
                enumerable: !0,
                get: () => (J(this, Zi, !0),
                n.signal)
            })
        }
          , i = () => {
            const h = hS(this.options, r)
              , m = {
                client: _(this, Hi),
                queryKey: this.queryKey,
                meta: this.meta
            };
            return s(m),
            J(this, Zi, !1),
            this.options.persister ? this.options.persister(h, m, this) : h(m)
        }
          , a = {
            fetchOptions: r,
            options: this.options,
            queryKey: this.queryKey,
            client: _(this, Hi),
            state: this.state,
            fetchFn: i
        };
        s(a),
        (l = this.options.behavior) == null || l.onFetch(a, this),
        J(this, bo, this.state),
        (this.state.fetchStatus === "idle" || this.state.fetchMeta !== ((c = a.fetchOptions) == null ? void 0 : c.meta)) && Pe(this, un, Qn).call(this, {
            type: "fetch",
            meta: (f = a.fetchOptions) == null ? void 0 : f.meta
        });
        const o = h => {
            var m, y, k, x;
            Ah(h) && h.silent || Pe(this, un, Qn).call(this, {
                type: "error",
                error: h
            }),
            Ah(h) || ((y = (m = _(this, Br).config).onError) == null || y.call(m, h, this),
            (x = (k = _(this, Br).config).onSettled) == null || x.call(k, this.state.data, h, this)),
            this.scheduleGc()
        }
        ;
        return J(this, Jt, yS({
            initialPromise: r == null ? void 0 : r.initialPromise,
            fn: a.fetchFn,
            abort: n.abort.bind(n),
            onSuccess: h => {
                var m, y, k, x;
                if (h === void 0) {
                    o(new Error(`${this.queryHash} data is undefined`));
                    return
                }
                try {
                    this.setData(h)
                } catch (w) {
                    o(w);
                    return
                }
                (y = (m = _(this, Br).config).onSuccess) == null || y.call(m, h, this),
                (x = (k = _(this, Br).config).onSettled) == null || x.call(k, h, this.state.error, this),
                this.scheduleGc()
            }
            ,
            onError: o,
            onFail: (h, m) => {
                Pe(this, un, Qn).call(this, {
                    type: "failed",
                    failureCount: h,
                    error: m
                })
            }
            ,
            onPause: () => {
                Pe(this, un, Qn).call(this, {
                    type: "pause"
                })
            }
            ,
            onContinue: () => {
                Pe(this, un, Qn).call(this, {
                    type: "continue"
                })
            }
            ,
            retry: a.options.retry,
            retryDelay: a.options.retryDelay,
            networkMode: a.options.networkMode,
            canRun: () => !0
        })),
        _(this, Jt).start()
    }
}
,
vo = new WeakMap,
bo = new WeakMap,
Br = new WeakMap,
Hi = new WeakMap,
Jt = new WeakMap,
Vu = new WeakMap,
Zi = new WeakMap,
un = new WeakSet,
Qn = function(t) {
    const r = n => {
        switch (t.type) {
        case "failed":
            return {
                ...n,
                fetchFailureCount: t.failureCount,
                fetchFailureReason: t.error
            };
        case "pause":
            return {
                ...n,
                fetchStatus: "paused"
            };
        case "continue":
            return {
                ...n,
                fetchStatus: "fetching"
            };
        case "fetch":
            return {
                ...n,
                ...vS(n.data, this.options),
                fetchMeta: t.meta ?? null
            };
        case "success":
            return {
                ...n,
                data: t.data,
                dataUpdateCount: n.dataUpdateCount + 1,
                dataUpdatedAt: t.dataUpdatedAt ?? Date.now(),
                error: null,
                isInvalidated: !1,
                status: "success",
                ...!t.manual && {
                    fetchStatus: "idle",
                    fetchFailureCount: 0,
                    fetchFailureReason: null
                }
            };
        case "error":
            const s = t.error;
            return Ah(s) && s.revert && _(this, bo) ? {
                ..._(this, bo),
                fetchStatus: "idle"
            } : {
                ...n,
                error: s,
                errorUpdateCount: n.errorUpdateCount + 1,
                errorUpdatedAt: Date.now(),
                fetchFailureCount: n.fetchFailureCount + 1,
                fetchFailureReason: s,
                fetchStatus: "idle",
                status: "error"
            };
        case "invalidate":
            return {
                ...n,
                isInvalidated: !0
            };
        case "setState":
            return {
                ...n,
                ...t.state
            }
        }
    }
    ;
    this.state = r(this.state),
    Mt.batch( () => {
        this.observers.forEach(n => {
            n.onQueryUpdate()
        }
        ),
        _(this, Br).notify({
            query: this,
            type: "updated",
            action: t
        })
    }
    )
}
,
I1);
function vS(e, t) {
    return {
        fetchFailureCount: 0,
        fetchFailureReason: null,
        fetchStatus: mS(t.networkMode) ? "fetching" : "paused",
        ...e === void 0 && {
            error: null,
            status: "pending"
        }
    }
}
function _L(e) {
    const t = typeof e.initialData == "function" ? e.initialData() : e.initialData
      , r = t !== void 0
      , n = r ? typeof e.initialDataUpdatedAt == "function" ? e.initialDataUpdatedAt() : e.initialDataUpdatedAt : 0;
    return {
        data: t,
        dataUpdateCount: 0,
        dataUpdatedAt: r ? n ?? Date.now() : 0,
        error: null,
        errorUpdateCount: 0,
        errorUpdatedAt: 0,
        fetchFailureCount: 0,
        fetchFailureReason: null,
        fetchMeta: null,
        isInvalidated: !1,
        status: r ? "success" : "pending",
        fetchStatus: "idle"
    }
}
var Nn, R1, TL = (R1 = class extends Go {
    constructor(t={}) {
        super();
        de(this, Nn);
        this.config = t,
        J(this, Nn, new Map)
    }
    build(t, r, n) {
        const s = r.queryKey
          , i = r.queryHash ?? Xy(s, r);
        let a = this.get(i);
        return a || (a = new EL({
            client: t,
            queryKey: s,
            queryHash: i,
            options: t.defaultQueryOptions(r),
            state: n,
            defaultOptions: t.getQueryDefaults(s)
        }),
        this.add(a)),
        a
    }
    add(t) {
        _(this, Nn).has(t.queryHash) || (_(this, Nn).set(t.queryHash, t),
        this.notify({
            type: "added",
            query: t
        }))
    }
    remove(t) {
        const r = _(this, Nn).get(t.queryHash);
        r && (t.destroy(),
        r === t && _(this, Nn).delete(t.queryHash),
        this.notify({
            type: "removed",
            query: t
        }))
    }
    clear() {
        Mt.batch( () => {
            this.getAll().forEach(t => {
                this.remove(t)
            }
            )
        }
        )
    }
    get(t) {
        return _(this, Nn).get(t)
    }
    getAll() {
        return [..._(this, Nn).values()]
    }
    find(t) {
        const r = {
            exact: !0,
            ...t
        };
        return this.getAll().find(n => L0(r, n))
    }
    findAll(t={}) {
        const r = this.getAll();
        return Object.keys(t).length > 0 ? r.filter(n => L0(t, n)) : r
    }
    notify(t) {
        Mt.batch( () => {
            this.listeners.forEach(r => {
                r(t)
            }
            )
        }
        )
    }
    onFocus() {
        Mt.batch( () => {
            this.getAll().forEach(t => {
                t.onFocus()
            }
            )
        }
        )
    }
    onOnline() {
        Mt.batch( () => {
            this.getAll().forEach(t => {
                t.onOnline()
            }
            )
        }
        )
    }
}
,
Nn = new WeakMap,
R1), jn, lr, Ki, In, Ps, O1, CL = (O1 = class extends gS {
    constructor(t) {
        super();
        de(this, In);
        de(this, jn);
        de(this, lr);
        de(this, Ki);
        this.mutationId = t.mutationId,
        J(this, lr, t.mutationCache),
        J(this, jn, []),
        this.state = t.state || bS(),
        this.setOptions(t.options),
        this.scheduleGc()
    }
    setOptions(t) {
        this.options = t,
        this.updateGcTime(this.options.gcTime)
    }
    get meta() {
        return this.options.meta
    }
    addObserver(t) {
        _(this, jn).includes(t) || (_(this, jn).push(t),
        this.clearGcTimeout(),
        _(this, lr).notify({
            type: "observerAdded",
            mutation: this,
            observer: t
        }))
    }
    removeObserver(t) {
        J(this, jn, _(this, jn).filter(r => r !== t)),
        this.scheduleGc(),
        _(this, lr).notify({
            type: "observerRemoved",
            mutation: this,
            observer: t
        })
    }
    optionalRemove() {
        _(this, jn).length || (this.state.status === "pending" ? this.scheduleGc() : _(this, lr).remove(this))
    }
    continue() {
        var t;
        return ((t = _(this, Ki)) == null ? void 0 : t.continue()) ?? this.execute(this.state.variables)
    }
    async execute(t) {
        var s, i, a, o, l, c, f, h, m, y, k, x, w, v, p, S, P, j, L, E;
        J(this, Ki, yS({
            fn: () => this.options.mutationFn ? this.options.mutationFn(t) : Promise.reject(new Error("No mutationFn found")),
            onFail: (b, O) => {
                Pe(this, In, Ps).call(this, {
                    type: "failed",
                    failureCount: b,
                    error: O
                })
            }
            ,
            onPause: () => {
                Pe(this, In, Ps).call(this, {
                    type: "pause"
                })
            }
            ,
            onContinue: () => {
                Pe(this, In, Ps).call(this, {
                    type: "continue"
                })
            }
            ,
            retry: this.options.retry ?? 0,
            retryDelay: this.options.retryDelay,
            networkMode: this.options.networkMode,
            canRun: () => _(this, lr).canRun(this)
        }));
        const r = this.state.status === "pending"
          , n = !_(this, Ki).canStart();
        try {
            if (!r) {
                Pe(this, In, Ps).call(this, {
                    type: "pending",
                    variables: t,
                    isPaused: n
                }),
                await ((i = (s = _(this, lr).config).onMutate) == null ? void 0 : i.call(s, t, this));
                const O = await ((o = (a = this.options).onMutate) == null ? void 0 : o.call(a, t));
                O !== this.state.context && Pe(this, In, Ps).call(this, {
                    type: "pending",
                    context: O,
                    variables: t,
                    isPaused: n
                })
            }
            const b = await _(this, Ki).start();
            return await ((c = (l = _(this, lr).config).onSuccess) == null ? void 0 : c.call(l, b, t, this.state.context, this)),
            await ((h = (f = this.options).onSuccess) == null ? void 0 : h.call(f, b, t, this.state.context)),
            await ((y = (m = _(this, lr).config).onSettled) == null ? void 0 : y.call(m, b, null, this.state.variables, this.state.context, this)),
            await ((x = (k = this.options).onSettled) == null ? void 0 : x.call(k, b, null, t, this.state.context)),
            Pe(this, In, Ps).call(this, {
                type: "success",
                data: b
            }),
            b
        } catch (b) {
            try {
                throw await ((v = (w = _(this, lr).config).onError) == null ? void 0 : v.call(w, b, t, this.state.context, this)),
                await ((S = (p = this.options).onError) == null ? void 0 : S.call(p, b, t, this.state.context)),
                await ((j = (P = _(this, lr).config).onSettled) == null ? void 0 : j.call(P, void 0, b, this.state.variables, this.state.context, this)),
                await ((E = (L = this.options).onSettled) == null ? void 0 : E.call(L, void 0, b, t, this.state.context)),
                b
            } finally {
                Pe(this, In, Ps).call(this, {
                    type: "error",
                    error: b
                })
            }
        } finally {
            _(this, lr).runNext(this)
        }
    }
}
,
jn = new WeakMap,
lr = new WeakMap,
Ki = new WeakMap,
In = new WeakSet,
Ps = function(t) {
    const r = n => {
        switch (t.type) {
        case "failed":
            return {
                ...n,
                failureCount: t.failureCount,
                failureReason: t.error
            };
        case "pause":
            return {
                ...n,
                isPaused: !0
            };
        case "continue":
            return {
                ...n,
                isPaused: !1
            };
        case "pending":
            return {
                ...n,
                context: t.context,
                data: void 0,
                failureCount: 0,
                failureReason: null,
                error: null,
                isPaused: t.isPaused,
                status: "pending",
                variables: t.variables,
                submittedAt: Date.now()
            };
        case "success":
            return {
                ...n,
                data: t.data,
                failureCount: 0,
                failureReason: null,
                error: null,
                status: "success",
                isPaused: !1
            };
        case "error":
            return {
                ...n,
                data: void 0,
                error: t.error,
                failureCount: n.failureCount + 1,
                failureReason: t.error,
                isPaused: !1,
                status: "error"
            }
        }
    }
    ;
    this.state = r(this.state),
    Mt.batch( () => {
        _(this, jn).forEach(n => {
            n.onMutationUpdate(t)
        }
        ),
        _(this, lr).notify({
            mutation: this,
            type: "updated",
            action: t
        })
    }
    )
}
,
O1);
function bS() {
    return {
        context: void 0,
        data: void 0,
        error: null,
        failureCount: 0,
        failureReason: null,
        isPaused: !1,
        status: "idle",
        variables: void 0,
        submittedAt: 0
    }
}
var Xn, cn, Bu, M1, PL = (M1 = class extends Go {
    constructor(t={}) {
        super();
        de(this, Xn);
        de(this, cn);
        de(this, Bu);
        this.config = t,
        J(this, Xn, new Set),
        J(this, cn, new Map),
        J(this, Bu, 0)
    }
    build(t, r, n) {
        const s = new CL({
            mutationCache: this,
            mutationId: ++wc(this, Bu)._,
            options: t.defaultMutationOptions(r),
            state: n
        });
        return this.add(s),
        s
    }
    add(t) {
        _(this, Xn).add(t);
        const r = $c(t);
        if (typeof r == "string") {
            const n = _(this, cn).get(r);
            n ? n.push(t) : _(this, cn).set(r, [t])
        }
        this.notify({
            type: "added",
            mutation: t
        })
    }
    remove(t) {
        if (_(this, Xn).delete(t)) {
            const r = $c(t);
            if (typeof r == "string") {
                const n = _(this, cn).get(r);
                if (n)
                    if (n.length > 1) {
                        const s = n.indexOf(t);
                        s !== -1 && n.splice(s, 1)
                    } else
                        n[0] === t && _(this, cn).delete(r)
            }
        }
        this.notify({
            type: "removed",
            mutation: t
        })
    }
    canRun(t) {
        const r = $c(t);
        if (typeof r == "string") {
            const n = _(this, cn).get(r)
              , s = n == null ? void 0 : n.find(i => i.state.status === "pending");
            return !s || s === t
        } else
            return !0
    }
    runNext(t) {
        var n;
        const r = $c(t);
        if (typeof r == "string") {
            const s = (n = _(this, cn).get(r)) == null ? void 0 : n.find(i => i !== t && i.state.isPaused);
            return (s == null ? void 0 : s.continue()) ?? Promise.resolve()
        } else
            return Promise.resolve()
    }
    clear() {
        Mt.batch( () => {
            _(this, Xn).forEach(t => {
                this.notify({
                    type: "removed",
                    mutation: t
                })
            }
            ),
            _(this, Xn).clear(),
            _(this, cn).clear()
        }
        )
    }
    getAll() {
        return Array.from(_(this, Xn))
    }
    find(t) {
        const r = {
            exact: !0,
            ...t
        };
        return this.getAll().find(n => D0(r, n))
    }
    findAll(t={}) {
        return this.getAll().filter(r => D0(t, r))
    }
    notify(t) {
        Mt.batch( () => {
            this.listeners.forEach(r => {
                r(t)
            }
            )
        }
        )
    }
    resumePausedMutations() {
        const t = this.getAll().filter(r => r.state.isPaused);
        return Mt.batch( () => Promise.all(t.map(r => r.continue().catch(Wr))))
    }
}
,
Xn = new WeakMap,
cn = new WeakMap,
Bu = new WeakMap,
M1);
function $c(e) {
    var t;
    return (t = e.options.scope) == null ? void 0 : t.id
}
function qd(e) {
    return {
        onFetch: (t, r) => {
            var f, h, m, y, k;
            const n = t.options
              , s = (m = (h = (f = t.fetchOptions) == null ? void 0 : f.meta) == null ? void 0 : h.fetchMore) == null ? void 0 : m.direction
              , i = ((y = t.state.data) == null ? void 0 : y.pages) || []
              , a = ((k = t.state.data) == null ? void 0 : k.pageParams) || [];
            let o = {
                pages: [],
                pageParams: []
            }
              , l = 0;
            const c = async () => {
                let x = !1;
                const w = S => {
                    Object.defineProperty(S, "signal", {
                        enumerable: !0,
                        get: () => (t.signal.aborted ? x = !0 : t.signal.addEventListener("abort", () => {
                            x = !0
                        }
                        ),
                        t.signal)
                    })
                }
                  , v = hS(t.options, t.fetchOptions)
                  , p = async (S, P, j) => {
                    if (x)
                        return Promise.reject();
                    if (P == null && S.pages.length)
                        return Promise.resolve(S);
                    const L = {
                        client: t.client,
                        queryKey: t.queryKey,
                        pageParam: P,
                        direction: j ? "backward" : "forward",
                        meta: t.options.meta
                    };
                    w(L);
                    const E = await v(L)
                      , {maxPages: b} = t.options
                      , O = j ? bL : vL;
                    return {
                        pages: O(S.pages, E, b),
                        pageParams: O(S.pageParams, P, b)
                    }
                }
                ;
                if (s && i.length) {
                    const S = s === "backward"
                      , P = S ? xS : Km
                      , j = {
                        pages: i,
                        pageParams: a
                    }
                      , L = P(n, j);
                    o = await p(j, L, S)
                } else {
                    const S = e ?? i.length;
                    do {
                        const P = l === 0 ? a[0] ?? n.initialPageParam : Km(n, o);
                        if (l > 0 && P == null)
                            break;
                        o = await p(o, P),
                        l++
                    } while (l < S)
                }
                return o
            }
            ;
            t.options.persister ? t.fetchFn = () => {
                var x, w;
                return (w = (x = t.options).persister) == null ? void 0 : w.call(x, c, {
                    client: t.client,
                    queryKey: t.queryKey,
                    meta: t.options.meta,
                    signal: t.signal
                }, r)
            }
            : t.fetchFn = c
        }
    }
}
function Km(e, {pages: t, pageParams: r}) {
    const n = t.length - 1;
    return t.length > 0 ? e.getNextPageParam(t[n], t, r[n], r) : void 0
}
function xS(e, {pages: t, pageParams: r}) {
    var n;
    return t.length > 0 ? (n = e.getPreviousPageParam) == null ? void 0 : n.call(e, t[0], t, r[0], r) : void 0
}
function $L(e, t) {
    return t ? Km(e, t) != null : !1
}
function NL(e, t) {
    return !t || !e.getPreviousPageParam ? !1 : xS(e, t) != null
}
var yt, Us, Vs, xo, wo, Bs, So, ko, A1, jL = (A1 = class {
    constructor(e={}) {
        de(this, yt);
        de(this, Us);
        de(this, Vs);
        de(this, xo);
        de(this, wo);
        de(this, Bs);
        de(this, So);
        de(this, ko);
        J(this, yt, e.queryCache || new TL),
        J(this, Us, e.mutationCache || new PL),
        J(this, Vs, e.defaultOptions || {}),
        J(this, xo, new Map),
        J(this, wo, new Map),
        J(this, Bs, 0)
    }
    mount() {
        wc(this, Bs)._++,
        _(this, Bs) === 1 && (J(this, So, eg.subscribe(async e => {
            e && (await this.resumePausedMutations(),
            _(this, yt).onFocus())
        }
        )),
        J(this, ko, Wd.subscribe(async e => {
            e && (await this.resumePausedMutations(),
            _(this, yt).onOnline())
        }
        )))
    }
    unmount() {
        var e, t;
        wc(this, Bs)._--,
        _(this, Bs) === 0 && ((e = _(this, So)) == null || e.call(this),
        J(this, So, void 0),
        (t = _(this, ko)) == null || t.call(this),
        J(this, ko, void 0))
    }
    isFetching(e) {
        return _(this, yt).findAll({
            ...e,
            fetchStatus: "fetching"
        }).length
    }
    isMutating(e) {
        return _(this, Us).findAll({
            ...e,
            status: "pending"
        }).length
    }
    getQueryData(e) {
        var r;
        const t = this.defaultQueryOptions({
            queryKey: e
        });
        return (r = _(this, yt).get(t.queryHash)) == null ? void 0 : r.state.data
    }
    ensureQueryData(e) {
        const t = this.defaultQueryOptions(e)
          , r = _(this, yt).build(this, t)
          , n = r.state.data;
        return n === void 0 ? this.fetchQuery(e) : (e.revalidateIfStale && r.isStaleByTime(so(t.staleTime, r)) && this.prefetchQuery(t),
        Promise.resolve(n))
    }
    getQueriesData(e) {
        return _(this, yt).findAll(e).map( ({queryKey: t, state: r}) => {
            const n = r.data;
            return [t, n]
        }
        )
    }
    setQueryData(e, t, r) {
        const n = this.defaultQueryOptions({
            queryKey: e
        })
          , s = _(this, yt).get(n.queryHash)
          , i = s == null ? void 0 : s.state.data
          , a = yL(t, i);
        if (a !== void 0)
            return _(this, yt).build(this, n).setData(a, {
                ...r,
                manual: !0
            })
    }
    setQueriesData(e, t, r) {
        return Mt.batch( () => _(this, yt).findAll(e).map( ({queryKey: n}) => [n, this.setQueryData(n, t, r)]))
    }
    getQueryState(e) {
        var r;
        const t = this.defaultQueryOptions({
            queryKey: e
        });
        return (r = _(this, yt).get(t.queryHash)) == null ? void 0 : r.state
    }
    removeQueries(e) {
        const t = _(this, yt);
        Mt.batch( () => {
            t.findAll(e).forEach(r => {
                t.remove(r)
            }
            )
        }
        )
    }
    resetQueries(e, t) {
        const r = _(this, yt);
        return Mt.batch( () => (r.findAll(e).forEach(n => {
            n.reset()
        }
        ),
        this.refetchQueries({
            type: "active",
            ...e
        }, t)))
    }
    cancelQueries(e, t={}) {
        const r = {
            revert: !0,
            ...t
        }
          , n = Mt.batch( () => _(this, yt).findAll(e).map(s => s.cancel(r)));
        return Promise.all(n).then(Wr).catch(Wr)
    }
    invalidateQueries(e, t={}) {
        return Mt.batch( () => (_(this, yt).findAll(e).forEach(r => {
            r.invalidate()
        }
        ),
        (e == null ? void 0 : e.refetchType) === "none" ? Promise.resolve() : this.refetchQueries({
            ...e,
            type: (e == null ? void 0 : e.refetchType) ?? (e == null ? void 0 : e.type) ?? "active"
        }, t)))
    }
    refetchQueries(e, t={}) {
        const r = {
            ...t,
            cancelRefetch: t.cancelRefetch ?? !0
        }
          , n = Mt.batch( () => _(this, yt).findAll(e).filter(s => !s.isDisabled()).map(s => {
            let i = s.fetch(void 0, r);
            return r.throwOnError || (i = i.catch(Wr)),
            s.state.fetchStatus === "paused" ? Promise.resolve() : i
        }
        ));
        return Promise.all(n).then(Wr)
    }
    fetchQuery(e) {
        const t = this.defaultQueryOptions(e);
        t.retry === void 0 && (t.retry = !1);
        const r = _(this, yt).build(this, t);
        return r.isStaleByTime(so(t.staleTime, r)) ? r.fetch(t) : Promise.resolve(r.state.data)
    }
    prefetchQuery(e) {
        return this.fetchQuery(e).then(Wr).catch(Wr)
    }
    fetchInfiniteQuery(e) {
        return e.behavior = qd(e.pages),
        this.fetchQuery(e)
    }
    prefetchInfiniteQuery(e) {
        return this.fetchInfiniteQuery(e).then(Wr).catch(Wr)
    }
    ensureInfiniteQueryData(e) {
        return e.behavior = qd(e.pages),
        this.ensureQueryData(e)
    }
    resumePausedMutations() {
        return Wd.isOnline() ? _(this, Us).resumePausedMutations() : Promise.resolve()
    }
    getQueryCache() {
        return _(this, yt)
    }
    getMutationCache() {
        return _(this, Us)
    }
    getDefaultOptions() {
        return _(this, Vs)
    }
    setDefaultOptions(e) {
        J(this, Vs, e)
    }
    setQueryDefaults(e, t) {
        _(this, xo).set(la(e), {
            queryKey: e,
            defaultOptions: t
        })
    }
    getQueryDefaults(e) {
        const t = [..._(this, xo).values()]
          , r = {};
        return t.forEach(n => {
            vu(e, n.queryKey) && Object.assign(r, n.defaultOptions)
        }
        ),
        r
    }
    setMutationDefaults(e, t) {
        _(this, wo).set(la(e), {
            mutationKey: e,
            defaultOptions: t
        })
    }
    getMutationDefaults(e) {
        const t = [..._(this, wo).values()]
          , r = {};
        return t.forEach(n => {
            vu(e, n.mutationKey) && Object.assign(r, n.defaultOptions)
        }
        ),
        r
    }
    defaultQueryOptions(e) {
        if (e._defaulted)
            return e;
        const t = {
            ..._(this, Vs).queries,
            ...this.getQueryDefaults(e.queryKey),
            ...e,
            _defaulted: !0
        };
        return t.queryHash || (t.queryHash = Xy(t.queryKey, t)),
        t.refetchOnReconnect === void 0 && (t.refetchOnReconnect = t.networkMode !== "always"),
        t.throwOnError === void 0 && (t.throwOnError = !!t.suspense),
        !t.networkMode && t.persister && (t.networkMode = "offlineFirst"),
        t.queryFn === ga && (t.enabled = !1),
        t
    }
    defaultMutationOptions(e) {
        return e != null && e._defaulted ? e : {
            ..._(this, Vs).mutations,
            ...(e == null ? void 0 : e.mutationKey) && this.getMutationDefaults(e.mutationKey),
            ...e,
            _defaulted: !0
        }
    }
    clear() {
        _(this, yt).clear(),
        _(this, Us).clear()
    }
}
,
yt = new WeakMap,
Us = new WeakMap,
Vs = new WeakMap,
xo = new WeakMap,
wo = new WeakMap,
Bs = new WeakMap,
So = new WeakMap,
ko = new WeakMap,
A1), Sr, Ie, Wu, ur, Qi, Eo, Ws, Rn, qu, _o, To, Gi, Yi, qs, Co, qe, Il, Qm, Gm, Ym, Jm, Xm, ep, tp, SS, L1, wS = (L1 = class extends Go {
    constructor(t, r) {
        super();
        de(this, qe);
        de(this, Sr);
        de(this, Ie);
        de(this, Wu);
        de(this, ur);
        de(this, Qi);
        de(this, Eo);
        de(this, Ws);
        de(this, Rn);
        de(this, qu);
        de(this, _o);
        de(this, To);
        de(this, Gi);
        de(this, Yi);
        de(this, qs);
        de(this, Co, new Set);
        this.options = r,
        J(this, Sr, t),
        J(this, Rn, null),
        J(this, Ws, Zm()),
        this.options.experimental_prefetchInRender || _(this, Ws).reject(new Error("experimental_prefetchInRender feature flag is not enabled")),
        this.bindMethods(),
        this.setOptions(r)
    }
    bindMethods() {
        this.refetch = this.refetch.bind(this)
    }
    onSubscribe() {
        this.listeners.size === 1 && (_(this, Ie).addObserver(this),
        U0(_(this, Ie), this.options) ? Pe(this, qe, Il).call(this) : this.updateResult(),
        Pe(this, qe, Jm).call(this))
    }
    onUnsubscribe() {
        this.hasListeners() || this.destroy()
    }
    shouldFetchOnReconnect() {
        return rp(_(this, Ie), this.options, this.options.refetchOnReconnect)
    }
    shouldFetchOnWindowFocus() {
        return rp(_(this, Ie), this.options, this.options.refetchOnWindowFocus)
    }
    destroy() {
        this.listeners = new Set,
        Pe(this, qe, Xm).call(this),
        Pe(this, qe, ep).call(this),
        _(this, Ie).removeObserver(this)
    }
    setOptions(t, r) {
        const n = this.options
          , s = _(this, Ie);
        if (this.options = _(this, Sr).defaultQueryOptions(t),
        this.options.enabled !== void 0 && typeof this.options.enabled != "boolean" && typeof this.options.enabled != "function" && typeof hn(this.options.enabled, _(this, Ie)) != "boolean")
            throw new Error("Expected enabled to be a boolean or a callback that returns a boolean");
        Pe(this, qe, tp).call(this),
        _(this, Ie).setOptions(this.options),
        n._defaulted && !Bd(this.options, n) && _(this, Sr).getQueryCache().notify({
            type: "observerOptionsUpdated",
            query: _(this, Ie),
            observer: this
        });
        const i = this.hasListeners();
        i && V0(_(this, Ie), s, this.options, n) && Pe(this, qe, Il).call(this),
        this.updateResult(r),
        i && (_(this, Ie) !== s || hn(this.options.enabled, _(this, Ie)) !== hn(n.enabled, _(this, Ie)) || so(this.options.staleTime, _(this, Ie)) !== so(n.staleTime, _(this, Ie))) && Pe(this, qe, Qm).call(this);
        const a = Pe(this, qe, Gm).call(this);
        i && (_(this, Ie) !== s || hn(this.options.enabled, _(this, Ie)) !== hn(n.enabled, _(this, Ie)) || a !== _(this, qs)) && Pe(this, qe, Ym).call(this, a)
    }
    getOptimisticResult(t) {
        const r = _(this, Sr).getQueryCache().build(_(this, Sr), t)
          , n = this.createResult(r, t);
        return RL(this, n) && (J(this, ur, n),
        J(this, Eo, this.options),
        J(this, Qi, _(this, Ie).state)),
        n
    }
    getCurrentResult() {
        return _(this, ur)
    }
    trackResult(t, r) {
        const n = {};
        return Object.keys(t).forEach(s => {
            Object.defineProperty(n, s, {
                configurable: !1,
                enumerable: !0,
                get: () => (this.trackProp(s),
                r == null || r(s),
                t[s])
            })
        }
        ),
        n
    }
    trackProp(t) {
        _(this, Co).add(t)
    }
    getCurrentQuery() {
        return _(this, Ie)
    }
    refetch({...t}={}) {
        return this.fetch({
            ...t
        })
    }
    fetchOptimistic(t) {
        const r = _(this, Sr).defaultQueryOptions(t)
          , n = _(this, Sr).getQueryCache().build(_(this, Sr), r);
        return n.fetch().then( () => this.createResult(n, r))
    }
    fetch(t) {
        return Pe(this, qe, Il).call(this, {
            ...t,
            cancelRefetch: t.cancelRefetch ?? !0
        }).then( () => (this.updateResult(),
        _(this, ur)))
    }
    createResult(t, r) {
        var b;
        const n = _(this, Ie)
          , s = this.options
          , i = _(this, ur)
          , a = _(this, Qi)
          , o = _(this, Eo)
          , c = t !== n ? t.state : _(this, Wu)
          , {state: f} = t;
        let h = {
            ...f
        }, m = !1, y;
        if (r._optimisticResults) {
            const O = this.hasListeners()
              , M = !O && U0(t, r)
              , D = O && V0(t, n, r, s);
            (M || D) && (h = {
                ...h,
                ...vS(f.data, t.options)
            }),
            r._optimisticResults === "isRestoring" && (h.fetchStatus = "idle")
        }
        let {error: k, errorUpdatedAt: x, status: w} = h;
        if (r.select && h.data !== void 0)
            if (i && h.data === (a == null ? void 0 : a.data) && r.select === _(this, qu))
                y = _(this, _o);
            else
                try {
                    J(this, qu, r.select),
                    y = r.select(h.data),
                    y = Hm(i == null ? void 0 : i.data, y, r),
                    J(this, _o, y),
                    J(this, Rn, null)
                } catch (O) {
                    J(this, Rn, O)
                }
        else
            y = h.data;
        if (r.placeholderData !== void 0 && y === void 0 && w === "pending") {
            let O;
            if (i != null && i.isPlaceholderData && r.placeholderData === (o == null ? void 0 : o.placeholderData))
                O = i.data;
            else if (O = typeof r.placeholderData == "function" ? r.placeholderData((b = _(this, To)) == null ? void 0 : b.state.data, _(this, To)) : r.placeholderData,
            r.select && O !== void 0)
                try {
                    O = r.select(O),
                    J(this, Rn, null)
                } catch (M) {
                    J(this, Rn, M)
                }
            O !== void 0 && (w = "success",
            y = Hm(i == null ? void 0 : i.data, O, r),
            m = !0)
        }
        _(this, Rn) && (k = _(this, Rn),
        y = _(this, _o),
        x = Date.now(),
        w = "error");
        const v = h.fetchStatus === "fetching"
          , p = w === "pending"
          , S = w === "error"
          , P = p && v
          , j = y !== void 0
          , E = {
            status: w,
            fetchStatus: h.fetchStatus,
            isPending: p,
            isSuccess: w === "success",
            isError: S,
            isInitialLoading: P,
            isLoading: P,
            data: y,
            dataUpdatedAt: h.dataUpdatedAt,
            error: k,
            errorUpdatedAt: x,
            failureCount: h.fetchFailureCount,
            failureReason: h.fetchFailureReason,
            errorUpdateCount: h.errorUpdateCount,
            isFetched: h.dataUpdateCount > 0 || h.errorUpdateCount > 0,
            isFetchedAfterMount: h.dataUpdateCount > c.dataUpdateCount || h.errorUpdateCount > c.errorUpdateCount,
            isFetching: v,
            isRefetching: v && !p,
            isLoadingError: S && !j,
            isPaused: h.fetchStatus === "paused",
            isPlaceholderData: m,
            isRefetchError: S && j,
            isStale: tg(t, r),
            refetch: this.refetch,
            promise: _(this, Ws)
        };
        if (this.options.experimental_prefetchInRender) {
            const O = z => {
                E.status === "error" ? z.reject(E.error) : E.data !== void 0 && z.resolve(E.data)
            }
              , M = () => {
                const z = J(this, Ws, E.promise = Zm());
                O(z)
            }
              , D = _(this, Ws);
            switch (D.status) {
            case "pending":
                t.queryHash === n.queryHash && O(D);
                break;
            case "fulfilled":
                (E.status === "error" || E.data !== D.value) && M();
                break;
            case "rejected":
                (E.status !== "error" || E.error !== D.reason) && M();
                break
            }
        }
        return E
    }
    updateResult(t) {
        const r = _(this, ur)
          , n = this.createResult(_(this, Ie), this.options);
        if (J(this, Qi, _(this, Ie).state),
        J(this, Eo, this.options),
        _(this, Qi).data !== void 0 && J(this, To, _(this, Ie)),
        Bd(n, r))
            return;
        J(this, ur, n);
        const s = {}
          , i = () => {
            if (!r)
                return !0;
            const {notifyOnChangeProps: a} = this.options
              , o = typeof a == "function" ? a() : a;
            if (o === "all" || !o && !_(this, Co).size)
                return !0;
            const l = new Set(o ?? _(this, Co));
            return this.options.throwOnError && l.add("error"),
            Object.keys(_(this, ur)).some(c => {
                const f = c;
                return _(this, ur)[f] !== r[f] && l.has(f)
            }
            )
        }
        ;
        (t == null ? void 0 : t.listeners) !== !1 && i() && (s.listeners = !0),
        Pe(this, qe, SS).call(this, {
            ...s,
            ...t
        })
    }
    onQueryUpdate() {
        this.updateResult(),
        this.hasListeners() && Pe(this, qe, Jm).call(this)
    }
}
,
Sr = new WeakMap,
Ie = new WeakMap,
Wu = new WeakMap,
ur = new WeakMap,
Qi = new WeakMap,
Eo = new WeakMap,
Ws = new WeakMap,
Rn = new WeakMap,
qu = new WeakMap,
_o = new WeakMap,
To = new WeakMap,
Gi = new WeakMap,
Yi = new WeakMap,
qs = new WeakMap,
Co = new WeakMap,
qe = new WeakSet,
Il = function(t) {
    Pe(this, qe, tp).call(this);
    let r = _(this, Ie).fetch(this.options, t);
    return t != null && t.throwOnError || (r = r.catch(Wr)),
    r
}
,
Qm = function() {
    Pe(this, qe, Xm).call(this);
    const t = so(this.options.staleTime, _(this, Ie));
    if (oa || _(this, ur).isStale || !Wm(t))
        return;
    const n = dS(_(this, ur).dataUpdatedAt, t) + 1;
    J(this, Gi, setTimeout( () => {
        _(this, ur).isStale || this.updateResult()
    }
    , n))
}
,
Gm = function() {
    return (typeof this.options.refetchInterval == "function" ? this.options.refetchInterval(_(this, Ie)) : this.options.refetchInterval) ?? !1
}
,
Ym = function(t) {
    Pe(this, qe, ep).call(this),
    J(this, qs, t),
    !(oa || hn(this.options.enabled, _(this, Ie)) === !1 || !Wm(_(this, qs)) || _(this, qs) === 0) && J(this, Yi, setInterval( () => {
        (this.options.refetchIntervalInBackground || eg.isFocused()) && Pe(this, qe, Il).call(this)
    }
    , _(this, qs)))
}
,
Jm = function() {
    Pe(this, qe, Qm).call(this),
    Pe(this, qe, Ym).call(this, Pe(this, qe, Gm).call(this))
}
,
Xm = function() {
    _(this, Gi) && (clearTimeout(_(this, Gi)),
    J(this, Gi, void 0))
}
,
ep = function() {
    _(this, Yi) && (clearInterval(_(this, Yi)),
    J(this, Yi, void 0))
}
,
tp = function() {
    const t = _(this, Sr).getQueryCache().build(_(this, Sr), this.options);
    if (t === _(this, Ie))
        return;
    const r = _(this, Ie);
    J(this, Ie, t),
    J(this, Wu, t.state),
    this.hasListeners() && (r == null || r.removeObserver(this),
    t.addObserver(this))
}
,
SS = function(t) {
    Mt.batch( () => {
        t.listeners && this.listeners.forEach(r => {
            r(_(this, ur))
        }
        ),
        _(this, Sr).getQueryCache().notify({
            query: _(this, Ie),
            type: "observerResultsUpdated"
        })
    }
    )
}
,
L1);
function IL(e, t) {
    return hn(t.enabled, e) !== !1 && e.state.data === void 0 && !(e.state.status === "error" && t.retryOnMount === !1)
}
function U0(e, t) {
    return IL(e, t) || e.state.data !== void 0 && rp(e, t, t.refetchOnMount)
}
function rp(e, t, r) {
    if (hn(t.enabled, e) !== !1) {
        const n = typeof r == "function" ? r(e) : r;
        return n === "always" || n !== !1 && tg(e, t)
    }
    return !1
}
function V0(e, t, r, n) {
    return (e !== t || hn(n.enabled, e) === !1) && (!r.suspense || e.state.status !== "error") && tg(e, r)
}
function tg(e, t) {
    return hn(t.enabled, e) !== !1 && e.isStaleByTime(so(t.staleTime, e))
}
function RL(e, t) {
    return !Bd(e.getCurrentResult(), t)
}
var OL = class extends wS {
    constructor(e, t) {
        super(e, t)
    }
    bindMethods() {
        super.bindMethods(),
        this.fetchNextPage = this.fetchNextPage.bind(this),
        this.fetchPreviousPage = this.fetchPreviousPage.bind(this)
    }
    setOptions(e, t) {
        super.setOptions({
            ...e,
            behavior: qd()
        }, t)
    }
    getOptimisticResult(e) {
        return e.behavior = qd(),
        super.getOptimisticResult(e)
    }
    fetchNextPage(e) {
        return this.fetch({
            ...e,
            meta: {
                fetchMore: {
                    direction: "forward"
                }
            }
        })
    }
    fetchPreviousPage(e) {
        return this.fetch({
            ...e,
            meta: {
                fetchMore: {
                    direction: "backward"
                }
            }
        })
    }
    createResult(e, t) {
        var k, x;
        const {state: r} = e
          , n = super.createResult(e, t)
          , {isFetching: s, isRefetching: i, isError: a, isRefetchError: o} = n
          , l = (x = (k = r.fetchMeta) == null ? void 0 : k.fetchMore) == null ? void 0 : x.direction
          , c = a && l === "forward"
          , f = s && l === "forward"
          , h = a && l === "backward"
          , m = s && l === "backward";
        return {
            ...n,
            fetchNextPage: this.fetchNextPage,
            fetchPreviousPage: this.fetchPreviousPage,
            hasNextPage: $L(t, r.data),
            hasPreviousPage: NL(t, r.data),
            isFetchNextPageError: c,
            isFetchingNextPage: f,
            isFetchPreviousPageError: h,
            isFetchingPreviousPage: m,
            isRefetchError: o && !c && !h,
            isRefetching: i && !f && !m
        }
    }
}
, Hs, Zs, kr, es, as, od, np, D1, ML = (D1 = class extends Go {
    constructor(r, n) {
        super();
        de(this, as);
        de(this, Hs);
        de(this, Zs);
        de(this, kr);
        de(this, es);
        J(this, Hs, r),
        this.setOptions(n),
        this.bindMethods(),
        Pe(this, as, od).call(this)
    }
    bindMethods() {
        this.mutate = this.mutate.bind(this),
        this.reset = this.reset.bind(this)
    }
    setOptions(r) {
        var s;
        const n = this.options;
        this.options = _(this, Hs).defaultMutationOptions(r),
        Bd(this.options, n) || _(this, Hs).getMutationCache().notify({
            type: "observerOptionsUpdated",
            mutation: _(this, kr),
            observer: this
        }),
        n != null && n.mutationKey && this.options.mutationKey && la(n.mutationKey) !== la(this.options.mutationKey) ? this.reset() : ((s = _(this, kr)) == null ? void 0 : s.state.status) === "pending" && _(this, kr).setOptions(this.options)
    }
    onUnsubscribe() {
        var r;
        this.hasListeners() || (r = _(this, kr)) == null || r.removeObserver(this)
    }
    onMutationUpdate(r) {
        Pe(this, as, od).call(this),
        Pe(this, as, np).call(this, r)
    }
    getCurrentResult() {
        return _(this, Zs)
    }
    reset() {
        var r;
        (r = _(this, kr)) == null || r.removeObserver(this),
        J(this, kr, void 0),
        Pe(this, as, od).call(this),
        Pe(this, as, np).call(this)
    }
    mutate(r, n) {
        var s;
        return J(this, es, n),
        (s = _(this, kr)) == null || s.removeObserver(this),
        J(this, kr, _(this, Hs).getMutationCache().build(_(this, Hs), this.options)),
        _(this, kr).addObserver(this),
        _(this, kr).execute(r)
    }
}
,
Hs = new WeakMap,
Zs = new WeakMap,
kr = new WeakMap,
es = new WeakMap,
as = new WeakSet,
od = function() {
    var n;
    const r = ((n = _(this, kr)) == null ? void 0 : n.state) ?? bS();
    J(this, Zs, {
        ...r,
        isPending: r.status === "pending",
        isSuccess: r.status === "success",
        isError: r.status === "error",
        isIdle: r.status === "idle",
        mutate: this.mutate,
        reset: this.reset
    })
}
,
np = function(r) {
    Mt.batch( () => {
        var n, s, i, a, o, l, c, f;
        if (_(this, es) && this.hasListeners()) {
            const h = _(this, Zs).variables
              , m = _(this, Zs).context;
            (r == null ? void 0 : r.type) === "success" ? ((s = (n = _(this, es)).onSuccess) == null || s.call(n, r.data, h, m),
            (a = (i = _(this, es)).onSettled) == null || a.call(i, r.data, null, h, m)) : (r == null ? void 0 : r.type) === "error" && ((l = (o = _(this, es)).onError) == null || l.call(o, r.error, h, m),
            (f = (c = _(this, es)).onSettled) == null || f.call(c, void 0, r.error, h, m))
        }
        this.listeners.forEach(h => {
            h(_(this, Zs))
        }
        )
    }
    )
}
,
D1), kS = g.createContext(void 0), jt = e => {
    const t = g.useContext(kS);
    if (e)
        return e;
    if (!t)
        throw new Error("No QueryClient set, use QueryClientProvider to set one");
    return t
}
, AL = ({client: e, children: t}) => (g.useEffect( () => (e.mount(),
() => {
    e.unmount()
}
), [e]),
d.jsx(kS.Provider, {
    value: e,
    children: t
})), ES = g.createContext(!1), LL = () => g.useContext(ES);
ES.Provider;
function DL() {
    let e = !1;
    return {
        clearReset: () => {
            e = !1
        }
        ,
        reset: () => {
            e = !0
        }
        ,
        isReset: () => e
    }
}
var FL = g.createContext(DL())
  , zL = () => g.useContext(FL);
function _S(e, t) {
    return typeof e == "function" ? e(...t) : !!e
}
function sp() {}
var UL = (e, t) => {
    (e.suspense || e.throwOnError || e.experimental_prefetchInRender) && (t.isReset() || (e.retryOnMount = !1))
}
  , VL = e => {
    g.useEffect( () => {
        e.clearReset()
    }
    , [e])
}
  , BL = ({result: e, errorResetBoundary: t, throwOnError: r, query: n, suspense: s}) => e.isError && !t.isReset() && !e.isFetching && n && (s && e.data === void 0 || _S(r, [e.error, n]))
  , WL = e => {
    const t = e.staleTime;
    e.suspense && (e.staleTime = typeof t == "function" ? (...r) => Math.max(t(...r), 1e3) : Math.max(t ?? 1e3, 1e3),
    typeof e.gcTime == "number" && (e.gcTime = Math.max(e.gcTime, 1e3)))
}
  , qL = (e, t) => e.isLoading && e.isFetching && !t
  , HL = (e, t) => (e == null ? void 0 : e.suspense) && t.isPending
  , B0 = (e, t, r) => t.fetchOptimistic(e).catch( () => {
    r.clearReset()
}
);
function TS(e, t, r) {
    var h, m, y, k, x;
    const n = jt(r)
      , s = LL()
      , i = zL()
      , a = n.defaultQueryOptions(e);
    (m = (h = n.getDefaultOptions().queries) == null ? void 0 : h._experimental_beforeQuery) == null || m.call(h, a),
    a._optimisticResults = s ? "isRestoring" : "optimistic",
    WL(a),
    UL(a, i),
    VL(i);
    const o = !n.getQueryCache().get(a.queryHash)
      , [l] = g.useState( () => new t(n,a))
      , c = l.getOptimisticResult(a)
      , f = !s && e.subscribed !== !1;
    if (g.useSyncExternalStore(g.useCallback(w => {
        const v = f ? l.subscribe(Mt.batchCalls(w)) : sp;
        return l.updateResult(),
        v
    }
    , [l, f]), () => l.getCurrentResult(), () => l.getCurrentResult()),
    g.useEffect( () => {
        l.setOptions(a, {
            listeners: !1
        })
    }
    , [a, l]),
    HL(a, c))
        throw B0(a, l, i);
    if (BL({
        result: c,
        errorResetBoundary: i,
        throwOnError: a.throwOnError,
        query: n.getQueryCache().get(a.queryHash),
        suspense: a.suspense
    }))
        throw c.error;
    if ((k = (y = n.getDefaultOptions().queries) == null ? void 0 : y._experimental_afterQuery) == null || k.call(y, a, c),
    a.experimental_prefetchInRender && !oa && qL(c, s)) {
        const w = o ? B0(a, l, i) : (x = n.getQueryCache().get(a.queryHash)) == null ? void 0 : x.promise;
        w == null || w.catch(sp).finally( () => {
            l.updateResult()
        }
        )
    }
    return a.notifyOnChangeProps ? c : l.trackResult(c)
}
function _n(e, t) {
    return TS(e, wS, t)
}
function Ft(e, t) {
    const r = jt(t)
      , [n] = g.useState( () => new ML(r,e));
    g.useEffect( () => {
        n.setOptions(e)
    }
    , [n, e]);
    const s = g.useSyncExternalStore(g.useCallback(a => n.subscribe(Mt.batchCalls(a)), [n]), () => n.getCurrentResult(), () => n.getCurrentResult())
      , i = g.useCallback( (a, o) => {
        n.mutate(a, o).catch(sp)
    }
    , [n]);
    if (s.error && _S(n.options.throwOnError, [s.error]))
        throw s.error;
    return {
        ...s,
        mutate: i,
        mutateAsync: s.mutate
    }
}
function rg(e, t) {
    return TS(e, OL, t)
}
const ge = ya({
    editingAvatarId: void 0,
    placedBuildingId: void 0,
    editingBuildingId: void 0,
    isFetchingItems: !1,
    isFetchingLimits: !1,
    isPurchasingSpace: !1,
    isCreatingItem: !1,
    itemsQuery: void 0,
    limitsQuery: void 0,
    fetchItems: Cn(async () => {
        ge.isFetchingItems = !0;
        const e = await C6();
        return ge.itemsQuery = e,
        ge.isFetchingItems = !1,
        e
    }
    ),
    fetchLimits: Cn(async () => {
        ge.isFetchingLimits = !0;
        const e = await p6();
        return ge.limitsQuery = e,
        ge.isFetchingLimits = !1,
        e
    }
    ),
    emitEquipAvatar: Cn(async e => er(async () => {
        const t = await Da(e);
        return t.ok && (await Ve.emit("avatar:equipped", {
            blobId: t.value.blob.id,
            blobType: t.value.blob.blobType,
            isSealed: !!t.value.blob.sealedAt,
            modelStoragePath: t.value.blob.modelStoragePath,
            modelUrl: t.value.blob.modelUrl,
            loadRotation: t.value.blob.loadRotation
        }),
        Se.currentAvatarId = t.value.blob.id),
        t
    }
    )),
    emitEditAvatar: Cn(async e => er(async () => {
        const t = await Da(e);
        return t.ok && (await Ve.emit("avatar:editing", {
            blobId: t.value.blob.id,
            blobType: t.value.blob.blobType,
            isSealed: !!t.value.blob.sealedAt,
            modelStoragePath: t.value.blob.modelStoragePath,
            modelUrl: t.value.blob.modelUrl,
            loadRotation: t.value.blob.loadRotation
        }),
        ge.editingAvatarId = t.value.blob.id),
        t
    }
    )),
    emitUseItem: Cn(async e => er(async () => {
        const t = W0(e)
          , r = await Da(e);
        return r.ok ? await Ve.emit("inventory_item:used", {
            blobId: r.value.blob.id,
            blobType: r.value.blob.blobType,
            isSealed: !!r.value.blob.sealedAt,
            modelStoragePath: r.value.blob.modelStoragePath,
            modelUrl: r.value.blob.modelUrl,
            loadRotation: r.value.blob.loadRotation
        }) : t(),
        r
    }
    )),
    emitPlaceBuilding: Cn(async e => er(async () => {
        const t = await Da(e);
        return t.ok && (await Ve.emit("building:placed", {
            blobId: t.value.blob.id,
            blobType: t.value.blob.blobType,
            isSealed: !!t.value.blob.sealedAt,
            modelStoragePath: t.value.blob.modelStoragePath,
            modelUrl: t.value.blob.modelUrl,
            loadRotation: t.value.blob.loadRotation
        }),
        ge.placedBuildingId = t.value.blob.id),
        t
    }
    )),
    emitEditBuilding: Cn(async e => er(async () => {
        const t = await Da(e);
        return t.ok && (await Ve.emit("building:editing", {
            blobId: t.value.blob.id,
            blobType: t.value.blob.blobType,
            isSealed: !!t.value.blob.sealedAt,
            modelStoragePath: t.value.blob.modelStoragePath,
            modelUrl: t.value.blob.modelUrl,
            loadRotation: t.value.blob.loadRotation
        }),
        ge.editingBuildingId = t.value.blob.id),
        t
    }
    )),
    createInventoryItem: Cn(async e => er(async () => {
        ge.isCreatingItem = !0;
        const t = CS("decrease")
          , r = await gw(e, () => Q5({
            blobId: e
        }));
        return r.ok || t(),
        await ge.fetchItems(),
        ge.isCreatingItem = !1,
        r
    }
    )),
    deleteInventoryItem: Cn(async e => er(async () => {
        const t = W0(e)
          , r = await n6(e);
        return r.ok || t(),
        r
    }
    )),
    purchaseInventorySpace: Cn(async () => {
        ge.isPurchasingSpace = !0;
        const e = await O6();
        return e.ok && (await ge.fetchLimits(),
        await Zy()),
        ge.isPurchasingSpace = !1,
        e
    }
    )
});
function gi() {
    return Ay(ge)
}
function W0(e) {
    var a;
    if (!((a = ge.itemsQuery) != null && a.ok))
        return () => {}
        ;
    const {value: t} = ge.itemsQuery;
    let r = -1, n;
    const s = new Array;
    for (let o = 0; o < t.length; o++) {
        const l = t[o];
        l.id !== e ? s.push(l) : (r = o,
        n = l)
    }
    if (r === -1)
        return () => {}
        ;
    ge.itemsQuery = ra(s);
    const i = CS("increase");
    return () => {
        const o = [...t];
        o.splice(r, 0, n),
        ge.itemsQuery = ra(o),
        i()
    }
}
function CS(e) {
    var n;
    if (!((n = ge.limitsQuery) != null && n.ok))
        return () => {}
        ;
    const {value: t} = ge.limitsQuery
      , r = e === "increase" ? t.remaining + 1 : t.remaining - 1;
    return ge.limitsQuery = ra({
        ...t,
        remaining: r
    }),
    () => {
        const s = e === "increase" ? t.remaining - 1 : t.remaining + 1;
        ge.limitsQuery = ra({
            ...t,
            remaining: s
        })
    }
}
function ZL() {
    return Ft({
        async mutationFn({id: e, reportNotes: t}) {
            return er( () => q5(e, {
                reportNotes: t
            }))
        }
    })
}
function KL(e) {
    return Ft({
        ...e,
        mutationFn: async t => {
            const r = await Z5(t);
            if (!r.ok)
                throw new Error(r.error.message);
            return r.value
        }
    })
}
function QL() {
    const e = g.useRef();
    async function t(n) {
        var s;
        if ((s = ge.itemsQuery) != null && s.ok)
            return e.current = ge.itemsQuery.value,
            ge.itemsQuery = ra(ge.itemsQuery.value.filter(i => i.id !== n)),
            e.current
    }
    async function r() {
        ge.itemsQuery = e.current ? ra(e.current) : void 0,
        e.current = void 0
    }
    return {
        removeItem: t,
        rollback: r
    }
}
function ng() {
    const e = jt();
    async function t(r) {
        if (typeof r.productsRemaining == "string") {
            const n = ["me", "limits", "products"]
              , s = e.getQueryData(n);
            s && (await e.cancelQueries({
                queryKey: n
            }),
            s.remaining += r.productsRemaining === "increment" ? 1 : -1,
            e.setQueryData(n, s))
        }
        if (typeof r.inventoryRemaining == "string") {
            const n = ["me", "limits", "inventory"]
              , s = e.getQueryData(n);
            s && (await e.cancelQueries({
                queryKey: n
            }),
            s.remaining += r.inventoryRemaining === "increment" ? 1 : -1,
            e.setQueryData(n, s))
        }
    }
    return {
        update: t
    }
}
function GL() {
    const e = QL()
      , t = ng();
    return Ft({
        async mutationFn(r) {
            await Promise.all([e.removeItem(r.inventoryItemId), t.update({
                inventoryRemaining: "increment",
                productsRemaining: "decrement"
            })]);
            const n = await er( () => Y5(r));
            if (!n.ok)
                console.error("Error creating product", n.error),
                await e.rollback();
            else if (r.salesChannel === "in_person") {
                const s = await o6(n.value.blob.id);
                if (!s.ok)
                    return console.error("Error finding blob for in-person product", s.error),
                    s;
                await Ve.emit("display_blob_for_sale", {
                    blobId: s.value.id,
                    blobType: s.value.blobType,
                    isSealed: !!s.value.sealedAt,
                    loadRotation: s.value.loadRotation,
                    modelStoragePath: s.value.modelStoragePath,
                    modelUrl: s.value.modelUrl,
                    inPersonProduct: s.value.inPersonProduct
                })
            }
            return n
        }
    })
}
function YL(e) {
    const t = jt();
    return Ft({
        ...e,
        mutationFn(r) {
            return er( () => t6(r.id))
        },
        async onMutate({id: r}) {
            const n = ["me", "friends"]
              , s = t.getQueryData(n);
            if (s)
                return await t.cancelQueries({
                    queryKey: n
                }),
                t.setQueryData(n, s.filter(i => (i == null ? void 0 : i.friendshipId) !== r)),
                {
                    friends: s
                }
        },
        onError(r, n, s) {
            s != null && s.friends && t.setQueryData(["me", "friends"], s.friends)
        }
    })
}
function JL() {
    const e = jt()
      , t = ng();
    return Ft({
        async mutationFn(r) {
            return i6(r.id)
        },
        onMutate(r) {
            t.update({
                inventoryRemaining: "decrement",
                productsRemaining: "increment"
            })
        },
        onSettled() {
            e.invalidateQueries({
                queryKey: ["me"]
            })
        }
    })
}
function XL() {
    return Ft({
        mutationFn: async e => {
            const t = await er( () => b6(e.userId));
            if (!t.ok)
                throw new Error(t.error.message);
            return await Ve.emit("friend:goto", {
                room: t.value,
                friend: e
            }),
            t.value
        }
    })
}
function eD() {
    return Ft({
        async mutationFn(e) {
            const t = await X5(e);
            if (!t.ok)
                throw new Error("Login failed");
            return Ky(t.value),
            Zf()
        }
    })
}
var PS = {
    exports: {}
}
  , zr = {}
  , $S = {
    exports: {}
}
  , NS = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(e) {
    function t(B, he) {
        var me = B.length;
        B.push(he);
        e: for (; 0 < me; ) {
            var De = me - 1 >>> 1
              , Fe = B[De];
            if (0 < s(Fe, he))
                B[De] = he,
                B[me] = Fe,
                me = De;
            else
                break e
        }
    }
    function r(B) {
        return B.length === 0 ? null : B[0]
    }
    function n(B) {
        if (B.length === 0)
            return null;
        var he = B[0]
          , me = B.pop();
        if (me !== he) {
            B[0] = me;
            e: for (var De = 0, Fe = B.length, Ir = Fe >>> 1; De < Ir; ) {
                var Qt = 2 * (De + 1) - 1
                  , zt = B[Qt]
                  , It = Qt + 1
                  , or = B[It];
                if (0 > s(zt, me))
                    It < Fe && 0 > s(or, zt) ? (B[De] = or,
                    B[It] = me,
                    De = It) : (B[De] = zt,
                    B[Qt] = me,
                    De = Qt);
                else if (It < Fe && 0 > s(or, me))
                    B[De] = or,
                    B[It] = me,
                    De = It;
                else
                    break e
            }
        }
        return he
    }
    function s(B, he) {
        var me = B.sortIndex - he.sortIndex;
        return me !== 0 ? me : B.id - he.id
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
        var i = performance;
        e.unstable_now = function() {
            return i.now()
        }
    } else {
        var a = Date
          , o = a.now();
        e.unstable_now = function() {
            return a.now() - o
        }
    }
    var l = []
      , c = []
      , f = 1
      , h = null
      , m = 3
      , y = !1
      , k = !1
      , x = !1
      , w = typeof setTimeout == "function" ? setTimeout : null
      , v = typeof clearTimeout == "function" ? clearTimeout : null
      , p = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function S(B) {
        for (var he = r(c); he !== null; ) {
            if (he.callback === null)
                n(c);
            else if (he.startTime <= B)
                n(c),
                he.sortIndex = he.expirationTime,
                t(l, he);
            else
                break;
            he = r(c)
        }
    }
    function P(B) {
        if (x = !1,
        S(B),
        !k)
            if (r(l) !== null)
                k = !0,
                Ke(j);
            else {
                var he = r(c);
                he !== null && xt(P, he.startTime - B)
            }
    }
    function j(B, he) {
        k = !1,
        x && (x = !1,
        v(b),
        b = -1),
        y = !0;
        var me = m;
        try {
            for (S(he),
            h = r(l); h !== null && (!(h.expirationTime > he) || B && !D()); ) {
                var De = h.callback;
                if (typeof De == "function") {
                    h.callback = null,
                    m = h.priorityLevel;
                    var Fe = De(h.expirationTime <= he);
                    he = e.unstable_now(),
                    typeof Fe == "function" ? h.callback = Fe : h === r(l) && n(l),
                    S(he)
                } else
                    n(l);
                h = r(l)
            }
            if (h !== null)
                var Ir = !0;
            else {
                var Qt = r(c);
                Qt !== null && xt(P, Qt.startTime - he),
                Ir = !1
            }
            return Ir
        } finally {
            h = null,
            m = me,
            y = !1
        }
    }
    var L = !1
      , E = null
      , b = -1
      , O = 5
      , M = -1;
    function D() {
        return !(e.unstable_now() - M < O)
    }
    function z() {
        if (E !== null) {
            var B = e.unstable_now();
            M = B;
            var he = !0;
            try {
                he = E(!0, B)
            } finally {
                he ? $() : (L = !1,
                E = null)
            }
        } else
            L = !1
    }
    var $;
    if (typeof p == "function")
        $ = function() {
            p(z)
        }
        ;
    else if (typeof MessageChannel < "u") {
        var Y = new MessageChannel
          , ce = Y.port2;
        Y.port1.onmessage = z,
        $ = function() {
            ce.postMessage(null)
        }
    } else
        $ = function() {
            w(z, 0)
        }
        ;
    function Ke(B) {
        E = B,
        L || (L = !0,
        $())
    }
    function xt(B, he) {
        b = w(function() {
            B(e.unstable_now())
        }, he)
    }
    e.unstable_IdlePriority = 5,
    e.unstable_ImmediatePriority = 1,
    e.unstable_LowPriority = 4,
    e.unstable_NormalPriority = 3,
    e.unstable_Profiling = null,
    e.unstable_UserBlockingPriority = 2,
    e.unstable_cancelCallback = function(B) {
        B.callback = null
    }
    ,
    e.unstable_continueExecution = function() {
        k || y || (k = !0,
        Ke(j))
    }
    ,
    e.unstable_forceFrameRate = function(B) {
        0 > B || 125 < B ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : O = 0 < B ? Math.floor(1e3 / B) : 5
    }
    ,
    e.unstable_getCurrentPriorityLevel = function() {
        return m
    }
    ,
    e.unstable_getFirstCallbackNode = function() {
        return r(l)
    }
    ,
    e.unstable_next = function(B) {
        switch (m) {
        case 1:
        case 2:
        case 3:
            var he = 3;
            break;
        default:
            he = m
        }
        var me = m;
        m = he;
        try {
            return B()
        } finally {
            m = me
        }
    }
    ,
    e.unstable_pauseExecution = function() {}
    ,
    e.unstable_requestPaint = function() {}
    ,
    e.unstable_runWithPriority = function(B, he) {
        switch (B) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
            break;
        default:
            B = 3
        }
        var me = m;
        m = B;
        try {
            return he()
        } finally {
            m = me
        }
    }
    ,
    e.unstable_scheduleCallback = function(B, he, me) {
        var De = e.unstable_now();
        switch (typeof me == "object" && me !== null ? (me = me.delay,
        me = typeof me == "number" && 0 < me ? De + me : De) : me = De,
        B) {
        case 1:
            var Fe = -1;
            break;
        case 2:
            Fe = 250;
            break;
        case 5:
            Fe = 1073741823;
            break;
        case 4:
            Fe = 1e4;
            break;
        default:
            Fe = 5e3
        }
        return Fe = me + Fe,
        B = {
            id: f++,
            callback: he,
            priorityLevel: B,
            startTime: me,
            expirationTime: Fe,
            sortIndex: -1
        },
        me > De ? (B.sortIndex = me,
        t(c, B),
        r(l) === null && B === r(c) && (x ? (v(b),
        b = -1) : x = !0,
        xt(P, me - De))) : (B.sortIndex = Fe,
        t(l, B),
        k || y || (k = !0,
        Ke(j))),
        B
    }
    ,
    e.unstable_shouldYield = D,
    e.unstable_wrapCallback = function(B) {
        var he = m;
        return function() {
            var me = m;
            m = he;
            try {
                return B.apply(this, arguments)
            } finally {
                m = me
            }
        }
    }
}
)(NS);
$S.exports = NS;
var tD = $S.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var rD = g
  , Fr = tD;
function V(e) {
    for (var t = "https://reactjs.org/docs/error-decoder.html?invariant=" + e, r = 1; r < arguments.length; r++)
        t += "&args[]=" + encodeURIComponent(arguments[r]);
    return "Minified React error #" + e + "; visit " + t + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
}
var jS = new Set
  , bu = {};
function va(e, t) {
    jo(e, t),
    jo(e + "Capture", t)
}
function jo(e, t) {
    for (bu[e] = t,
    e = 0; e < t.length; e++)
        jS.add(t[e])
}
var us = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u")
  , ip = Object.prototype.hasOwnProperty
  , nD = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/
  , q0 = {}
  , H0 = {};
function sD(e) {
    return ip.call(H0, e) ? !0 : ip.call(q0, e) ? !1 : nD.test(e) ? H0[e] = !0 : (q0[e] = !0,
    !1)
}
function iD(e, t, r, n) {
    if (r !== null && r.type === 0)
        return !1;
    switch (typeof t) {
    case "function":
    case "symbol":
        return !0;
    case "boolean":
        return n ? !1 : r !== null ? !r.acceptsBooleans : (e = e.toLowerCase().slice(0, 5),
        e !== "data-" && e !== "aria-");
    default:
        return !1
    }
}
function aD(e, t, r, n) {
    if (t === null || typeof t > "u" || iD(e, t, r, n))
        return !0;
    if (n)
        return !1;
    if (r !== null)
        switch (r.type) {
        case 3:
            return !t;
        case 4:
            return t === !1;
        case 5:
            return isNaN(t);
        case 6:
            return isNaN(t) || 1 > t
        }
    return !1
}
function xr(e, t, r, n, s, i, a) {
    this.acceptsBooleans = t === 2 || t === 3 || t === 4,
    this.attributeName = n,
    this.attributeNamespace = s,
    this.mustUseProperty = r,
    this.propertyName = e,
    this.type = t,
    this.sanitizeURL = i,
    this.removeEmptyString = a
}
var Zt = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(e) {
    Zt[e] = new xr(e,0,!1,e,null,!1,!1)
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(e) {
    var t = e[0];
    Zt[t] = new xr(t,1,!1,e[1],null,!1,!1)
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(e) {
    Zt[e] = new xr(e,2,!1,e.toLowerCase(),null,!1,!1)
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(e) {
    Zt[e] = new xr(e,2,!1,e,null,!1,!1)
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(e) {
    Zt[e] = new xr(e,3,!1,e.toLowerCase(),null,!1,!1)
});
["checked", "multiple", "muted", "selected"].forEach(function(e) {
    Zt[e] = new xr(e,3,!0,e,null,!1,!1)
});
["capture", "download"].forEach(function(e) {
    Zt[e] = new xr(e,4,!1,e,null,!1,!1)
});
["cols", "rows", "size", "span"].forEach(function(e) {
    Zt[e] = new xr(e,6,!1,e,null,!1,!1)
});
["rowSpan", "start"].forEach(function(e) {
    Zt[e] = new xr(e,5,!1,e.toLowerCase(),null,!1,!1)
});
var sg = /[\-:]([a-z])/g;
function ig(e) {
    return e[1].toUpperCase()
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(e) {
    var t = e.replace(sg, ig);
    Zt[t] = new xr(t,1,!1,e,null,!1,!1)
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(e) {
    var t = e.replace(sg, ig);
    Zt[t] = new xr(t,1,!1,e,"http://www.w3.org/1999/xlink",!1,!1)
});
["xml:base", "xml:lang", "xml:space"].forEach(function(e) {
    var t = e.replace(sg, ig);
    Zt[t] = new xr(t,1,!1,e,"http://www.w3.org/XML/1998/namespace",!1,!1)
});
["tabIndex", "crossOrigin"].forEach(function(e) {
    Zt[e] = new xr(e,1,!1,e.toLowerCase(),null,!1,!1)
});
Zt.xlinkHref = new xr("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1);
["src", "href", "action", "formAction"].forEach(function(e) {
    Zt[e] = new xr(e,1,!1,e.toLowerCase(),null,!0,!0)
});
function ag(e, t, r, n) {
    var s = Zt.hasOwnProperty(t) ? Zt[t] : null;
    (s !== null ? s.type !== 0 : n || !(2 < t.length) || t[0] !== "o" && t[0] !== "O" || t[1] !== "n" && t[1] !== "N") && (aD(t, r, s, n) && (r = null),
    n || s === null ? sD(t) && (r === null ? e.removeAttribute(t) : e.setAttribute(t, "" + r)) : s.mustUseProperty ? e[s.propertyName] = r === null ? s.type === 3 ? !1 : "" : r : (t = s.attributeName,
    n = s.attributeNamespace,
    r === null ? e.removeAttribute(t) : (s = s.type,
    r = s === 3 || s === 4 && r === !0 ? "" : "" + r,
    n ? e.setAttributeNS(n, t, r) : e.setAttribute(t, r))))
}
var vs = rD.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
  , Nc = Symbol.for("react.element")
  , Ba = Symbol.for("react.portal")
  , Wa = Symbol.for("react.fragment")
  , og = Symbol.for("react.strict_mode")
  , ap = Symbol.for("react.profiler")
  , IS = Symbol.for("react.provider")
  , RS = Symbol.for("react.context")
  , lg = Symbol.for("react.forward_ref")
  , op = Symbol.for("react.suspense")
  , lp = Symbol.for("react.suspense_list")
  , ug = Symbol.for("react.memo")
  , js = Symbol.for("react.lazy")
  , OS = Symbol.for("react.offscreen")
  , Z0 = Symbol.iterator;
function ml(e) {
    return e === null || typeof e != "object" ? null : (e = Z0 && e[Z0] || e["@@iterator"],
    typeof e == "function" ? e : null)
}
var dt = Object.assign, Lh;
function Rl(e) {
    if (Lh === void 0)
        try {
            throw Error()
        } catch (r) {
            var t = r.stack.trim().match(/\n( *(at )?)/);
            Lh = t && t[1] || ""
        }
    return `
` + Lh + e
}
var Dh = !1;
function Fh(e, t) {
    if (!e || Dh)
        return "";
    Dh = !0;
    var r = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
        if (t)
            if (t = function() {
                throw Error()
            }
            ,
            Object.defineProperty(t.prototype, "props", {
                set: function() {
                    throw Error()
                }
            }),
            typeof Reflect == "object" && Reflect.construct) {
                try {
                    Reflect.construct(t, [])
                } catch (c) {
                    var n = c
                }
                Reflect.construct(e, [], t)
            } else {
                try {
                    t.call()
                } catch (c) {
                    n = c
                }
                e.call(t.prototype)
            }
        else {
            try {
                throw Error()
            } catch (c) {
                n = c
            }
            e()
        }
    } catch (c) {
        if (c && n && typeof c.stack == "string") {
            for (var s = c.stack.split(`
`), i = n.stack.split(`
`), a = s.length - 1, o = i.length - 1; 1 <= a && 0 <= o && s[a] !== i[o]; )
                o--;
            for (; 1 <= a && 0 <= o; a--,
            o--)
                if (s[a] !== i[o]) {
                    if (a !== 1 || o !== 1)
                        do
                            if (a--,
                            o--,
                            0 > o || s[a] !== i[o]) {
                                var l = `
` + s[a].replace(" at new ", " at ");
                                return e.displayName && l.includes("<anonymous>") && (l = l.replace("<anonymous>", e.displayName)),
                                l
                            }
                        while (1 <= a && 0 <= o);
                    break
                }
        }
    } finally {
        Dh = !1,
        Error.prepareStackTrace = r
    }
    return (e = e ? e.displayName || e.name : "") ? Rl(e) : ""
}
function oD(e) {
    switch (e.tag) {
    case 5:
        return Rl(e.type);
    case 16:
        return Rl("Lazy");
    case 13:
        return Rl("Suspense");
    case 19:
        return Rl("SuspenseList");
    case 0:
    case 2:
    case 15:
        return e = Fh(e.type, !1),
        e;
    case 11:
        return e = Fh(e.type.render, !1),
        e;
    case 1:
        return e = Fh(e.type, !0),
        e;
    default:
        return ""
    }
}
function up(e) {
    if (e == null)
        return null;
    if (typeof e == "function")
        return e.displayName || e.name || null;
    if (typeof e == "string")
        return e;
    switch (e) {
    case Wa:
        return "Fragment";
    case Ba:
        return "Portal";
    case ap:
        return "Profiler";
    case og:
        return "StrictMode";
    case op:
        return "Suspense";
    case lp:
        return "SuspenseList"
    }
    if (typeof e == "object")
        switch (e.$$typeof) {
        case RS:
            return (e.displayName || "Context") + ".Consumer";
        case IS:
            return (e._context.displayName || "Context") + ".Provider";
        case lg:
            var t = e.render;
            return e = e.displayName,
            e || (e = t.displayName || t.name || "",
            e = e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef"),
            e;
        case ug:
            return t = e.displayName || null,
            t !== null ? t : up(e.type) || "Memo";
        case js:
            t = e._payload,
            e = e._init;
            try {
                return up(e(t))
            } catch {}
        }
    return null
}
function lD(e) {
    var t = e.type;
    switch (e.tag) {
    case 24:
        return "Cache";
    case 9:
        return (t.displayName || "Context") + ".Consumer";
    case 10:
        return (t._context.displayName || "Context") + ".Provider";
    case 18:
        return "DehydratedFragment";
    case 11:
        return e = t.render,
        e = e.displayName || e.name || "",
        t.displayName || (e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef");
    case 7:
        return "Fragment";
    case 5:
        return t;
    case 4:
        return "Portal";
    case 3:
        return "Root";
    case 6:
        return "Text";
    case 16:
        return up(t);
    case 8:
        return t === og ? "StrictMode" : "Mode";
    case 22:
        return "Offscreen";
    case 12:
        return "Profiler";
    case 21:
        return "Scope";
    case 13:
        return "Suspense";
    case 19:
        return "SuspenseList";
    case 25:
        return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
        if (typeof t == "function")
            return t.displayName || t.name || null;
        if (typeof t == "string")
            return t
    }
    return null
}
function hi(e) {
    switch (typeof e) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
        return e;
    case "object":
        return e;
    default:
        return ""
    }
}
function MS(e) {
    var t = e.type;
    return (e = e.nodeName) && e.toLowerCase() === "input" && (t === "checkbox" || t === "radio")
}
function uD(e) {
    var t = MS(e) ? "checked" : "value"
      , r = Object.getOwnPropertyDescriptor(e.constructor.prototype, t)
      , n = "" + e[t];
    if (!e.hasOwnProperty(t) && typeof r < "u" && typeof r.get == "function" && typeof r.set == "function") {
        var s = r.get
          , i = r.set;
        return Object.defineProperty(e, t, {
            configurable: !0,
            get: function() {
                return s.call(this)
            },
            set: function(a) {
                n = "" + a,
                i.call(this, a)
            }
        }),
        Object.defineProperty(e, t, {
            enumerable: r.enumerable
        }),
        {
            getValue: function() {
                return n
            },
            setValue: function(a) {
                n = "" + a
            },
            stopTracking: function() {
                e._valueTracker = null,
                delete e[t]
            }
        }
    }
}
function jc(e) {
    e._valueTracker || (e._valueTracker = uD(e))
}
function AS(e) {
    if (!e)
        return !1;
    var t = e._valueTracker;
    if (!t)
        return !0;
    var r = t.getValue()
      , n = "";
    return e && (n = MS(e) ? e.checked ? "true" : "false" : e.value),
    e = n,
    e !== r ? (t.setValue(e),
    !0) : !1
}
function Hd(e) {
    if (e = e || (typeof document < "u" ? document : void 0),
    typeof e > "u")
        return null;
    try {
        return e.activeElement || e.body
    } catch {
        return e.body
    }
}
function cp(e, t) {
    var r = t.checked;
    return dt({}, t, {
        defaultChecked: void 0,
        defaultValue: void 0,
        value: void 0,
        checked: r ?? e._wrapperState.initialChecked
    })
}
function K0(e, t) {
    var r = t.defaultValue == null ? "" : t.defaultValue
      , n = t.checked != null ? t.checked : t.defaultChecked;
    r = hi(t.value != null ? t.value : r),
    e._wrapperState = {
        initialChecked: n,
        initialValue: r,
        controlled: t.type === "checkbox" || t.type === "radio" ? t.checked != null : t.value != null
    }
}
function LS(e, t) {
    t = t.checked,
    t != null && ag(e, "checked", t, !1)
}
function dp(e, t) {
    LS(e, t);
    var r = hi(t.value)
      , n = t.type;
    if (r != null)
        n === "number" ? (r === 0 && e.value === "" || e.value != r) && (e.value = "" + r) : e.value !== "" + r && (e.value = "" + r);
    else if (n === "submit" || n === "reset") {
        e.removeAttribute("value");
        return
    }
    t.hasOwnProperty("value") ? fp(e, t.type, r) : t.hasOwnProperty("defaultValue") && fp(e, t.type, hi(t.defaultValue)),
    t.checked == null && t.defaultChecked != null && (e.defaultChecked = !!t.defaultChecked)
}
function Q0(e, t, r) {
    if (t.hasOwnProperty("value") || t.hasOwnProperty("defaultValue")) {
        var n = t.type;
        if (!(n !== "submit" && n !== "reset" || t.value !== void 0 && t.value !== null))
            return;
        t = "" + e._wrapperState.initialValue,
        r || t === e.value || (e.value = t),
        e.defaultValue = t
    }
    r = e.name,
    r !== "" && (e.name = ""),
    e.defaultChecked = !!e._wrapperState.initialChecked,
    r !== "" && (e.name = r)
}
function fp(e, t, r) {
    (t !== "number" || Hd(e.ownerDocument) !== e) && (r == null ? e.defaultValue = "" + e._wrapperState.initialValue : e.defaultValue !== "" + r && (e.defaultValue = "" + r))
}
var Ol = Array.isArray;
function io(e, t, r, n) {
    if (e = e.options,
    t) {
        t = {};
        for (var s = 0; s < r.length; s++)
            t["$" + r[s]] = !0;
        for (r = 0; r < e.length; r++)
            s = t.hasOwnProperty("$" + e[r].value),
            e[r].selected !== s && (e[r].selected = s),
            s && n && (e[r].defaultSelected = !0)
    } else {
        for (r = "" + hi(r),
        t = null,
        s = 0; s < e.length; s++) {
            if (e[s].value === r) {
                e[s].selected = !0,
                n && (e[s].defaultSelected = !0);
                return
            }
            t !== null || e[s].disabled || (t = e[s])
        }
        t !== null && (t.selected = !0)
    }
}
function hp(e, t) {
    if (t.dangerouslySetInnerHTML != null)
        throw Error(V(91));
    return dt({}, t, {
        value: void 0,
        defaultValue: void 0,
        children: "" + e._wrapperState.initialValue
    })
}
function G0(e, t) {
    var r = t.value;
    if (r == null) {
        if (r = t.children,
        t = t.defaultValue,
        r != null) {
            if (t != null)
                throw Error(V(92));
            if (Ol(r)) {
                if (1 < r.length)
                    throw Error(V(93));
                r = r[0]
            }
            t = r
        }
        t == null && (t = ""),
        r = t
    }
    e._wrapperState = {
        initialValue: hi(r)
    }
}
function DS(e, t) {
    var r = hi(t.value)
      , n = hi(t.defaultValue);
    r != null && (r = "" + r,
    r !== e.value && (e.value = r),
    t.defaultValue == null && e.defaultValue !== r && (e.defaultValue = r)),
    n != null && (e.defaultValue = "" + n)
}
function Y0(e) {
    var t = e.textContent;
    t === e._wrapperState.initialValue && t !== "" && t !== null && (e.value = t)
}
function FS(e) {
    switch (e) {
    case "svg":
        return "http://www.w3.org/2000/svg";
    case "math":
        return "http://www.w3.org/1998/Math/MathML";
    default:
        return "http://www.w3.org/1999/xhtml"
    }
}
function mp(e, t) {
    return e == null || e === "http://www.w3.org/1999/xhtml" ? FS(t) : e === "http://www.w3.org/2000/svg" && t === "foreignObject" ? "http://www.w3.org/1999/xhtml" : e
}
var Ic, zS = function(e) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(t, r, n, s) {
        MSApp.execUnsafeLocalFunction(function() {
            return e(t, r, n, s)
        })
    }
    : e
}(function(e, t) {
    if (e.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML"in e)
        e.innerHTML = t;
    else {
        for (Ic = Ic || document.createElement("div"),
        Ic.innerHTML = "<svg>" + t.valueOf().toString() + "</svg>",
        t = Ic.firstChild; e.firstChild; )
            e.removeChild(e.firstChild);
        for (; t.firstChild; )
            e.appendChild(t.firstChild)
    }
});
function xu(e, t) {
    if (t) {
        var r = e.firstChild;
        if (r && r === e.lastChild && r.nodeType === 3) {
            r.nodeValue = t;
            return
        }
    }
    e.textContent = t
}
var Bl = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
}
  , cD = ["Webkit", "ms", "Moz", "O"];
Object.keys(Bl).forEach(function(e) {
    cD.forEach(function(t) {
        t = t + e.charAt(0).toUpperCase() + e.substring(1),
        Bl[t] = Bl[e]
    })
});
function US(e, t, r) {
    return t == null || typeof t == "boolean" || t === "" ? "" : r || typeof t != "number" || t === 0 || Bl.hasOwnProperty(e) && Bl[e] ? ("" + t).trim() : t + "px"
}
function VS(e, t) {
    e = e.style;
    for (var r in t)
        if (t.hasOwnProperty(r)) {
            var n = r.indexOf("--") === 0
              , s = US(r, t[r], n);
            r === "float" && (r = "cssFloat"),
            n ? e.setProperty(r, s) : e[r] = s
        }
}
var dD = dt({
    menuitem: !0
}, {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0
});
function pp(e, t) {
    if (t) {
        if (dD[e] && (t.children != null || t.dangerouslySetInnerHTML != null))
            throw Error(V(137, e));
        if (t.dangerouslySetInnerHTML != null) {
            if (t.children != null)
                throw Error(V(60));
            if (typeof t.dangerouslySetInnerHTML != "object" || !("__html"in t.dangerouslySetInnerHTML))
                throw Error(V(61))
        }
        if (t.style != null && typeof t.style != "object")
            throw Error(V(62))
    }
}
function yp(e, t) {
    if (e.indexOf("-") === -1)
        return typeof t.is == "string";
    switch (e) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
        return !1;
    default:
        return !0
    }
}
var gp = null;
function cg(e) {
    return e = e.target || e.srcElement || window,
    e.correspondingUseElement && (e = e.correspondingUseElement),
    e.nodeType === 3 ? e.parentNode : e
}
var vp = null
  , ao = null
  , oo = null;
function J0(e) {
    if (e = tc(e)) {
        if (typeof vp != "function")
            throw Error(V(280));
        var t = e.stateNode;
        t && (t = Xf(t),
        vp(e.stateNode, e.type, t))
    }
}
function BS(e) {
    ao ? oo ? oo.push(e) : oo = [e] : ao = e
}
function WS() {
    if (ao) {
        var e = ao
          , t = oo;
        if (oo = ao = null,
        J0(e),
        t)
            for (e = 0; e < t.length; e++)
                J0(t[e])
    }
}
function qS(e, t) {
    return e(t)
}
function HS() {}
var zh = !1;
function ZS(e, t, r) {
    if (zh)
        return e(t, r);
    zh = !0;
    try {
        return qS(e, t, r)
    } finally {
        zh = !1,
        (ao !== null || oo !== null) && (HS(),
        WS())
    }
}
function wu(e, t) {
    var r = e.stateNode;
    if (r === null)
        return null;
    var n = Xf(r);
    if (n === null)
        return null;
    r = n[t];
    e: switch (t) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
        (n = !n.disabled) || (e = e.type,
        n = !(e === "button" || e === "input" || e === "select" || e === "textarea")),
        e = !n;
        break e;
    default:
        e = !1
    }
    if (e)
        return null;
    if (r && typeof r != "function")
        throw Error(V(231, t, typeof r));
    return r
}
var bp = !1;
if (us)
    try {
        var pl = {};
        Object.defineProperty(pl, "passive", {
            get: function() {
                bp = !0
            }
        }),
        window.addEventListener("test", pl, pl),
        window.removeEventListener("test", pl, pl)
    } catch {
        bp = !1
    }
function fD(e, t, r, n, s, i, a, o, l) {
    var c = Array.prototype.slice.call(arguments, 3);
    try {
        t.apply(r, c)
    } catch (f) {
        this.onError(f)
    }
}
var Wl = !1
  , Zd = null
  , Kd = !1
  , xp = null
  , hD = {
    onError: function(e) {
        Wl = !0,
        Zd = e
    }
};
function mD(e, t, r, n, s, i, a, o, l) {
    Wl = !1,
    Zd = null,
    fD.apply(hD, arguments)
}
function pD(e, t, r, n, s, i, a, o, l) {
    if (mD.apply(this, arguments),
    Wl) {
        if (Wl) {
            var c = Zd;
            Wl = !1,
            Zd = null
        } else
            throw Error(V(198));
        Kd || (Kd = !0,
        xp = c)
    }
}
function ba(e) {
    var t = e
      , r = e;
    if (e.alternate)
        for (; t.return; )
            t = t.return;
    else {
        e = t;
        do
            t = e,
            t.flags & 4098 && (r = t.return),
            e = t.return;
        while (e)
    }
    return t.tag === 3 ? r : null
}
function KS(e) {
    if (e.tag === 13) {
        var t = e.memoizedState;
        if (t === null && (e = e.alternate,
        e !== null && (t = e.memoizedState)),
        t !== null)
            return t.dehydrated
    }
    return null
}
function X0(e) {
    if (ba(e) !== e)
        throw Error(V(188))
}
function yD(e) {
    var t = e.alternate;
    if (!t) {
        if (t = ba(e),
        t === null)
            throw Error(V(188));
        return t !== e ? null : e
    }
    for (var r = e, n = t; ; ) {
        var s = r.return;
        if (s === null)
            break;
        var i = s.alternate;
        if (i === null) {
            if (n = s.return,
            n !== null) {
                r = n;
                continue
            }
            break
        }
        if (s.child === i.child) {
            for (i = s.child; i; ) {
                if (i === r)
                    return X0(s),
                    e;
                if (i === n)
                    return X0(s),
                    t;
                i = i.sibling
            }
            throw Error(V(188))
        }
        if (r.return !== n.return)
            r = s,
            n = i;
        else {
            for (var a = !1, o = s.child; o; ) {
                if (o === r) {
                    a = !0,
                    r = s,
                    n = i;
                    break
                }
                if (o === n) {
                    a = !0,
                    n = s,
                    r = i;
                    break
                }
                o = o.sibling
            }
            if (!a) {
                for (o = i.child; o; ) {
                    if (o === r) {
                        a = !0,
                        r = i,
                        n = s;
                        break
                    }
                    if (o === n) {
                        a = !0,
                        n = i,
                        r = s;
                        break
                    }
                    o = o.sibling
                }
                if (!a)
                    throw Error(V(189))
            }
        }
        if (r.alternate !== n)
            throw Error(V(190))
    }
    if (r.tag !== 3)
        throw Error(V(188));
    return r.stateNode.current === r ? e : t
}
function QS(e) {
    return e = yD(e),
    e !== null ? GS(e) : null
}
function GS(e) {
    if (e.tag === 5 || e.tag === 6)
        return e;
    for (e = e.child; e !== null; ) {
        var t = GS(e);
        if (t !== null)
            return t;
        e = e.sibling
    }
    return null
}
var YS = Fr.unstable_scheduleCallback
  , eb = Fr.unstable_cancelCallback
  , gD = Fr.unstable_shouldYield
  , vD = Fr.unstable_requestPaint
  , Et = Fr.unstable_now
  , bD = Fr.unstable_getCurrentPriorityLevel
  , dg = Fr.unstable_ImmediatePriority
  , JS = Fr.unstable_UserBlockingPriority
  , Qd = Fr.unstable_NormalPriority
  , xD = Fr.unstable_LowPriority
  , XS = Fr.unstable_IdlePriority
  , Qf = null
  , zn = null;
function wD(e) {
    if (zn && typeof zn.onCommitFiberRoot == "function")
        try {
            zn.onCommitFiberRoot(Qf, e, void 0, (e.current.flags & 128) === 128)
        } catch {}
}
var xn = Math.clz32 ? Math.clz32 : ED
  , SD = Math.log
  , kD = Math.LN2;
function ED(e) {
    return e >>>= 0,
    e === 0 ? 32 : 31 - (SD(e) / kD | 0) | 0
}
var Rc = 64
  , Oc = 4194304;
function Ml(e) {
    switch (e & -e) {
    case 1:
        return 1;
    case 2:
        return 2;
    case 4:
        return 4;
    case 8:
        return 8;
    case 16:
        return 16;
    case 32:
        return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
        return e & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
        return e & 130023424;
    case 134217728:
        return 134217728;
    case 268435456:
        return 268435456;
    case 536870912:
        return 536870912;
    case 1073741824:
        return 1073741824;
    default:
        return e
    }
}
function Gd(e, t) {
    var r = e.pendingLanes;
    if (r === 0)
        return 0;
    var n = 0
      , s = e.suspendedLanes
      , i = e.pingedLanes
      , a = r & 268435455;
    if (a !== 0) {
        var o = a & ~s;
        o !== 0 ? n = Ml(o) : (i &= a,
        i !== 0 && (n = Ml(i)))
    } else
        a = r & ~s,
        a !== 0 ? n = Ml(a) : i !== 0 && (n = Ml(i));
    if (n === 0)
        return 0;
    if (t !== 0 && t !== n && !(t & s) && (s = n & -n,
    i = t & -t,
    s >= i || s === 16 && (i & 4194240) !== 0))
        return t;
    if (n & 4 && (n |= r & 16),
    t = e.entangledLanes,
    t !== 0)
        for (e = e.entanglements,
        t &= n; 0 < t; )
            r = 31 - xn(t),
            s = 1 << r,
            n |= e[r],
            t &= ~s;
    return n
}
function _D(e, t) {
    switch (e) {
    case 1:
    case 2:
    case 4:
        return t + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
        return t + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
        return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
        return -1;
    default:
        return -1
    }
}
function TD(e, t) {
    for (var r = e.suspendedLanes, n = e.pingedLanes, s = e.expirationTimes, i = e.pendingLanes; 0 < i; ) {
        var a = 31 - xn(i)
          , o = 1 << a
          , l = s[a];
        l === -1 ? (!(o & r) || o & n) && (s[a] = _D(o, t)) : l <= t && (e.expiredLanes |= o),
        i &= ~o
    }
}
function wp(e) {
    return e = e.pendingLanes & -1073741825,
    e !== 0 ? e : e & 1073741824 ? 1073741824 : 0
}
function e2() {
    var e = Rc;
    return Rc <<= 1,
    !(Rc & 4194240) && (Rc = 64),
    e
}
function Uh(e) {
    for (var t = [], r = 0; 31 > r; r++)
        t.push(e);
    return t
}
function Xu(e, t, r) {
    e.pendingLanes |= t,
    t !== 536870912 && (e.suspendedLanes = 0,
    e.pingedLanes = 0),
    e = e.eventTimes,
    t = 31 - xn(t),
    e[t] = r
}
function CD(e, t) {
    var r = e.pendingLanes & ~t;
    e.pendingLanes = t,
    e.suspendedLanes = 0,
    e.pingedLanes = 0,
    e.expiredLanes &= t,
    e.mutableReadLanes &= t,
    e.entangledLanes &= t,
    t = e.entanglements;
    var n = e.eventTimes;
    for (e = e.expirationTimes; 0 < r; ) {
        var s = 31 - xn(r)
          , i = 1 << s;
        t[s] = 0,
        n[s] = -1,
        e[s] = -1,
        r &= ~i
    }
}
function fg(e, t) {
    var r = e.entangledLanes |= t;
    for (e = e.entanglements; r; ) {
        var n = 31 - xn(r)
          , s = 1 << n;
        s & t | e[n] & t && (e[n] |= t),
        r &= ~s
    }
}
var Ze = 0;
function t2(e) {
    return e &= -e,
    1 < e ? 4 < e ? e & 268435455 ? 16 : 536870912 : 4 : 1
}
var r2, hg, n2, s2, i2, Sp = !1, Mc = [], Js = null, Xs = null, ei = null, Su = new Map, ku = new Map, Os = [], PD = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function tb(e, t) {
    switch (e) {
    case "focusin":
    case "focusout":
        Js = null;
        break;
    case "dragenter":
    case "dragleave":
        Xs = null;
        break;
    case "mouseover":
    case "mouseout":
        ei = null;
        break;
    case "pointerover":
    case "pointerout":
        Su.delete(t.pointerId);
        break;
    case "gotpointercapture":
    case "lostpointercapture":
        ku.delete(t.pointerId)
    }
}
function yl(e, t, r, n, s, i) {
    return e === null || e.nativeEvent !== i ? (e = {
        blockedOn: t,
        domEventName: r,
        eventSystemFlags: n,
        nativeEvent: i,
        targetContainers: [s]
    },
    t !== null && (t = tc(t),
    t !== null && hg(t)),
    e) : (e.eventSystemFlags |= n,
    t = e.targetContainers,
    s !== null && t.indexOf(s) === -1 && t.push(s),
    e)
}
function $D(e, t, r, n, s) {
    switch (t) {
    case "focusin":
        return Js = yl(Js, e, t, r, n, s),
        !0;
    case "dragenter":
        return Xs = yl(Xs, e, t, r, n, s),
        !0;
    case "mouseover":
        return ei = yl(ei, e, t, r, n, s),
        !0;
    case "pointerover":
        var i = s.pointerId;
        return Su.set(i, yl(Su.get(i) || null, e, t, r, n, s)),
        !0;
    case "gotpointercapture":
        return i = s.pointerId,
        ku.set(i, yl(ku.get(i) || null, e, t, r, n, s)),
        !0
    }
    return !1
}
function a2(e) {
    var t = Li(e.target);
    if (t !== null) {
        var r = ba(t);
        if (r !== null) {
            if (t = r.tag,
            t === 13) {
                if (t = KS(r),
                t !== null) {
                    e.blockedOn = t,
                    i2(e.priority, function() {
                        n2(r)
                    });
                    return
                }
            } else if (t === 3 && r.stateNode.current.memoizedState.isDehydrated) {
                e.blockedOn = r.tag === 3 ? r.stateNode.containerInfo : null;
                return
            }
        }
    }
    e.blockedOn = null
}
function ld(e) {
    if (e.blockedOn !== null)
        return !1;
    for (var t = e.targetContainers; 0 < t.length; ) {
        var r = kp(e.domEventName, e.eventSystemFlags, t[0], e.nativeEvent);
        if (r === null) {
            r = e.nativeEvent;
            var n = new r.constructor(r.type,r);
            gp = n,
            r.target.dispatchEvent(n),
            gp = null
        } else
            return t = tc(r),
            t !== null && hg(t),
            e.blockedOn = r,
            !1;
        t.shift()
    }
    return !0
}
function rb(e, t, r) {
    ld(e) && r.delete(t)
}
function ND() {
    Sp = !1,
    Js !== null && ld(Js) && (Js = null),
    Xs !== null && ld(Xs) && (Xs = null),
    ei !== null && ld(ei) && (ei = null),
    Su.forEach(rb),
    ku.forEach(rb)
}
function gl(e, t) {
    e.blockedOn === t && (e.blockedOn = null,
    Sp || (Sp = !0,
    Fr.unstable_scheduleCallback(Fr.unstable_NormalPriority, ND)))
}
function Eu(e) {
    function t(s) {
        return gl(s, e)
    }
    if (0 < Mc.length) {
        gl(Mc[0], e);
        for (var r = 1; r < Mc.length; r++) {
            var n = Mc[r];
            n.blockedOn === e && (n.blockedOn = null)
        }
    }
    for (Js !== null && gl(Js, e),
    Xs !== null && gl(Xs, e),
    ei !== null && gl(ei, e),
    Su.forEach(t),
    ku.forEach(t),
    r = 0; r < Os.length; r++)
        n = Os[r],
        n.blockedOn === e && (n.blockedOn = null);
    for (; 0 < Os.length && (r = Os[0],
    r.blockedOn === null); )
        a2(r),
        r.blockedOn === null && Os.shift()
}
var lo = vs.ReactCurrentBatchConfig
  , Yd = !0;
function jD(e, t, r, n) {
    var s = Ze
      , i = lo.transition;
    lo.transition = null;
    try {
        Ze = 1,
        mg(e, t, r, n)
    } finally {
        Ze = s,
        lo.transition = i
    }
}
function ID(e, t, r, n) {
    var s = Ze
      , i = lo.transition;
    lo.transition = null;
    try {
        Ze = 4,
        mg(e, t, r, n)
    } finally {
        Ze = s,
        lo.transition = i
    }
}
function mg(e, t, r, n) {
    if (Yd) {
        var s = kp(e, t, r, n);
        if (s === null)
            Yh(e, t, n, Jd, r),
            tb(e, n);
        else if ($D(s, e, t, r, n))
            n.stopPropagation();
        else if (tb(e, n),
        t & 4 && -1 < PD.indexOf(e)) {
            for (; s !== null; ) {
                var i = tc(s);
                if (i !== null && r2(i),
                i = kp(e, t, r, n),
                i === null && Yh(e, t, n, Jd, r),
                i === s)
                    break;
                s = i
            }
            s !== null && n.stopPropagation()
        } else
            Yh(e, t, n, null, r)
    }
}
var Jd = null;
function kp(e, t, r, n) {
    if (Jd = null,
    e = cg(n),
    e = Li(e),
    e !== null)
        if (t = ba(e),
        t === null)
            e = null;
        else if (r = t.tag,
        r === 13) {
            if (e = KS(t),
            e !== null)
                return e;
            e = null
        } else if (r === 3) {
            if (t.stateNode.current.memoizedState.isDehydrated)
                return t.tag === 3 ? t.stateNode.containerInfo : null;
            e = null
        } else
            t !== e && (e = null);
    return Jd = e,
    null
}
function o2(e) {
    switch (e) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
        return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
        return 4;
    case "message":
        switch (bD()) {
        case dg:
            return 1;
        case JS:
            return 4;
        case Qd:
        case xD:
            return 16;
        case XS:
            return 536870912;
        default:
            return 16
        }
    default:
        return 16
    }
}
var Ks = null
  , pg = null
  , ud = null;
function l2() {
    if (ud)
        return ud;
    var e, t = pg, r = t.length, n, s = "value"in Ks ? Ks.value : Ks.textContent, i = s.length;
    for (e = 0; e < r && t[e] === s[e]; e++)
        ;
    var a = r - e;
    for (n = 1; n <= a && t[r - n] === s[i - n]; n++)
        ;
    return ud = s.slice(e, 1 < n ? 1 - n : void 0)
}
function cd(e) {
    var t = e.keyCode;
    return "charCode"in e ? (e = e.charCode,
    e === 0 && t === 13 && (e = 13)) : e = t,
    e === 10 && (e = 13),
    32 <= e || e === 13 ? e : 0
}
function Ac() {
    return !0
}
function nb() {
    return !1
}
function Ur(e) {
    function t(r, n, s, i, a) {
        this._reactName = r,
        this._targetInst = s,
        this.type = n,
        this.nativeEvent = i,
        this.target = a,
        this.currentTarget = null;
        for (var o in e)
            e.hasOwnProperty(o) && (r = e[o],
            this[o] = r ? r(i) : i[o]);
        return this.isDefaultPrevented = (i.defaultPrevented != null ? i.defaultPrevented : i.returnValue === !1) ? Ac : nb,
        this.isPropagationStopped = nb,
        this
    }
    return dt(t.prototype, {
        preventDefault: function() {
            this.defaultPrevented = !0;
            var r = this.nativeEvent;
            r && (r.preventDefault ? r.preventDefault() : typeof r.returnValue != "unknown" && (r.returnValue = !1),
            this.isDefaultPrevented = Ac)
        },
        stopPropagation: function() {
            var r = this.nativeEvent;
            r && (r.stopPropagation ? r.stopPropagation() : typeof r.cancelBubble != "unknown" && (r.cancelBubble = !0),
            this.isPropagationStopped = Ac)
        },
        persist: function() {},
        isPersistent: Ac
    }),
    t
}
var Yo = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function(e) {
        return e.timeStamp || Date.now()
    },
    defaultPrevented: 0,
    isTrusted: 0
}, yg = Ur(Yo), ec = dt({}, Yo, {
    view: 0,
    detail: 0
}), RD = Ur(ec), Vh, Bh, vl, Gf = dt({}, ec, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: gg,
    button: 0,
    buttons: 0,
    relatedTarget: function(e) {
        return e.relatedTarget === void 0 ? e.fromElement === e.srcElement ? e.toElement : e.fromElement : e.relatedTarget
    },
    movementX: function(e) {
        return "movementX"in e ? e.movementX : (e !== vl && (vl && e.type === "mousemove" ? (Vh = e.screenX - vl.screenX,
        Bh = e.screenY - vl.screenY) : Bh = Vh = 0,
        vl = e),
        Vh)
    },
    movementY: function(e) {
        return "movementY"in e ? e.movementY : Bh
    }
}), sb = Ur(Gf), OD = dt({}, Gf, {
    dataTransfer: 0
}), MD = Ur(OD), AD = dt({}, ec, {
    relatedTarget: 0
}), Wh = Ur(AD), LD = dt({}, Yo, {
    animationName: 0,
    elapsedTime: 0,
    pseudoElement: 0
}), DD = Ur(LD), FD = dt({}, Yo, {
    clipboardData: function(e) {
        return "clipboardData"in e ? e.clipboardData : window.clipboardData
    }
}), zD = Ur(FD), UD = dt({}, Yo, {
    data: 0
}), ib = Ur(UD), VD = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
}, BD = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
}, WD = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey"
};
function qD(e) {
    var t = this.nativeEvent;
    return t.getModifierState ? t.getModifierState(e) : (e = WD[e]) ? !!t[e] : !1
}
function gg() {
    return qD
}
var HD = dt({}, ec, {
    key: function(e) {
        if (e.key) {
            var t = VD[e.key] || e.key;
            if (t !== "Unidentified")
                return t
        }
        return e.type === "keypress" ? (e = cd(e),
        e === 13 ? "Enter" : String.fromCharCode(e)) : e.type === "keydown" || e.type === "keyup" ? BD[e.keyCode] || "Unidentified" : ""
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: gg,
    charCode: function(e) {
        return e.type === "keypress" ? cd(e) : 0
    },
    keyCode: function(e) {
        return e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0
    },
    which: function(e) {
        return e.type === "keypress" ? cd(e) : e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0
    }
})
  , ZD = Ur(HD)
  , KD = dt({}, Gf, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0
})
  , ab = Ur(KD)
  , QD = dt({}, ec, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: gg
})
  , GD = Ur(QD)
  , YD = dt({}, Yo, {
    propertyName: 0,
    elapsedTime: 0,
    pseudoElement: 0
})
  , JD = Ur(YD)
  , XD = dt({}, Gf, {
    deltaX: function(e) {
        return "deltaX"in e ? e.deltaX : "wheelDeltaX"in e ? -e.wheelDeltaX : 0
    },
    deltaY: function(e) {
        return "deltaY"in e ? e.deltaY : "wheelDeltaY"in e ? -e.wheelDeltaY : "wheelDelta"in e ? -e.wheelDelta : 0
    },
    deltaZ: 0,
    deltaMode: 0
})
  , eF = Ur(XD)
  , tF = [9, 13, 27, 32]
  , vg = us && "CompositionEvent"in window
  , ql = null;
us && "documentMode"in document && (ql = document.documentMode);
var rF = us && "TextEvent"in window && !ql
  , u2 = us && (!vg || ql && 8 < ql && 11 >= ql)
  , ob = " "
  , lb = !1;
function c2(e, t) {
    switch (e) {
    case "keyup":
        return tF.indexOf(t.keyCode) !== -1;
    case "keydown":
        return t.keyCode !== 229;
    case "keypress":
    case "mousedown":
    case "focusout":
        return !0;
    default:
        return !1
    }
}
function d2(e) {
    return e = e.detail,
    typeof e == "object" && "data"in e ? e.data : null
}
var qa = !1;
function nF(e, t) {
    switch (e) {
    case "compositionend":
        return d2(t);
    case "keypress":
        return t.which !== 32 ? null : (lb = !0,
        ob);
    case "textInput":
        return e = t.data,
        e === ob && lb ? null : e;
    default:
        return null
    }
}
function sF(e, t) {
    if (qa)
        return e === "compositionend" || !vg && c2(e, t) ? (e = l2(),
        ud = pg = Ks = null,
        qa = !1,
        e) : null;
    switch (e) {
    case "paste":
        return null;
    case "keypress":
        if (!(t.ctrlKey || t.altKey || t.metaKey) || t.ctrlKey && t.altKey) {
            if (t.char && 1 < t.char.length)
                return t.char;
            if (t.which)
                return String.fromCharCode(t.which)
        }
        return null;
    case "compositionend":
        return u2 && t.locale !== "ko" ? null : t.data;
    default:
        return null
    }
}
var iF = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0
};
function ub(e) {
    var t = e && e.nodeName && e.nodeName.toLowerCase();
    return t === "input" ? !!iF[e.type] : t === "textarea"
}
function f2(e, t, r, n) {
    BS(n),
    t = Xd(t, "onChange"),
    0 < t.length && (r = new yg("onChange","change",null,r,n),
    e.push({
        event: r,
        listeners: t
    }))
}
var Hl = null
  , _u = null;
function aF(e) {
    k2(e, 0)
}
function Yf(e) {
    var t = Ka(e);
    if (AS(t))
        return e
}
function oF(e, t) {
    if (e === "change")
        return t
}
var h2 = !1;
if (us) {
    var qh;
    if (us) {
        var Hh = "oninput"in document;
        if (!Hh) {
            var cb = document.createElement("div");
            cb.setAttribute("oninput", "return;"),
            Hh = typeof cb.oninput == "function"
        }
        qh = Hh
    } else
        qh = !1;
    h2 = qh && (!document.documentMode || 9 < document.documentMode)
}
function db() {
    Hl && (Hl.detachEvent("onpropertychange", m2),
    _u = Hl = null)
}
function m2(e) {
    if (e.propertyName === "value" && Yf(_u)) {
        var t = [];
        f2(t, _u, e, cg(e)),
        ZS(aF, t)
    }
}
function lF(e, t, r) {
    e === "focusin" ? (db(),
    Hl = t,
    _u = r,
    Hl.attachEvent("onpropertychange", m2)) : e === "focusout" && db()
}
function uF(e) {
    if (e === "selectionchange" || e === "keyup" || e === "keydown")
        return Yf(_u)
}
function cF(e, t) {
    if (e === "click")
        return Yf(t)
}
function dF(e, t) {
    if (e === "input" || e === "change")
        return Yf(t)
}
function fF(e, t) {
    return e === t && (e !== 0 || 1 / e === 1 / t) || e !== e && t !== t
}
var kn = typeof Object.is == "function" ? Object.is : fF;
function Tu(e, t) {
    if (kn(e, t))
        return !0;
    if (typeof e != "object" || e === null || typeof t != "object" || t === null)
        return !1;
    var r = Object.keys(e)
      , n = Object.keys(t);
    if (r.length !== n.length)
        return !1;
    for (n = 0; n < r.length; n++) {
        var s = r[n];
        if (!ip.call(t, s) || !kn(e[s], t[s]))
            return !1
    }
    return !0
}
function fb(e) {
    for (; e && e.firstChild; )
        e = e.firstChild;
    return e
}
function hb(e, t) {
    var r = fb(e);
    e = 0;
    for (var n; r; ) {
        if (r.nodeType === 3) {
            if (n = e + r.textContent.length,
            e <= t && n >= t)
                return {
                    node: r,
                    offset: t - e
                };
            e = n
        }
        e: {
            for (; r; ) {
                if (r.nextSibling) {
                    r = r.nextSibling;
                    break e
                }
                r = r.parentNode
            }
            r = void 0
        }
        r = fb(r)
    }
}
function p2(e, t) {
    return e && t ? e === t ? !0 : e && e.nodeType === 3 ? !1 : t && t.nodeType === 3 ? p2(e, t.parentNode) : "contains"in e ? e.contains(t) : e.compareDocumentPosition ? !!(e.compareDocumentPosition(t) & 16) : !1 : !1
}
function y2() {
    for (var e = window, t = Hd(); t instanceof e.HTMLIFrameElement; ) {
        try {
            var r = typeof t.contentWindow.location.href == "string"
        } catch {
            r = !1
        }
        if (r)
            e = t.contentWindow;
        else
            break;
        t = Hd(e.document)
    }
    return t
}
function bg(e) {
    var t = e && e.nodeName && e.nodeName.toLowerCase();
    return t && (t === "input" && (e.type === "text" || e.type === "search" || e.type === "tel" || e.type === "url" || e.type === "password") || t === "textarea" || e.contentEditable === "true")
}
function hF(e) {
    var t = y2()
      , r = e.focusedElem
      , n = e.selectionRange;
    if (t !== r && r && r.ownerDocument && p2(r.ownerDocument.documentElement, r)) {
        if (n !== null && bg(r)) {
            if (t = n.start,
            e = n.end,
            e === void 0 && (e = t),
            "selectionStart"in r)
                r.selectionStart = t,
                r.selectionEnd = Math.min(e, r.value.length);
            else if (e = (t = r.ownerDocument || document) && t.defaultView || window,
            e.getSelection) {
                e = e.getSelection();
                var s = r.textContent.length
                  , i = Math.min(n.start, s);
                n = n.end === void 0 ? i : Math.min(n.end, s),
                !e.extend && i > n && (s = n,
                n = i,
                i = s),
                s = hb(r, i);
                var a = hb(r, n);
                s && a && (e.rangeCount !== 1 || e.anchorNode !== s.node || e.anchorOffset !== s.offset || e.focusNode !== a.node || e.focusOffset !== a.offset) && (t = t.createRange(),
                t.setStart(s.node, s.offset),
                e.removeAllRanges(),
                i > n ? (e.addRange(t),
                e.extend(a.node, a.offset)) : (t.setEnd(a.node, a.offset),
                e.addRange(t)))
            }
        }
        for (t = [],
        e = r; e = e.parentNode; )
            e.nodeType === 1 && t.push({
                element: e,
                left: e.scrollLeft,
                top: e.scrollTop
            });
        for (typeof r.focus == "function" && r.focus(),
        r = 0; r < t.length; r++)
            e = t[r],
            e.element.scrollLeft = e.left,
            e.element.scrollTop = e.top
    }
}
var mF = us && "documentMode"in document && 11 >= document.documentMode
  , Ha = null
  , Ep = null
  , Zl = null
  , _p = !1;
function mb(e, t, r) {
    var n = r.window === r ? r.document : r.nodeType === 9 ? r : r.ownerDocument;
    _p || Ha == null || Ha !== Hd(n) || (n = Ha,
    "selectionStart"in n && bg(n) ? n = {
        start: n.selectionStart,
        end: n.selectionEnd
    } : (n = (n.ownerDocument && n.ownerDocument.defaultView || window).getSelection(),
    n = {
        anchorNode: n.anchorNode,
        anchorOffset: n.anchorOffset,
        focusNode: n.focusNode,
        focusOffset: n.focusOffset
    }),
    Zl && Tu(Zl, n) || (Zl = n,
    n = Xd(Ep, "onSelect"),
    0 < n.length && (t = new yg("onSelect","select",null,t,r),
    e.push({
        event: t,
        listeners: n
    }),
    t.target = Ha)))
}
function Lc(e, t) {
    var r = {};
    return r[e.toLowerCase()] = t.toLowerCase(),
    r["Webkit" + e] = "webkit" + t,
    r["Moz" + e] = "moz" + t,
    r
}
var Za = {
    animationend: Lc("Animation", "AnimationEnd"),
    animationiteration: Lc("Animation", "AnimationIteration"),
    animationstart: Lc("Animation", "AnimationStart"),
    transitionend: Lc("Transition", "TransitionEnd")
}
  , Zh = {}
  , g2 = {};
us && (g2 = document.createElement("div").style,
"AnimationEvent"in window || (delete Za.animationend.animation,
delete Za.animationiteration.animation,
delete Za.animationstart.animation),
"TransitionEvent"in window || delete Za.transitionend.transition);
function Jf(e) {
    if (Zh[e])
        return Zh[e];
    if (!Za[e])
        return e;
    var t = Za[e], r;
    for (r in t)
        if (t.hasOwnProperty(r) && r in g2)
            return Zh[e] = t[r];
    return e
}
var v2 = Jf("animationend")
  , b2 = Jf("animationiteration")
  , x2 = Jf("animationstart")
  , w2 = Jf("transitionend")
  , S2 = new Map
  , pb = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function vi(e, t) {
    S2.set(e, t),
    va(t, [e])
}
for (var Kh = 0; Kh < pb.length; Kh++) {
    var Qh = pb[Kh]
      , pF = Qh.toLowerCase()
      , yF = Qh[0].toUpperCase() + Qh.slice(1);
    vi(pF, "on" + yF)
}
vi(v2, "onAnimationEnd");
vi(b2, "onAnimationIteration");
vi(x2, "onAnimationStart");
vi("dblclick", "onDoubleClick");
vi("focusin", "onFocus");
vi("focusout", "onBlur");
vi(w2, "onTransitionEnd");
jo("onMouseEnter", ["mouseout", "mouseover"]);
jo("onMouseLeave", ["mouseout", "mouseover"]);
jo("onPointerEnter", ["pointerout", "pointerover"]);
jo("onPointerLeave", ["pointerout", "pointerover"]);
va("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
va("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
va("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
va("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
va("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
va("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var Al = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" ")
  , gF = new Set("cancel close invalid load scroll toggle".split(" ").concat(Al));
function yb(e, t, r) {
    var n = e.type || "unknown-event";
    e.currentTarget = r,
    pD(n, t, void 0, e),
    e.currentTarget = null
}
function k2(e, t) {
    t = (t & 4) !== 0;
    for (var r = 0; r < e.length; r++) {
        var n = e[r]
          , s = n.event;
        n = n.listeners;
        e: {
            var i = void 0;
            if (t)
                for (var a = n.length - 1; 0 <= a; a--) {
                    var o = n[a]
                      , l = o.instance
                      , c = o.currentTarget;
                    if (o = o.listener,
                    l !== i && s.isPropagationStopped())
                        break e;
                    yb(s, o, c),
                    i = l
                }
            else
                for (a = 0; a < n.length; a++) {
                    if (o = n[a],
                    l = o.instance,
                    c = o.currentTarget,
                    o = o.listener,
                    l !== i && s.isPropagationStopped())
                        break e;
                    yb(s, o, c),
                    i = l
                }
        }
    }
    if (Kd)
        throw e = xp,
        Kd = !1,
        xp = null,
        e
}
function Xe(e, t) {
    var r = t[Np];
    r === void 0 && (r = t[Np] = new Set);
    var n = e + "__bubble";
    r.has(n) || (E2(t, e, 2, !1),
    r.add(n))
}
function Gh(e, t, r) {
    var n = 0;
    t && (n |= 4),
    E2(r, e, n, t)
}
var Dc = "_reactListening" + Math.random().toString(36).slice(2);
function Cu(e) {
    if (!e[Dc]) {
        e[Dc] = !0,
        jS.forEach(function(r) {
            r !== "selectionchange" && (gF.has(r) || Gh(r, !1, e),
            Gh(r, !0, e))
        });
        var t = e.nodeType === 9 ? e : e.ownerDocument;
        t === null || t[Dc] || (t[Dc] = !0,
        Gh("selectionchange", !1, t))
    }
}
function E2(e, t, r, n) {
    switch (o2(t)) {
    case 1:
        var s = jD;
        break;
    case 4:
        s = ID;
        break;
    default:
        s = mg
    }
    r = s.bind(null, t, r, e),
    s = void 0,
    !bp || t !== "touchstart" && t !== "touchmove" && t !== "wheel" || (s = !0),
    n ? s !== void 0 ? e.addEventListener(t, r, {
        capture: !0,
        passive: s
    }) : e.addEventListener(t, r, !0) : s !== void 0 ? e.addEventListener(t, r, {
        passive: s
    }) : e.addEventListener(t, r, !1)
}
function Yh(e, t, r, n, s) {
    var i = n;
    if (!(t & 1) && !(t & 2) && n !== null)
        e: for (; ; ) {
            if (n === null)
                return;
            var a = n.tag;
            if (a === 3 || a === 4) {
                var o = n.stateNode.containerInfo;
                if (o === s || o.nodeType === 8 && o.parentNode === s)
                    break;
                if (a === 4)
                    for (a = n.return; a !== null; ) {
                        var l = a.tag;
                        if ((l === 3 || l === 4) && (l = a.stateNode.containerInfo,
                        l === s || l.nodeType === 8 && l.parentNode === s))
                            return;
                        a = a.return
                    }
                for (; o !== null; ) {
                    if (a = Li(o),
                    a === null)
                        return;
                    if (l = a.tag,
                    l === 5 || l === 6) {
                        n = i = a;
                        continue e
                    }
                    o = o.parentNode
                }
            }
            n = n.return
        }
    ZS(function() {
        var c = i
          , f = cg(r)
          , h = [];
        e: {
            var m = S2.get(e);
            if (m !== void 0) {
                var y = yg
                  , k = e;
                switch (e) {
                case "keypress":
                    if (cd(r) === 0)
                        break e;
                case "keydown":
                case "keyup":
                    y = ZD;
                    break;
                case "focusin":
                    k = "focus",
                    y = Wh;
                    break;
                case "focusout":
                    k = "blur",
                    y = Wh;
                    break;
                case "beforeblur":
                case "afterblur":
                    y = Wh;
                    break;
                case "click":
                    if (r.button === 2)
                        break e;
                case "auxclick":
                case "dblclick":
                case "mousedown":
                case "mousemove":
                case "mouseup":
                case "mouseout":
                case "mouseover":
                case "contextmenu":
                    y = sb;
                    break;
                case "drag":
                case "dragend":
                case "dragenter":
                case "dragexit":
                case "dragleave":
                case "dragover":
                case "dragstart":
                case "drop":
                    y = MD;
                    break;
                case "touchcancel":
                case "touchend":
                case "touchmove":
                case "touchstart":
                    y = GD;
                    break;
                case v2:
                case b2:
                case x2:
                    y = DD;
                    break;
                case w2:
                    y = JD;
                    break;
                case "scroll":
                    y = RD;
                    break;
                case "wheel":
                    y = eF;
                    break;
                case "copy":
                case "cut":
                case "paste":
                    y = zD;
                    break;
                case "gotpointercapture":
                case "lostpointercapture":
                case "pointercancel":
                case "pointerdown":
                case "pointermove":
                case "pointerout":
                case "pointerover":
                case "pointerup":
                    y = ab
                }
                var x = (t & 4) !== 0
                  , w = !x && e === "scroll"
                  , v = x ? m !== null ? m + "Capture" : null : m;
                x = [];
                for (var p = c, S; p !== null; ) {
                    S = p;
                    var P = S.stateNode;
                    if (S.tag === 5 && P !== null && (S = P,
                    v !== null && (P = wu(p, v),
                    P != null && x.push(Pu(p, P, S)))),
                    w)
                        break;
                    p = p.return
                }
                0 < x.length && (m = new y(m,k,null,r,f),
                h.push({
                    event: m,
                    listeners: x
                }))
            }
        }
        if (!(t & 7)) {
            e: {
                if (m = e === "mouseover" || e === "pointerover",
                y = e === "mouseout" || e === "pointerout",
                m && r !== gp && (k = r.relatedTarget || r.fromElement) && (Li(k) || k[cs]))
                    break e;
                if ((y || m) && (m = f.window === f ? f : (m = f.ownerDocument) ? m.defaultView || m.parentWindow : window,
                y ? (k = r.relatedTarget || r.toElement,
                y = c,
                k = k ? Li(k) : null,
                k !== null && (w = ba(k),
                k !== w || k.tag !== 5 && k.tag !== 6) && (k = null)) : (y = null,
                k = c),
                y !== k)) {
                    if (x = sb,
                    P = "onMouseLeave",
                    v = "onMouseEnter",
                    p = "mouse",
                    (e === "pointerout" || e === "pointerover") && (x = ab,
                    P = "onPointerLeave",
                    v = "onPointerEnter",
                    p = "pointer"),
                    w = y == null ? m : Ka(y),
                    S = k == null ? m : Ka(k),
                    m = new x(P,p + "leave",y,r,f),
                    m.target = w,
                    m.relatedTarget = S,
                    P = null,
                    Li(f) === c && (x = new x(v,p + "enter",k,r,f),
                    x.target = S,
                    x.relatedTarget = w,
                    P = x),
                    w = P,
                    y && k)
                        t: {
                            for (x = y,
                            v = k,
                            p = 0,
                            S = x; S; S = $a(S))
                                p++;
                            for (S = 0,
                            P = v; P; P = $a(P))
                                S++;
                            for (; 0 < p - S; )
                                x = $a(x),
                                p--;
                            for (; 0 < S - p; )
                                v = $a(v),
                                S--;
                            for (; p--; ) {
                                if (x === v || v !== null && x === v.alternate)
                                    break t;
                                x = $a(x),
                                v = $a(v)
                            }
                            x = null
                        }
                    else
                        x = null;
                    y !== null && gb(h, m, y, x, !1),
                    k !== null && w !== null && gb(h, w, k, x, !0)
                }
            }
            e: {
                if (m = c ? Ka(c) : window,
                y = m.nodeName && m.nodeName.toLowerCase(),
                y === "select" || y === "input" && m.type === "file")
                    var j = oF;
                else if (ub(m))
                    if (h2)
                        j = dF;
                    else {
                        j = uF;
                        var L = lF
                    }
                else
                    (y = m.nodeName) && y.toLowerCase() === "input" && (m.type === "checkbox" || m.type === "radio") && (j = cF);
                if (j && (j = j(e, c))) {
                    f2(h, j, r, f);
                    break e
                }
                L && L(e, m, c),
                e === "focusout" && (L = m._wrapperState) && L.controlled && m.type === "number" && fp(m, "number", m.value)
            }
            switch (L = c ? Ka(c) : window,
            e) {
            case "focusin":
                (ub(L) || L.contentEditable === "true") && (Ha = L,
                Ep = c,
                Zl = null);
                break;
            case "focusout":
                Zl = Ep = Ha = null;
                break;
            case "mousedown":
                _p = !0;
                break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
                _p = !1,
                mb(h, r, f);
                break;
            case "selectionchange":
                if (mF)
                    break;
            case "keydown":
            case "keyup":
                mb(h, r, f)
            }
            var E;
            if (vg)
                e: {
                    switch (e) {
                    case "compositionstart":
                        var b = "onCompositionStart";
                        break e;
                    case "compositionend":
                        b = "onCompositionEnd";
                        break e;
                    case "compositionupdate":
                        b = "onCompositionUpdate";
                        break e
                    }
                    b = void 0
                }
            else
                qa ? c2(e, r) && (b = "onCompositionEnd") : e === "keydown" && r.keyCode === 229 && (b = "onCompositionStart");
            b && (u2 && r.locale !== "ko" && (qa || b !== "onCompositionStart" ? b === "onCompositionEnd" && qa && (E = l2()) : (Ks = f,
            pg = "value"in Ks ? Ks.value : Ks.textContent,
            qa = !0)),
            L = Xd(c, b),
            0 < L.length && (b = new ib(b,e,null,r,f),
            h.push({
                event: b,
                listeners: L
            }),
            E ? b.data = E : (E = d2(r),
            E !== null && (b.data = E)))),
            (E = rF ? nF(e, r) : sF(e, r)) && (c = Xd(c, "onBeforeInput"),
            0 < c.length && (f = new ib("onBeforeInput","beforeinput",null,r,f),
            h.push({
                event: f,
                listeners: c
            }),
            f.data = E))
        }
        k2(h, t)
    })
}
function Pu(e, t, r) {
    return {
        instance: e,
        listener: t,
        currentTarget: r
    }
}
function Xd(e, t) {
    for (var r = t + "Capture", n = []; e !== null; ) {
        var s = e
          , i = s.stateNode;
        s.tag === 5 && i !== null && (s = i,
        i = wu(e, r),
        i != null && n.unshift(Pu(e, i, s)),
        i = wu(e, t),
        i != null && n.push(Pu(e, i, s))),
        e = e.return
    }
    return n
}
function $a(e) {
    if (e === null)
        return null;
    do
        e = e.return;
    while (e && e.tag !== 5);
    return e || null
}
function gb(e, t, r, n, s) {
    for (var i = t._reactName, a = []; r !== null && r !== n; ) {
        var o = r
          , l = o.alternate
          , c = o.stateNode;
        if (l !== null && l === n)
            break;
        o.tag === 5 && c !== null && (o = c,
        s ? (l = wu(r, i),
        l != null && a.unshift(Pu(r, l, o))) : s || (l = wu(r, i),
        l != null && a.push(Pu(r, l, o)))),
        r = r.return
    }
    a.length !== 0 && e.push({
        event: t,
        listeners: a
    })
}
var vF = /\r\n?/g
  , bF = /\u0000|\uFFFD/g;
function vb(e) {
    return (typeof e == "string" ? e : "" + e).replace(vF, `
`).replace(bF, "")
}
function Fc(e, t, r) {
    if (t = vb(t),
    vb(e) !== t && r)
        throw Error(V(425))
}
function ef() {}
var Tp = null
  , Cp = null;
function Pp(e, t) {
    return e === "textarea" || e === "noscript" || typeof t.children == "string" || typeof t.children == "number" || typeof t.dangerouslySetInnerHTML == "object" && t.dangerouslySetInnerHTML !== null && t.dangerouslySetInnerHTML.__html != null
}
var $p = typeof setTimeout == "function" ? setTimeout : void 0
  , xF = typeof clearTimeout == "function" ? clearTimeout : void 0
  , bb = typeof Promise == "function" ? Promise : void 0
  , wF = typeof queueMicrotask == "function" ? queueMicrotask : typeof bb < "u" ? function(e) {
    return bb.resolve(null).then(e).catch(SF)
}
: $p;
function SF(e) {
    setTimeout(function() {
        throw e
    })
}
function Jh(e, t) {
    var r = t
      , n = 0;
    do {
        var s = r.nextSibling;
        if (e.removeChild(r),
        s && s.nodeType === 8)
            if (r = s.data,
            r === "/$") {
                if (n === 0) {
                    e.removeChild(s),
                    Eu(t);
                    return
                }
                n--
            } else
                r !== "$" && r !== "$?" && r !== "$!" || n++;
        r = s
    } while (r);
    Eu(t)
}
function ti(e) {
    for (; e != null; e = e.nextSibling) {
        var t = e.nodeType;
        if (t === 1 || t === 3)
            break;
        if (t === 8) {
            if (t = e.data,
            t === "$" || t === "$!" || t === "$?")
                break;
            if (t === "/$")
                return null
        }
    }
    return e
}
function xb(e) {
    e = e.previousSibling;
    for (var t = 0; e; ) {
        if (e.nodeType === 8) {
            var r = e.data;
            if (r === "$" || r === "$!" || r === "$?") {
                if (t === 0)
                    return e;
                t--
            } else
                r === "/$" && t++
        }
        e = e.previousSibling
    }
    return null
}
var Jo = Math.random().toString(36).slice(2)
  , Mn = "__reactFiber$" + Jo
  , $u = "__reactProps$" + Jo
  , cs = "__reactContainer$" + Jo
  , Np = "__reactEvents$" + Jo
  , kF = "__reactListeners$" + Jo
  , EF = "__reactHandles$" + Jo;
function Li(e) {
    var t = e[Mn];
    if (t)
        return t;
    for (var r = e.parentNode; r; ) {
        if (t = r[cs] || r[Mn]) {
            if (r = t.alternate,
            t.child !== null || r !== null && r.child !== null)
                for (e = xb(e); e !== null; ) {
                    if (r = e[Mn])
                        return r;
                    e = xb(e)
                }
            return t
        }
        e = r,
        r = e.parentNode
    }
    return null
}
function tc(e) {
    return e = e[Mn] || e[cs],
    !e || e.tag !== 5 && e.tag !== 6 && e.tag !== 13 && e.tag !== 3 ? null : e
}
function Ka(e) {
    if (e.tag === 5 || e.tag === 6)
        return e.stateNode;
    throw Error(V(33))
}
function Xf(e) {
    return e[$u] || null
}
var jp = []
  , Qa = -1;
function bi(e) {
    return {
        current: e
    }
}
function rt(e) {
    0 > Qa || (e.current = jp[Qa],
    jp[Qa] = null,
    Qa--)
}
function Ye(e, t) {
    Qa++,
    jp[Qa] = e.current,
    e.current = t
}
var mi = {}
  , sr = bi(mi)
  , Pr = bi(!1)
  , ua = mi;
function Io(e, t) {
    var r = e.type.contextTypes;
    if (!r)
        return mi;
    var n = e.stateNode;
    if (n && n.__reactInternalMemoizedUnmaskedChildContext === t)
        return n.__reactInternalMemoizedMaskedChildContext;
    var s = {}, i;
    for (i in r)
        s[i] = t[i];
    return n && (e = e.stateNode,
    e.__reactInternalMemoizedUnmaskedChildContext = t,
    e.__reactInternalMemoizedMaskedChildContext = s),
    s
}
function $r(e) {
    return e = e.childContextTypes,
    e != null
}
function tf() {
    rt(Pr),
    rt(sr)
}
function wb(e, t, r) {
    if (sr.current !== mi)
        throw Error(V(168));
    Ye(sr, t),
    Ye(Pr, r)
}
function _2(e, t, r) {
    var n = e.stateNode;
    if (t = t.childContextTypes,
    typeof n.getChildContext != "function")
        return r;
    n = n.getChildContext();
    for (var s in n)
        if (!(s in t))
            throw Error(V(108, lD(e) || "Unknown", s));
    return dt({}, r, n)
}
function rf(e) {
    return e = (e = e.stateNode) && e.__reactInternalMemoizedMergedChildContext || mi,
    ua = sr.current,
    Ye(sr, e),
    Ye(Pr, Pr.current),
    !0
}
function Sb(e, t, r) {
    var n = e.stateNode;
    if (!n)
        throw Error(V(169));
    r ? (e = _2(e, t, ua),
    n.__reactInternalMemoizedMergedChildContext = e,
    rt(Pr),
    rt(sr),
    Ye(sr, e)) : rt(Pr),
    Ye(Pr, r)
}
var Jn = null
  , eh = !1
  , Xh = !1;
function T2(e) {
    Jn === null ? Jn = [e] : Jn.push(e)
}
function _F(e) {
    eh = !0,
    T2(e)
}
function xi() {
    if (!Xh && Jn !== null) {
        Xh = !0;
        var e = 0
          , t = Ze;
        try {
            var r = Jn;
            for (Ze = 1; e < r.length; e++) {
                var n = r[e];
                do
                    n = n(!0);
                while (n !== null)
            }
            Jn = null,
            eh = !1
        } catch (s) {
            throw Jn !== null && (Jn = Jn.slice(e + 1)),
            YS(dg, xi),
            s
        } finally {
            Ze = t,
            Xh = !1
        }
    }
    return null
}
var Ga = []
  , Ya = 0
  , nf = null
  , sf = 0
  , Hr = []
  , Zr = 0
  , ca = null
  , rs = 1
  , ns = "";
function Ri(e, t) {
    Ga[Ya++] = sf,
    Ga[Ya++] = nf,
    nf = e,
    sf = t
}
function C2(e, t, r) {
    Hr[Zr++] = rs,
    Hr[Zr++] = ns,
    Hr[Zr++] = ca,
    ca = e;
    var n = rs;
    e = ns;
    var s = 32 - xn(n) - 1;
    n &= ~(1 << s),
    r += 1;
    var i = 32 - xn(t) + s;
    if (30 < i) {
        var a = s - s % 5;
        i = (n & (1 << a) - 1).toString(32),
        n >>= a,
        s -= a,
        rs = 1 << 32 - xn(t) + s | r << s | n,
        ns = i + e
    } else
        rs = 1 << i | r << s | n,
        ns = e
}
function xg(e) {
    e.return !== null && (Ri(e, 1),
    C2(e, 1, 0))
}
function wg(e) {
    for (; e === nf; )
        nf = Ga[--Ya],
        Ga[Ya] = null,
        sf = Ga[--Ya],
        Ga[Ya] = null;
    for (; e === ca; )
        ca = Hr[--Zr],
        Hr[Zr] = null,
        ns = Hr[--Zr],
        Hr[Zr] = null,
        rs = Hr[--Zr],
        Hr[Zr] = null
}
var Lr = null
  , Mr = null
  , it = !1
  , mn = null;
function P2(e, t) {
    var r = Gr(5, null, null, 0);
    r.elementType = "DELETED",
    r.stateNode = t,
    r.return = e,
    t = e.deletions,
    t === null ? (e.deletions = [r],
    e.flags |= 16) : t.push(r)
}
function kb(e, t) {
    switch (e.tag) {
    case 5:
        var r = e.type;
        return t = t.nodeType !== 1 || r.toLowerCase() !== t.nodeName.toLowerCase() ? null : t,
        t !== null ? (e.stateNode = t,
        Lr = e,
        Mr = ti(t.firstChild),
        !0) : !1;
    case 6:
        return t = e.pendingProps === "" || t.nodeType !== 3 ? null : t,
        t !== null ? (e.stateNode = t,
        Lr = e,
        Mr = null,
        !0) : !1;
    case 13:
        return t = t.nodeType !== 8 ? null : t,
        t !== null ? (r = ca !== null ? {
            id: rs,
            overflow: ns
        } : null,
        e.memoizedState = {
            dehydrated: t,
            treeContext: r,
            retryLane: 1073741824
        },
        r = Gr(18, null, null, 0),
        r.stateNode = t,
        r.return = e,
        e.child = r,
        Lr = e,
        Mr = null,
        !0) : !1;
    default:
        return !1
    }
}
function Ip(e) {
    return (e.mode & 1) !== 0 && (e.flags & 128) === 0
}
function Rp(e) {
    if (it) {
        var t = Mr;
        if (t) {
            var r = t;
            if (!kb(e, t)) {
                if (Ip(e))
                    throw Error(V(418));
                t = ti(r.nextSibling);
                var n = Lr;
                t && kb(e, t) ? P2(n, r) : (e.flags = e.flags & -4097 | 2,
                it = !1,
                Lr = e)
            }
        } else {
            if (Ip(e))
                throw Error(V(418));
            e.flags = e.flags & -4097 | 2,
            it = !1,
            Lr = e
        }
    }
}
function Eb(e) {
    for (e = e.return; e !== null && e.tag !== 5 && e.tag !== 3 && e.tag !== 13; )
        e = e.return;
    Lr = e
}
function zc(e) {
    if (e !== Lr)
        return !1;
    if (!it)
        return Eb(e),
        it = !0,
        !1;
    var t;
    if ((t = e.tag !== 3) && !(t = e.tag !== 5) && (t = e.type,
    t = t !== "head" && t !== "body" && !Pp(e.type, e.memoizedProps)),
    t && (t = Mr)) {
        if (Ip(e))
            throw $2(),
            Error(V(418));
        for (; t; )
            P2(e, t),
            t = ti(t.nextSibling)
    }
    if (Eb(e),
    e.tag === 13) {
        if (e = e.memoizedState,
        e = e !== null ? e.dehydrated : null,
        !e)
            throw Error(V(317));
        e: {
            for (e = e.nextSibling,
            t = 0; e; ) {
                if (e.nodeType === 8) {
                    var r = e.data;
                    if (r === "/$") {
                        if (t === 0) {
                            Mr = ti(e.nextSibling);
                            break e
                        }
                        t--
                    } else
                        r !== "$" && r !== "$!" && r !== "$?" || t++
                }
                e = e.nextSibling
            }
            Mr = null
        }
    } else
        Mr = Lr ? ti(e.stateNode.nextSibling) : null;
    return !0
}
function $2() {
    for (var e = Mr; e; )
        e = ti(e.nextSibling)
}
function Ro() {
    Mr = Lr = null,
    it = !1
}
function Sg(e) {
    mn === null ? mn = [e] : mn.push(e)
}
var TF = vs.ReactCurrentBatchConfig;
function bl(e, t, r) {
    if (e = r.ref,
    e !== null && typeof e != "function" && typeof e != "object") {
        if (r._owner) {
            if (r = r._owner,
            r) {
                if (r.tag !== 1)
                    throw Error(V(309));
                var n = r.stateNode
            }
            if (!n)
                throw Error(V(147, e));
            var s = n
              , i = "" + e;
            return t !== null && t.ref !== null && typeof t.ref == "function" && t.ref._stringRef === i ? t.ref : (t = function(a) {
                var o = s.refs;
                a === null ? delete o[i] : o[i] = a
            }
            ,
            t._stringRef = i,
            t)
        }
        if (typeof e != "string")
            throw Error(V(284));
        if (!r._owner)
            throw Error(V(290, e))
    }
    return e
}
function Uc(e, t) {
    throw e = Object.prototype.toString.call(t),
    Error(V(31, e === "[object Object]" ? "object with keys {" + Object.keys(t).join(", ") + "}" : e))
}
function _b(e) {
    var t = e._init;
    return t(e._payload)
}
function N2(e) {
    function t(v, p) {
        if (e) {
            var S = v.deletions;
            S === null ? (v.deletions = [p],
            v.flags |= 16) : S.push(p)
        }
    }
    function r(v, p) {
        if (!e)
            return null;
        for (; p !== null; )
            t(v, p),
            p = p.sibling;
        return null
    }
    function n(v, p) {
        for (v = new Map; p !== null; )
            p.key !== null ? v.set(p.key, p) : v.set(p.index, p),
            p = p.sibling;
        return v
    }
    function s(v, p) {
        return v = ii(v, p),
        v.index = 0,
        v.sibling = null,
        v
    }
    function i(v, p, S) {
        return v.index = S,
        e ? (S = v.alternate,
        S !== null ? (S = S.index,
        S < p ? (v.flags |= 2,
        p) : S) : (v.flags |= 2,
        p)) : (v.flags |= 1048576,
        p)
    }
    function a(v) {
        return e && v.alternate === null && (v.flags |= 2),
        v
    }
    function o(v, p, S, P) {
        return p === null || p.tag !== 6 ? (p = am(S, v.mode, P),
        p.return = v,
        p) : (p = s(p, S),
        p.return = v,
        p)
    }
    function l(v, p, S, P) {
        var j = S.type;
        return j === Wa ? f(v, p, S.props.children, P, S.key) : p !== null && (p.elementType === j || typeof j == "object" && j !== null && j.$$typeof === js && _b(j) === p.type) ? (P = s(p, S.props),
        P.ref = bl(v, p, S),
        P.return = v,
        P) : (P = gd(S.type, S.key, S.props, null, v.mode, P),
        P.ref = bl(v, p, S),
        P.return = v,
        P)
    }
    function c(v, p, S, P) {
        return p === null || p.tag !== 4 || p.stateNode.containerInfo !== S.containerInfo || p.stateNode.implementation !== S.implementation ? (p = om(S, v.mode, P),
        p.return = v,
        p) : (p = s(p, S.children || []),
        p.return = v,
        p)
    }
    function f(v, p, S, P, j) {
        return p === null || p.tag !== 7 ? (p = ta(S, v.mode, P, j),
        p.return = v,
        p) : (p = s(p, S),
        p.return = v,
        p)
    }
    function h(v, p, S) {
        if (typeof p == "string" && p !== "" || typeof p == "number")
            return p = am("" + p, v.mode, S),
            p.return = v,
            p;
        if (typeof p == "object" && p !== null) {
            switch (p.$$typeof) {
            case Nc:
                return S = gd(p.type, p.key, p.props, null, v.mode, S),
                S.ref = bl(v, null, p),
                S.return = v,
                S;
            case Ba:
                return p = om(p, v.mode, S),
                p.return = v,
                p;
            case js:
                var P = p._init;
                return h(v, P(p._payload), S)
            }
            if (Ol(p) || ml(p))
                return p = ta(p, v.mode, S, null),
                p.return = v,
                p;
            Uc(v, p)
        }
        return null
    }
    function m(v, p, S, P) {
        var j = p !== null ? p.key : null;
        if (typeof S == "string" && S !== "" || typeof S == "number")
            return j !== null ? null : o(v, p, "" + S, P);
        if (typeof S == "object" && S !== null) {
            switch (S.$$typeof) {
            case Nc:
                return S.key === j ? l(v, p, S, P) : null;
            case Ba:
                return S.key === j ? c(v, p, S, P) : null;
            case js:
                return j = S._init,
                m(v, p, j(S._payload), P)
            }
            if (Ol(S) || ml(S))
                return j !== null ? null : f(v, p, S, P, null);
            Uc(v, S)
        }
        return null
    }
    function y(v, p, S, P, j) {
        if (typeof P == "string" && P !== "" || typeof P == "number")
            return v = v.get(S) || null,
            o(p, v, "" + P, j);
        if (typeof P == "object" && P !== null) {
            switch (P.$$typeof) {
            case Nc:
                return v = v.get(P.key === null ? S : P.key) || null,
                l(p, v, P, j);
            case Ba:
                return v = v.get(P.key === null ? S : P.key) || null,
                c(p, v, P, j);
            case js:
                var L = P._init;
                return y(v, p, S, L(P._payload), j)
            }
            if (Ol(P) || ml(P))
                return v = v.get(S) || null,
                f(p, v, P, j, null);
            Uc(p, P)
        }
        return null
    }
    function k(v, p, S, P) {
        for (var j = null, L = null, E = p, b = p = 0, O = null; E !== null && b < S.length; b++) {
            E.index > b ? (O = E,
            E = null) : O = E.sibling;
            var M = m(v, E, S[b], P);
            if (M === null) {
                E === null && (E = O);
                break
            }
            e && E && M.alternate === null && t(v, E),
            p = i(M, p, b),
            L === null ? j = M : L.sibling = M,
            L = M,
            E = O
        }
        if (b === S.length)
            return r(v, E),
            it && Ri(v, b),
            j;
        if (E === null) {
            for (; b < S.length; b++)
                E = h(v, S[b], P),
                E !== null && (p = i(E, p, b),
                L === null ? j = E : L.sibling = E,
                L = E);
            return it && Ri(v, b),
            j
        }
        for (E = n(v, E); b < S.length; b++)
            O = y(E, v, b, S[b], P),
            O !== null && (e && O.alternate !== null && E.delete(O.key === null ? b : O.key),
            p = i(O, p, b),
            L === null ? j = O : L.sibling = O,
            L = O);
        return e && E.forEach(function(D) {
            return t(v, D)
        }),
        it && Ri(v, b),
        j
    }
    function x(v, p, S, P) {
        var j = ml(S);
        if (typeof j != "function")
            throw Error(V(150));
        if (S = j.call(S),
        S == null)
            throw Error(V(151));
        for (var L = j = null, E = p, b = p = 0, O = null, M = S.next(); E !== null && !M.done; b++,
        M = S.next()) {
            E.index > b ? (O = E,
            E = null) : O = E.sibling;
            var D = m(v, E, M.value, P);
            if (D === null) {
                E === null && (E = O);
                break
            }
            e && E && D.alternate === null && t(v, E),
            p = i(D, p, b),
            L === null ? j = D : L.sibling = D,
            L = D,
            E = O
        }
        if (M.done)
            return r(v, E),
            it && Ri(v, b),
            j;
        if (E === null) {
            for (; !M.done; b++,
            M = S.next())
                M = h(v, M.value, P),
                M !== null && (p = i(M, p, b),
                L === null ? j = M : L.sibling = M,
                L = M);
            return it && Ri(v, b),
            j
        }
        for (E = n(v, E); !M.done; b++,
        M = S.next())
            M = y(E, v, b, M.value, P),
            M !== null && (e && M.alternate !== null && E.delete(M.key === null ? b : M.key),
            p = i(M, p, b),
            L === null ? j = M : L.sibling = M,
            L = M);
        return e && E.forEach(function(z) {
            return t(v, z)
        }),
        it && Ri(v, b),
        j
    }
    function w(v, p, S, P) {
        if (typeof S == "object" && S !== null && S.type === Wa && S.key === null && (S = S.props.children),
        typeof S == "object" && S !== null) {
            switch (S.$$typeof) {
            case Nc:
                e: {
                    for (var j = S.key, L = p; L !== null; ) {
                        if (L.key === j) {
                            if (j = S.type,
                            j === Wa) {
                                if (L.tag === 7) {
                                    r(v, L.sibling),
                                    p = s(L, S.props.children),
                                    p.return = v,
                                    v = p;
                                    break e
                                }
                            } else if (L.elementType === j || typeof j == "object" && j !== null && j.$$typeof === js && _b(j) === L.type) {
                                r(v, L.sibling),
                                p = s(L, S.props),
                                p.ref = bl(v, L, S),
                                p.return = v,
                                v = p;
                                break e
                            }
                            r(v, L);
                            break
                        } else
                            t(v, L);
                        L = L.sibling
                    }
                    S.type === Wa ? (p = ta(S.props.children, v.mode, P, S.key),
                    p.return = v,
                    v = p) : (P = gd(S.type, S.key, S.props, null, v.mode, P),
                    P.ref = bl(v, p, S),
                    P.return = v,
                    v = P)
                }
                return a(v);
            case Ba:
                e: {
                    for (L = S.key; p !== null; ) {
                        if (p.key === L)
                            if (p.tag === 4 && p.stateNode.containerInfo === S.containerInfo && p.stateNode.implementation === S.implementation) {
                                r(v, p.sibling),
                                p = s(p, S.children || []),
                                p.return = v,
                                v = p;
                                break e
                            } else {
                                r(v, p);
                                break
                            }
                        else
                            t(v, p);
                        p = p.sibling
                    }
                    p = om(S, v.mode, P),
                    p.return = v,
                    v = p
                }
                return a(v);
            case js:
                return L = S._init,
                w(v, p, L(S._payload), P)
            }
            if (Ol(S))
                return k(v, p, S, P);
            if (ml(S))
                return x(v, p, S, P);
            Uc(v, S)
        }
        return typeof S == "string" && S !== "" || typeof S == "number" ? (S = "" + S,
        p !== null && p.tag === 6 ? (r(v, p.sibling),
        p = s(p, S),
        p.return = v,
        v = p) : (r(v, p),
        p = am(S, v.mode, P),
        p.return = v,
        v = p),
        a(v)) : r(v, p)
    }
    return w
}
var Oo = N2(!0)
  , j2 = N2(!1)
  , af = bi(null)
  , of = null
  , Ja = null
  , kg = null;
function Eg() {
    kg = Ja = of = null
}
function _g(e) {
    var t = af.current;
    rt(af),
    e._currentValue = t
}
function Op(e, t, r) {
    for (; e !== null; ) {
        var n = e.alternate;
        if ((e.childLanes & t) !== t ? (e.childLanes |= t,
        n !== null && (n.childLanes |= t)) : n !== null && (n.childLanes & t) !== t && (n.childLanes |= t),
        e === r)
            break;
        e = e.return
    }
}
function uo(e, t) {
    of = e,
    kg = Ja = null,
    e = e.dependencies,
    e !== null && e.firstContext !== null && (e.lanes & t && (Cr = !0),
    e.firstContext = null)
}
function en(e) {
    var t = e._currentValue;
    if (kg !== e)
        if (e = {
            context: e,
            memoizedValue: t,
            next: null
        },
        Ja === null) {
            if (of === null)
                throw Error(V(308));
            Ja = e,
            of.dependencies = {
                lanes: 0,
                firstContext: e
            }
        } else
            Ja = Ja.next = e;
    return t
}
var Di = null;
function Tg(e) {
    Di === null ? Di = [e] : Di.push(e)
}
function I2(e, t, r, n) {
    var s = t.interleaved;
    return s === null ? (r.next = r,
    Tg(t)) : (r.next = s.next,
    s.next = r),
    t.interleaved = r,
    ds(e, n)
}
function ds(e, t) {
    e.lanes |= t;
    var r = e.alternate;
    for (r !== null && (r.lanes |= t),
    r = e,
    e = e.return; e !== null; )
        e.childLanes |= t,
        r = e.alternate,
        r !== null && (r.childLanes |= t),
        r = e,
        e = e.return;
    return r.tag === 3 ? r.stateNode : null
}
var Is = !1;
function Cg(e) {
    e.updateQueue = {
        baseState: e.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
            pending: null,
            interleaved: null,
            lanes: 0
        },
        effects: null
    }
}
function R2(e, t) {
    e = e.updateQueue,
    t.updateQueue === e && (t.updateQueue = {
        baseState: e.baseState,
        firstBaseUpdate: e.firstBaseUpdate,
        lastBaseUpdate: e.lastBaseUpdate,
        shared: e.shared,
        effects: e.effects
    })
}
function ss(e, t) {
    return {
        eventTime: e,
        lane: t,
        tag: 0,
        payload: null,
        callback: null,
        next: null
    }
}
function ri(e, t, r) {
    var n = e.updateQueue;
    if (n === null)
        return null;
    if (n = n.shared,
    Ae & 2) {
        var s = n.pending;
        return s === null ? t.next = t : (t.next = s.next,
        s.next = t),
        n.pending = t,
        ds(e, r)
    }
    return s = n.interleaved,
    s === null ? (t.next = t,
    Tg(n)) : (t.next = s.next,
    s.next = t),
    n.interleaved = t,
    ds(e, r)
}
function dd(e, t, r) {
    if (t = t.updateQueue,
    t !== null && (t = t.shared,
    (r & 4194240) !== 0)) {
        var n = t.lanes;
        n &= e.pendingLanes,
        r |= n,
        t.lanes = r,
        fg(e, r)
    }
}
function Tb(e, t) {
    var r = e.updateQueue
      , n = e.alternate;
    if (n !== null && (n = n.updateQueue,
    r === n)) {
        var s = null
          , i = null;
        if (r = r.firstBaseUpdate,
        r !== null) {
            do {
                var a = {
                    eventTime: r.eventTime,
                    lane: r.lane,
                    tag: r.tag,
                    payload: r.payload,
                    callback: r.callback,
                    next: null
                };
                i === null ? s = i = a : i = i.next = a,
                r = r.next
            } while (r !== null);
            i === null ? s = i = t : i = i.next = t
        } else
            s = i = t;
        r = {
            baseState: n.baseState,
            firstBaseUpdate: s,
            lastBaseUpdate: i,
            shared: n.shared,
            effects: n.effects
        },
        e.updateQueue = r;
        return
    }
    e = r.lastBaseUpdate,
    e === null ? r.firstBaseUpdate = t : e.next = t,
    r.lastBaseUpdate = t
}
function lf(e, t, r, n) {
    var s = e.updateQueue;
    Is = !1;
    var i = s.firstBaseUpdate
      , a = s.lastBaseUpdate
      , o = s.shared.pending;
    if (o !== null) {
        s.shared.pending = null;
        var l = o
          , c = l.next;
        l.next = null,
        a === null ? i = c : a.next = c,
        a = l;
        var f = e.alternate;
        f !== null && (f = f.updateQueue,
        o = f.lastBaseUpdate,
        o !== a && (o === null ? f.firstBaseUpdate = c : o.next = c,
        f.lastBaseUpdate = l))
    }
    if (i !== null) {
        var h = s.baseState;
        a = 0,
        f = c = l = null,
        o = i;
        do {
            var m = o.lane
              , y = o.eventTime;
            if ((n & m) === m) {
                f !== null && (f = f.next = {
                    eventTime: y,
                    lane: 0,
                    tag: o.tag,
                    payload: o.payload,
                    callback: o.callback,
                    next: null
                });
                e: {
                    var k = e
                      , x = o;
                    switch (m = t,
                    y = r,
                    x.tag) {
                    case 1:
                        if (k = x.payload,
                        typeof k == "function") {
                            h = k.call(y, h, m);
                            break e
                        }
                        h = k;
                        break e;
                    case 3:
                        k.flags = k.flags & -65537 | 128;
                    case 0:
                        if (k = x.payload,
                        m = typeof k == "function" ? k.call(y, h, m) : k,
                        m == null)
                            break e;
                        h = dt({}, h, m);
                        break e;
                    case 2:
                        Is = !0
                    }
                }
                o.callback !== null && o.lane !== 0 && (e.flags |= 64,
                m = s.effects,
                m === null ? s.effects = [o] : m.push(o))
            } else
                y = {
                    eventTime: y,
                    lane: m,
                    tag: o.tag,
                    payload: o.payload,
                    callback: o.callback,
                    next: null
                },
                f === null ? (c = f = y,
                l = h) : f = f.next = y,
                a |= m;
            if (o = o.next,
            o === null) {
                if (o = s.shared.pending,
                o === null)
                    break;
                m = o,
                o = m.next,
                m.next = null,
                s.lastBaseUpdate = m,
                s.shared.pending = null
            }
        } while (!0);
        if (f === null && (l = h),
        s.baseState = l,
        s.firstBaseUpdate = c,
        s.lastBaseUpdate = f,
        t = s.shared.interleaved,
        t !== null) {
            s = t;
            do
                a |= s.lane,
                s = s.next;
            while (s !== t)
        } else
            i === null && (s.shared.lanes = 0);
        fa |= a,
        e.lanes = a,
        e.memoizedState = h
    }
}
function Cb(e, t, r) {
    if (e = t.effects,
    t.effects = null,
    e !== null)
        for (t = 0; t < e.length; t++) {
            var n = e[t]
              , s = n.callback;
            if (s !== null) {
                if (n.callback = null,
                n = r,
                typeof s != "function")
                    throw Error(V(191, s));
                s.call(n)
            }
        }
}
var rc = {}
  , Un = bi(rc)
  , Nu = bi(rc)
  , ju = bi(rc);
function Fi(e) {
    if (e === rc)
        throw Error(V(174));
    return e
}
function Pg(e, t) {
    switch (Ye(ju, t),
    Ye(Nu, e),
    Ye(Un, rc),
    e = t.nodeType,
    e) {
    case 9:
    case 11:
        t = (t = t.documentElement) ? t.namespaceURI : mp(null, "");
        break;
    default:
        e = e === 8 ? t.parentNode : t,
        t = e.namespaceURI || null,
        e = e.tagName,
        t = mp(t, e)
    }
    rt(Un),
    Ye(Un, t)
}
function Mo() {
    rt(Un),
    rt(Nu),
    rt(ju)
}
function O2(e) {
    Fi(ju.current);
    var t = Fi(Un.current)
      , r = mp(t, e.type);
    t !== r && (Ye(Nu, e),
    Ye(Un, r))
}
function $g(e) {
    Nu.current === e && (rt(Un),
    rt(Nu))
}
var lt = bi(0);
function uf(e) {
    for (var t = e; t !== null; ) {
        if (t.tag === 13) {
            var r = t.memoizedState;
            if (r !== null && (r = r.dehydrated,
            r === null || r.data === "$?" || r.data === "$!"))
                return t
        } else if (t.tag === 19 && t.memoizedProps.revealOrder !== void 0) {
            if (t.flags & 128)
                return t
        } else if (t.child !== null) {
            t.child.return = t,
            t = t.child;
            continue
        }
        if (t === e)
            break;
        for (; t.sibling === null; ) {
            if (t.return === null || t.return === e)
                return null;
            t = t.return
        }
        t.sibling.return = t.return,
        t = t.sibling
    }
    return null
}
var em = [];
function Ng() {
    for (var e = 0; e < em.length; e++)
        em[e]._workInProgressVersionPrimary = null;
    em.length = 0
}
var fd = vs.ReactCurrentDispatcher
  , tm = vs.ReactCurrentBatchConfig
  , da = 0
  , ut = null
  , Ot = null
  , Lt = null
  , cf = !1
  , Kl = !1
  , Iu = 0
  , CF = 0;
function Gt() {
    throw Error(V(321))
}
function jg(e, t) {
    if (t === null)
        return !1;
    for (var r = 0; r < t.length && r < e.length; r++)
        if (!kn(e[r], t[r]))
            return !1;
    return !0
}
function Ig(e, t, r, n, s, i) {
    if (da = i,
    ut = t,
    t.memoizedState = null,
    t.updateQueue = null,
    t.lanes = 0,
    fd.current = e === null || e.memoizedState === null ? jF : IF,
    e = r(n, s),
    Kl) {
        i = 0;
        do {
            if (Kl = !1,
            Iu = 0,
            25 <= i)
                throw Error(V(301));
            i += 1,
            Lt = Ot = null,
            t.updateQueue = null,
            fd.current = RF,
            e = r(n, s)
        } while (Kl)
    }
    if (fd.current = df,
    t = Ot !== null && Ot.next !== null,
    da = 0,
    Lt = Ot = ut = null,
    cf = !1,
    t)
        throw Error(V(300));
    return e
}
function Rg() {
    var e = Iu !== 0;
    return Iu = 0,
    e
}
function $n() {
    var e = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
    };
    return Lt === null ? ut.memoizedState = Lt = e : Lt = Lt.next = e,
    Lt
}
function tn() {
    if (Ot === null) {
        var e = ut.alternate;
        e = e !== null ? e.memoizedState : null
    } else
        e = Ot.next;
    var t = Lt === null ? ut.memoizedState : Lt.next;
    if (t !== null)
        Lt = t,
        Ot = e;
    else {
        if (e === null)
            throw Error(V(310));
        Ot = e,
        e = {
            memoizedState: Ot.memoizedState,
            baseState: Ot.baseState,
            baseQueue: Ot.baseQueue,
            queue: Ot.queue,
            next: null
        },
        Lt === null ? ut.memoizedState = Lt = e : Lt = Lt.next = e
    }
    return Lt
}
function Ru(e, t) {
    return typeof t == "function" ? t(e) : t
}
function rm(e) {
    var t = tn()
      , r = t.queue;
    if (r === null)
        throw Error(V(311));
    r.lastRenderedReducer = e;
    var n = Ot
      , s = n.baseQueue
      , i = r.pending;
    if (i !== null) {
        if (s !== null) {
            var a = s.next;
            s.next = i.next,
            i.next = a
        }
        n.baseQueue = s = i,
        r.pending = null
    }
    if (s !== null) {
        i = s.next,
        n = n.baseState;
        var o = a = null
          , l = null
          , c = i;
        do {
            var f = c.lane;
            if ((da & f) === f)
                l !== null && (l = l.next = {
                    lane: 0,
                    action: c.action,
                    hasEagerState: c.hasEagerState,
                    eagerState: c.eagerState,
                    next: null
                }),
                n = c.hasEagerState ? c.eagerState : e(n, c.action);
            else {
                var h = {
                    lane: f,
                    action: c.action,
                    hasEagerState: c.hasEagerState,
                    eagerState: c.eagerState,
                    next: null
                };
                l === null ? (o = l = h,
                a = n) : l = l.next = h,
                ut.lanes |= f,
                fa |= f
            }
            c = c.next
        } while (c !== null && c !== i);
        l === null ? a = n : l.next = o,
        kn(n, t.memoizedState) || (Cr = !0),
        t.memoizedState = n,
        t.baseState = a,
        t.baseQueue = l,
        r.lastRenderedState = n
    }
    if (e = r.interleaved,
    e !== null) {
        s = e;
        do
            i = s.lane,
            ut.lanes |= i,
            fa |= i,
            s = s.next;
        while (s !== e)
    } else
        s === null && (r.lanes = 0);
    return [t.memoizedState, r.dispatch]
}
function nm(e) {
    var t = tn()
      , r = t.queue;
    if (r === null)
        throw Error(V(311));
    r.lastRenderedReducer = e;
    var n = r.dispatch
      , s = r.pending
      , i = t.memoizedState;
    if (s !== null) {
        r.pending = null;
        var a = s = s.next;
        do
            i = e(i, a.action),
            a = a.next;
        while (a !== s);
        kn(i, t.memoizedState) || (Cr = !0),
        t.memoizedState = i,
        t.baseQueue === null && (t.baseState = i),
        r.lastRenderedState = i
    }
    return [i, n]
}
function M2() {}
function A2(e, t) {
    var r = ut
      , n = tn()
      , s = t()
      , i = !kn(n.memoizedState, s);
    if (i && (n.memoizedState = s,
    Cr = !0),
    n = n.queue,
    Og(F2.bind(null, r, n, e), [e]),
    n.getSnapshot !== t || i || Lt !== null && Lt.memoizedState.tag & 1) {
        if (r.flags |= 2048,
        Ou(9, D2.bind(null, r, n, s, t), void 0, null),
        Dt === null)
            throw Error(V(349));
        da & 30 || L2(r, t, s)
    }
    return s
}
function L2(e, t, r) {
    e.flags |= 16384,
    e = {
        getSnapshot: t,
        value: r
    },
    t = ut.updateQueue,
    t === null ? (t = {
        lastEffect: null,
        stores: null
    },
    ut.updateQueue = t,
    t.stores = [e]) : (r = t.stores,
    r === null ? t.stores = [e] : r.push(e))
}
function D2(e, t, r, n) {
    t.value = r,
    t.getSnapshot = n,
    z2(t) && U2(e)
}
function F2(e, t, r) {
    return r(function() {
        z2(t) && U2(e)
    })
}
function z2(e) {
    var t = e.getSnapshot;
    e = e.value;
    try {
        var r = t();
        return !kn(e, r)
    } catch {
        return !0
    }
}
function U2(e) {
    var t = ds(e, 1);
    t !== null && wn(t, e, 1, -1)
}
function Pb(e) {
    var t = $n();
    return typeof e == "function" && (e = e()),
    t.memoizedState = t.baseState = e,
    e = {
        pending: null,
        interleaved: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: Ru,
        lastRenderedState: e
    },
    t.queue = e,
    e = e.dispatch = NF.bind(null, ut, e),
    [t.memoizedState, e]
}
function Ou(e, t, r, n) {
    return e = {
        tag: e,
        create: t,
        destroy: r,
        deps: n,
        next: null
    },
    t = ut.updateQueue,
    t === null ? (t = {
        lastEffect: null,
        stores: null
    },
    ut.updateQueue = t,
    t.lastEffect = e.next = e) : (r = t.lastEffect,
    r === null ? t.lastEffect = e.next = e : (n = r.next,
    r.next = e,
    e.next = n,
    t.lastEffect = e)),
    e
}
function V2() {
    return tn().memoizedState
}
function hd(e, t, r, n) {
    var s = $n();
    ut.flags |= e,
    s.memoizedState = Ou(1 | t, r, void 0, n === void 0 ? null : n)
}
function th(e, t, r, n) {
    var s = tn();
    n = n === void 0 ? null : n;
    var i = void 0;
    if (Ot !== null) {
        var a = Ot.memoizedState;
        if (i = a.destroy,
        n !== null && jg(n, a.deps)) {
            s.memoizedState = Ou(t, r, i, n);
            return
        }
    }
    ut.flags |= e,
    s.memoizedState = Ou(1 | t, r, i, n)
}
function $b(e, t) {
    return hd(8390656, 8, e, t)
}
function Og(e, t) {
    return th(2048, 8, e, t)
}
function B2(e, t) {
    return th(4, 2, e, t)
}
function W2(e, t) {
    return th(4, 4, e, t)
}
function q2(e, t) {
    if (typeof t == "function")
        return e = e(),
        t(e),
        function() {
            t(null)
        }
        ;
    if (t != null)
        return e = e(),
        t.current = e,
        function() {
            t.current = null
        }
}
function H2(e, t, r) {
    return r = r != null ? r.concat([e]) : null,
    th(4, 4, q2.bind(null, t, e), r)
}
function Mg() {}
function Z2(e, t) {
    var r = tn();
    t = t === void 0 ? null : t;
    var n = r.memoizedState;
    return n !== null && t !== null && jg(t, n[1]) ? n[0] : (r.memoizedState = [e, t],
    e)
}
function K2(e, t) {
    var r = tn();
    t = t === void 0 ? null : t;
    var n = r.memoizedState;
    return n !== null && t !== null && jg(t, n[1]) ? n[0] : (e = e(),
    r.memoizedState = [e, t],
    e)
}
function Q2(e, t, r) {
    return da & 21 ? (kn(r, t) || (r = e2(),
    ut.lanes |= r,
    fa |= r,
    e.baseState = !0),
    t) : (e.baseState && (e.baseState = !1,
    Cr = !0),
    e.memoizedState = r)
}
function PF(e, t) {
    var r = Ze;
    Ze = r !== 0 && 4 > r ? r : 4,
    e(!0);
    var n = tm.transition;
    tm.transition = {};
    try {
        e(!1),
        t()
    } finally {
        Ze = r,
        tm.transition = n
    }
}
function G2() {
    return tn().memoizedState
}
function $F(e, t, r) {
    var n = si(e);
    if (r = {
        lane: n,
        action: r,
        hasEagerState: !1,
        eagerState: null,
        next: null
    },
    Y2(e))
        J2(t, r);
    else if (r = I2(e, t, r, n),
    r !== null) {
        var s = yr();
        wn(r, e, n, s),
        X2(r, t, n)
    }
}
function NF(e, t, r) {
    var n = si(e)
      , s = {
        lane: n,
        action: r,
        hasEagerState: !1,
        eagerState: null,
        next: null
    };
    if (Y2(e))
        J2(t, s);
    else {
        var i = e.alternate;
        if (e.lanes === 0 && (i === null || i.lanes === 0) && (i = t.lastRenderedReducer,
        i !== null))
            try {
                var a = t.lastRenderedState
                  , o = i(a, r);
                if (s.hasEagerState = !0,
                s.eagerState = o,
                kn(o, a)) {
                    var l = t.interleaved;
                    l === null ? (s.next = s,
                    Tg(t)) : (s.next = l.next,
                    l.next = s),
                    t.interleaved = s;
                    return
                }
            } catch {} finally {}
        r = I2(e, t, s, n),
        r !== null && (s = yr(),
        wn(r, e, n, s),
        X2(r, t, n))
    }
}
function Y2(e) {
    var t = e.alternate;
    return e === ut || t !== null && t === ut
}
function J2(e, t) {
    Kl = cf = !0;
    var r = e.pending;
    r === null ? t.next = t : (t.next = r.next,
    r.next = t),
    e.pending = t
}
function X2(e, t, r) {
    if (r & 4194240) {
        var n = t.lanes;
        n &= e.pendingLanes,
        r |= n,
        t.lanes = r,
        fg(e, r)
    }
}
var df = {
    readContext: en,
    useCallback: Gt,
    useContext: Gt,
    useEffect: Gt,
    useImperativeHandle: Gt,
    useInsertionEffect: Gt,
    useLayoutEffect: Gt,
    useMemo: Gt,
    useReducer: Gt,
    useRef: Gt,
    useState: Gt,
    useDebugValue: Gt,
    useDeferredValue: Gt,
    useTransition: Gt,
    useMutableSource: Gt,
    useSyncExternalStore: Gt,
    useId: Gt,
    unstable_isNewReconciler: !1
}
  , jF = {
    readContext: en,
    useCallback: function(e, t) {
        return $n().memoizedState = [e, t === void 0 ? null : t],
        e
    },
    useContext: en,
    useEffect: $b,
    useImperativeHandle: function(e, t, r) {
        return r = r != null ? r.concat([e]) : null,
        hd(4194308, 4, q2.bind(null, t, e), r)
    },
    useLayoutEffect: function(e, t) {
        return hd(4194308, 4, e, t)
    },
    useInsertionEffect: function(e, t) {
        return hd(4, 2, e, t)
    },
    useMemo: function(e, t) {
        var r = $n();
        return t = t === void 0 ? null : t,
        e = e(),
        r.memoizedState = [e, t],
        e
    },
    useReducer: function(e, t, r) {
        var n = $n();
        return t = r !== void 0 ? r(t) : t,
        n.memoizedState = n.baseState = t,
        e = {
            pending: null,
            interleaved: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: e,
            lastRenderedState: t
        },
        n.queue = e,
        e = e.dispatch = $F.bind(null, ut, e),
        [n.memoizedState, e]
    },
    useRef: function(e) {
        var t = $n();
        return e = {
            current: e
        },
        t.memoizedState = e
    },
    useState: Pb,
    useDebugValue: Mg,
    useDeferredValue: function(e) {
        return $n().memoizedState = e
    },
    useTransition: function() {
        var e = Pb(!1)
          , t = e[0];
        return e = PF.bind(null, e[1]),
        $n().memoizedState = e,
        [t, e]
    },
    useMutableSource: function() {},
    useSyncExternalStore: function(e, t, r) {
        var n = ut
          , s = $n();
        if (it) {
            if (r === void 0)
                throw Error(V(407));
            r = r()
        } else {
            if (r = t(),
            Dt === null)
                throw Error(V(349));
            da & 30 || L2(n, t, r)
        }
        s.memoizedState = r;
        var i = {
            value: r,
            getSnapshot: t
        };
        return s.queue = i,
        $b(F2.bind(null, n, i, e), [e]),
        n.flags |= 2048,
        Ou(9, D2.bind(null, n, i, r, t), void 0, null),
        r
    },
    useId: function() {
        var e = $n()
          , t = Dt.identifierPrefix;
        if (it) {
            var r = ns
              , n = rs;
            r = (n & ~(1 << 32 - xn(n) - 1)).toString(32) + r,
            t = ":" + t + "R" + r,
            r = Iu++,
            0 < r && (t += "H" + r.toString(32)),
            t += ":"
        } else
            r = CF++,
            t = ":" + t + "r" + r.toString(32) + ":";
        return e.memoizedState = t
    },
    unstable_isNewReconciler: !1
}
  , IF = {
    readContext: en,
    useCallback: Z2,
    useContext: en,
    useEffect: Og,
    useImperativeHandle: H2,
    useInsertionEffect: B2,
    useLayoutEffect: W2,
    useMemo: K2,
    useReducer: rm,
    useRef: V2,
    useState: function() {
        return rm(Ru)
    },
    useDebugValue: Mg,
    useDeferredValue: function(e) {
        var t = tn();
        return Q2(t, Ot.memoizedState, e)
    },
    useTransition: function() {
        var e = rm(Ru)[0]
          , t = tn().memoizedState;
        return [e, t]
    },
    useMutableSource: M2,
    useSyncExternalStore: A2,
    useId: G2,
    unstable_isNewReconciler: !1
}
  , RF = {
    readContext: en,
    useCallback: Z2,
    useContext: en,
    useEffect: Og,
    useImperativeHandle: H2,
    useInsertionEffect: B2,
    useLayoutEffect: W2,
    useMemo: K2,
    useReducer: nm,
    useRef: V2,
    useState: function() {
        return nm(Ru)
    },
    useDebugValue: Mg,
    useDeferredValue: function(e) {
        var t = tn();
        return Ot === null ? t.memoizedState = e : Q2(t, Ot.memoizedState, e)
    },
    useTransition: function() {
        var e = nm(Ru)[0]
          , t = tn().memoizedState;
        return [e, t]
    },
    useMutableSource: M2,
    useSyncExternalStore: A2,
    useId: G2,
    unstable_isNewReconciler: !1
};
function ln(e, t) {
    if (e && e.defaultProps) {
        t = dt({}, t),
        e = e.defaultProps;
        for (var r in e)
            t[r] === void 0 && (t[r] = e[r]);
        return t
    }
    return t
}
function Mp(e, t, r, n) {
    t = e.memoizedState,
    r = r(n, t),
    r = r == null ? t : dt({}, t, r),
    e.memoizedState = r,
    e.lanes === 0 && (e.updateQueue.baseState = r)
}
var rh = {
    isMounted: function(e) {
        return (e = e._reactInternals) ? ba(e) === e : !1
    },
    enqueueSetState: function(e, t, r) {
        e = e._reactInternals;
        var n = yr()
          , s = si(e)
          , i = ss(n, s);
        i.payload = t,
        r != null && (i.callback = r),
        t = ri(e, i, s),
        t !== null && (wn(t, e, s, n),
        dd(t, e, s))
    },
    enqueueReplaceState: function(e, t, r) {
        e = e._reactInternals;
        var n = yr()
          , s = si(e)
          , i = ss(n, s);
        i.tag = 1,
        i.payload = t,
        r != null && (i.callback = r),
        t = ri(e, i, s),
        t !== null && (wn(t, e, s, n),
        dd(t, e, s))
    },
    enqueueForceUpdate: function(e, t) {
        e = e._reactInternals;
        var r = yr()
          , n = si(e)
          , s = ss(r, n);
        s.tag = 2,
        t != null && (s.callback = t),
        t = ri(e, s, n),
        t !== null && (wn(t, e, n, r),
        dd(t, e, n))
    }
};
function Nb(e, t, r, n, s, i, a) {
    return e = e.stateNode,
    typeof e.shouldComponentUpdate == "function" ? e.shouldComponentUpdate(n, i, a) : t.prototype && t.prototype.isPureReactComponent ? !Tu(r, n) || !Tu(s, i) : !0
}
function ek(e, t, r) {
    var n = !1
      , s = mi
      , i = t.contextType;
    return typeof i == "object" && i !== null ? i = en(i) : (s = $r(t) ? ua : sr.current,
    n = t.contextTypes,
    i = (n = n != null) ? Io(e, s) : mi),
    t = new t(r,i),
    e.memoizedState = t.state !== null && t.state !== void 0 ? t.state : null,
    t.updater = rh,
    e.stateNode = t,
    t._reactInternals = e,
    n && (e = e.stateNode,
    e.__reactInternalMemoizedUnmaskedChildContext = s,
    e.__reactInternalMemoizedMaskedChildContext = i),
    t
}
function jb(e, t, r, n) {
    e = t.state,
    typeof t.componentWillReceiveProps == "function" && t.componentWillReceiveProps(r, n),
    typeof t.UNSAFE_componentWillReceiveProps == "function" && t.UNSAFE_componentWillReceiveProps(r, n),
    t.state !== e && rh.enqueueReplaceState(t, t.state, null)
}
function Ap(e, t, r, n) {
    var s = e.stateNode;
    s.props = r,
    s.state = e.memoizedState,
    s.refs = {},
    Cg(e);
    var i = t.contextType;
    typeof i == "object" && i !== null ? s.context = en(i) : (i = $r(t) ? ua : sr.current,
    s.context = Io(e, i)),
    s.state = e.memoizedState,
    i = t.getDerivedStateFromProps,
    typeof i == "function" && (Mp(e, t, i, r),
    s.state = e.memoizedState),
    typeof t.getDerivedStateFromProps == "function" || typeof s.getSnapshotBeforeUpdate == "function" || typeof s.UNSAFE_componentWillMount != "function" && typeof s.componentWillMount != "function" || (t = s.state,
    typeof s.componentWillMount == "function" && s.componentWillMount(),
    typeof s.UNSAFE_componentWillMount == "function" && s.UNSAFE_componentWillMount(),
    t !== s.state && rh.enqueueReplaceState(s, s.state, null),
    lf(e, r, s, n),
    s.state = e.memoizedState),
    typeof s.componentDidMount == "function" && (e.flags |= 4194308)
}
function Ao(e, t) {
    try {
        var r = ""
          , n = t;
        do
            r += oD(n),
            n = n.return;
        while (n);
        var s = r
    } catch (i) {
        s = `
Error generating stack: ` + i.message + `
` + i.stack
    }
    return {
        value: e,
        source: t,
        stack: s,
        digest: null
    }
}
function sm(e, t, r) {
    return {
        value: e,
        source: null,
        stack: r ?? null,
        digest: t ?? null
    }
}
function Lp(e, t) {
    try {
        console.error(t.value)
    } catch (r) {
        setTimeout(function() {
            throw r
        })
    }
}
var OF = typeof WeakMap == "function" ? WeakMap : Map;
function tk(e, t, r) {
    r = ss(-1, r),
    r.tag = 3,
    r.payload = {
        element: null
    };
    var n = t.value;
    return r.callback = function() {
        hf || (hf = !0,
        Zp = n),
        Lp(e, t)
    }
    ,
    r
}
function rk(e, t, r) {
    r = ss(-1, r),
    r.tag = 3;
    var n = e.type.getDerivedStateFromError;
    if (typeof n == "function") {
        var s = t.value;
        r.payload = function() {
            return n(s)
        }
        ,
        r.callback = function() {
            Lp(e, t)
        }
    }
    var i = e.stateNode;
    return i !== null && typeof i.componentDidCatch == "function" && (r.callback = function() {
        Lp(e, t),
        typeof n != "function" && (ni === null ? ni = new Set([this]) : ni.add(this));
        var a = t.stack;
        this.componentDidCatch(t.value, {
            componentStack: a !== null ? a : ""
        })
    }
    ),
    r
}
function Ib(e, t, r) {
    var n = e.pingCache;
    if (n === null) {
        n = e.pingCache = new OF;
        var s = new Set;
        n.set(t, s)
    } else
        s = n.get(t),
        s === void 0 && (s = new Set,
        n.set(t, s));
    s.has(r) || (s.add(r),
    e = KF.bind(null, e, t, r),
    t.then(e, e))
}
function Rb(e) {
    do {
        var t;
        if ((t = e.tag === 13) && (t = e.memoizedState,
        t = t !== null ? t.dehydrated !== null : !0),
        t)
            return e;
        e = e.return
    } while (e !== null);
    return null
}
function Ob(e, t, r, n, s) {
    return e.mode & 1 ? (e.flags |= 65536,
    e.lanes = s,
    e) : (e === t ? e.flags |= 65536 : (e.flags |= 128,
    r.flags |= 131072,
    r.flags &= -52805,
    r.tag === 1 && (r.alternate === null ? r.tag = 17 : (t = ss(-1, 1),
    t.tag = 2,
    ri(r, t, 1))),
    r.lanes |= 1),
    e)
}
var MF = vs.ReactCurrentOwner
  , Cr = !1;
function cr(e, t, r, n) {
    t.child = e === null ? j2(t, null, r, n) : Oo(t, e.child, r, n)
}
function Mb(e, t, r, n, s) {
    r = r.render;
    var i = t.ref;
    return uo(t, s),
    n = Ig(e, t, r, n, i, s),
    r = Rg(),
    e !== null && !Cr ? (t.updateQueue = e.updateQueue,
    t.flags &= -2053,
    e.lanes &= ~s,
    fs(e, t, s)) : (it && r && xg(t),
    t.flags |= 1,
    cr(e, t, n, s),
    t.child)
}
function Ab(e, t, r, n, s) {
    if (e === null) {
        var i = r.type;
        return typeof i == "function" && !Bg(i) && i.defaultProps === void 0 && r.compare === null && r.defaultProps === void 0 ? (t.tag = 15,
        t.type = i,
        nk(e, t, i, n, s)) : (e = gd(r.type, null, n, t, t.mode, s),
        e.ref = t.ref,
        e.return = t,
        t.child = e)
    }
    if (i = e.child,
    !(e.lanes & s)) {
        var a = i.memoizedProps;
        if (r = r.compare,
        r = r !== null ? r : Tu,
        r(a, n) && e.ref === t.ref)
            return fs(e, t, s)
    }
    return t.flags |= 1,
    e = ii(i, n),
    e.ref = t.ref,
    e.return = t,
    t.child = e
}
function nk(e, t, r, n, s) {
    if (e !== null) {
        var i = e.memoizedProps;
        if (Tu(i, n) && e.ref === t.ref)
            if (Cr = !1,
            t.pendingProps = n = i,
            (e.lanes & s) !== 0)
                e.flags & 131072 && (Cr = !0);
            else
                return t.lanes = e.lanes,
                fs(e, t, s)
    }
    return Dp(e, t, r, n, s)
}
function sk(e, t, r) {
    var n = t.pendingProps
      , s = n.children
      , i = e !== null ? e.memoizedState : null;
    if (n.mode === "hidden")
        if (!(t.mode & 1))
            t.memoizedState = {
                baseLanes: 0,
                cachePool: null,
                transitions: null
            },
            Ye(eo, Rr),
            Rr |= r;
        else {
            if (!(r & 1073741824))
                return e = i !== null ? i.baseLanes | r : r,
                t.lanes = t.childLanes = 1073741824,
                t.memoizedState = {
                    baseLanes: e,
                    cachePool: null,
                    transitions: null
                },
                t.updateQueue = null,
                Ye(eo, Rr),
                Rr |= e,
                null;
            t.memoizedState = {
                baseLanes: 0,
                cachePool: null,
                transitions: null
            },
            n = i !== null ? i.baseLanes : r,
            Ye(eo, Rr),
            Rr |= n
        }
    else
        i !== null ? (n = i.baseLanes | r,
        t.memoizedState = null) : n = r,
        Ye(eo, Rr),
        Rr |= n;
    return cr(e, t, s, r),
    t.child
}
function ik(e, t) {
    var r = t.ref;
    (e === null && r !== null || e !== null && e.ref !== r) && (t.flags |= 512,
    t.flags |= 2097152)
}
function Dp(e, t, r, n, s) {
    var i = $r(r) ? ua : sr.current;
    return i = Io(t, i),
    uo(t, s),
    r = Ig(e, t, r, n, i, s),
    n = Rg(),
    e !== null && !Cr ? (t.updateQueue = e.updateQueue,
    t.flags &= -2053,
    e.lanes &= ~s,
    fs(e, t, s)) : (it && n && xg(t),
    t.flags |= 1,
    cr(e, t, r, s),
    t.child)
}
function Lb(e, t, r, n, s) {
    if ($r(r)) {
        var i = !0;
        rf(t)
    } else
        i = !1;
    if (uo(t, s),
    t.stateNode === null)
        md(e, t),
        ek(t, r, n),
        Ap(t, r, n, s),
        n = !0;
    else if (e === null) {
        var a = t.stateNode
          , o = t.memoizedProps;
        a.props = o;
        var l = a.context
          , c = r.contextType;
        typeof c == "object" && c !== null ? c = en(c) : (c = $r(r) ? ua : sr.current,
        c = Io(t, c));
        var f = r.getDerivedStateFromProps
          , h = typeof f == "function" || typeof a.getSnapshotBeforeUpdate == "function";
        h || typeof a.UNSAFE_componentWillReceiveProps != "function" && typeof a.componentWillReceiveProps != "function" || (o !== n || l !== c) && jb(t, a, n, c),
        Is = !1;
        var m = t.memoizedState;
        a.state = m,
        lf(t, n, a, s),
        l = t.memoizedState,
        o !== n || m !== l || Pr.current || Is ? (typeof f == "function" && (Mp(t, r, f, n),
        l = t.memoizedState),
        (o = Is || Nb(t, r, o, n, m, l, c)) ? (h || typeof a.UNSAFE_componentWillMount != "function" && typeof a.componentWillMount != "function" || (typeof a.componentWillMount == "function" && a.componentWillMount(),
        typeof a.UNSAFE_componentWillMount == "function" && a.UNSAFE_componentWillMount()),
        typeof a.componentDidMount == "function" && (t.flags |= 4194308)) : (typeof a.componentDidMount == "function" && (t.flags |= 4194308),
        t.memoizedProps = n,
        t.memoizedState = l),
        a.props = n,
        a.state = l,
        a.context = c,
        n = o) : (typeof a.componentDidMount == "function" && (t.flags |= 4194308),
        n = !1)
    } else {
        a = t.stateNode,
        R2(e, t),
        o = t.memoizedProps,
        c = t.type === t.elementType ? o : ln(t.type, o),
        a.props = c,
        h = t.pendingProps,
        m = a.context,
        l = r.contextType,
        typeof l == "object" && l !== null ? l = en(l) : (l = $r(r) ? ua : sr.current,
        l = Io(t, l));
        var y = r.getDerivedStateFromProps;
        (f = typeof y == "function" || typeof a.getSnapshotBeforeUpdate == "function") || typeof a.UNSAFE_componentWillReceiveProps != "function" && typeof a.componentWillReceiveProps != "function" || (o !== h || m !== l) && jb(t, a, n, l),
        Is = !1,
        m = t.memoizedState,
        a.state = m,
        lf(t, n, a, s);
        var k = t.memoizedState;
        o !== h || m !== k || Pr.current || Is ? (typeof y == "function" && (Mp(t, r, y, n),
        k = t.memoizedState),
        (c = Is || Nb(t, r, c, n, m, k, l) || !1) ? (f || typeof a.UNSAFE_componentWillUpdate != "function" && typeof a.componentWillUpdate != "function" || (typeof a.componentWillUpdate == "function" && a.componentWillUpdate(n, k, l),
        typeof a.UNSAFE_componentWillUpdate == "function" && a.UNSAFE_componentWillUpdate(n, k, l)),
        typeof a.componentDidUpdate == "function" && (t.flags |= 4),
        typeof a.getSnapshotBeforeUpdate == "function" && (t.flags |= 1024)) : (typeof a.componentDidUpdate != "function" || o === e.memoizedProps && m === e.memoizedState || (t.flags |= 4),
        typeof a.getSnapshotBeforeUpdate != "function" || o === e.memoizedProps && m === e.memoizedState || (t.flags |= 1024),
        t.memoizedProps = n,
        t.memoizedState = k),
        a.props = n,
        a.state = k,
        a.context = l,
        n = c) : (typeof a.componentDidUpdate != "function" || o === e.memoizedProps && m === e.memoizedState || (t.flags |= 4),
        typeof a.getSnapshotBeforeUpdate != "function" || o === e.memoizedProps && m === e.memoizedState || (t.flags |= 1024),
        n = !1)
    }
    return Fp(e, t, r, n, i, s)
}
function Fp(e, t, r, n, s, i) {
    ik(e, t);
    var a = (t.flags & 128) !== 0;
    if (!n && !a)
        return s && Sb(t, r, !1),
        fs(e, t, i);
    n = t.stateNode,
    MF.current = t;
    var o = a && typeof r.getDerivedStateFromError != "function" ? null : n.render();
    return t.flags |= 1,
    e !== null && a ? (t.child = Oo(t, e.child, null, i),
    t.child = Oo(t, null, o, i)) : cr(e, t, o, i),
    t.memoizedState = n.state,
    s && Sb(t, r, !0),
    t.child
}
function ak(e) {
    var t = e.stateNode;
    t.pendingContext ? wb(e, t.pendingContext, t.pendingContext !== t.context) : t.context && wb(e, t.context, !1),
    Pg(e, t.containerInfo)
}
function Db(e, t, r, n, s) {
    return Ro(),
    Sg(s),
    t.flags |= 256,
    cr(e, t, r, n),
    t.child
}
var zp = {
    dehydrated: null,
    treeContext: null,
    retryLane: 0
};
function Up(e) {
    return {
        baseLanes: e,
        cachePool: null,
        transitions: null
    }
}
function ok(e, t, r) {
    var n = t.pendingProps, s = lt.current, i = !1, a = (t.flags & 128) !== 0, o;
    if ((o = a) || (o = e !== null && e.memoizedState === null ? !1 : (s & 2) !== 0),
    o ? (i = !0,
    t.flags &= -129) : (e === null || e.memoizedState !== null) && (s |= 1),
    Ye(lt, s & 1),
    e === null)
        return Rp(t),
        e = t.memoizedState,
        e !== null && (e = e.dehydrated,
        e !== null) ? (t.mode & 1 ? e.data === "$!" ? t.lanes = 8 : t.lanes = 1073741824 : t.lanes = 1,
        null) : (a = n.children,
        e = n.fallback,
        i ? (n = t.mode,
        i = t.child,
        a = {
            mode: "hidden",
            children: a
        },
        !(n & 1) && i !== null ? (i.childLanes = 0,
        i.pendingProps = a) : i = ih(a, n, 0, null),
        e = ta(e, n, r, null),
        i.return = t,
        e.return = t,
        i.sibling = e,
        t.child = i,
        t.child.memoizedState = Up(r),
        t.memoizedState = zp,
        e) : Ag(t, a));
    if (s = e.memoizedState,
    s !== null && (o = s.dehydrated,
    o !== null))
        return AF(e, t, a, n, o, s, r);
    if (i) {
        i = n.fallback,
        a = t.mode,
        s = e.child,
        o = s.sibling;
        var l = {
            mode: "hidden",
            children: n.children
        };
        return !(a & 1) && t.child !== s ? (n = t.child,
        n.childLanes = 0,
        n.pendingProps = l,
        t.deletions = null) : (n = ii(s, l),
        n.subtreeFlags = s.subtreeFlags & 14680064),
        o !== null ? i = ii(o, i) : (i = ta(i, a, r, null),
        i.flags |= 2),
        i.return = t,
        n.return = t,
        n.sibling = i,
        t.child = n,
        n = i,
        i = t.child,
        a = e.child.memoizedState,
        a = a === null ? Up(r) : {
            baseLanes: a.baseLanes | r,
            cachePool: null,
            transitions: a.transitions
        },
        i.memoizedState = a,
        i.childLanes = e.childLanes & ~r,
        t.memoizedState = zp,
        n
    }
    return i = e.child,
    e = i.sibling,
    n = ii(i, {
        mode: "visible",
        children: n.children
    }),
    !(t.mode & 1) && (n.lanes = r),
    n.return = t,
    n.sibling = null,
    e !== null && (r = t.deletions,
    r === null ? (t.deletions = [e],
    t.flags |= 16) : r.push(e)),
    t.child = n,
    t.memoizedState = null,
    n
}
function Ag(e, t) {
    return t = ih({
        mode: "visible",
        children: t
    }, e.mode, 0, null),
    t.return = e,
    e.child = t
}
function Vc(e, t, r, n) {
    return n !== null && Sg(n),
    Oo(t, e.child, null, r),
    e = Ag(t, t.pendingProps.children),
    e.flags |= 2,
    t.memoizedState = null,
    e
}
function AF(e, t, r, n, s, i, a) {
    if (r)
        return t.flags & 256 ? (t.flags &= -257,
        n = sm(Error(V(422))),
        Vc(e, t, a, n)) : t.memoizedState !== null ? (t.child = e.child,
        t.flags |= 128,
        null) : (i = n.fallback,
        s = t.mode,
        n = ih({
            mode: "visible",
            children: n.children
        }, s, 0, null),
        i = ta(i, s, a, null),
        i.flags |= 2,
        n.return = t,
        i.return = t,
        n.sibling = i,
        t.child = n,
        t.mode & 1 && Oo(t, e.child, null, a),
        t.child.memoizedState = Up(a),
        t.memoizedState = zp,
        i);
    if (!(t.mode & 1))
        return Vc(e, t, a, null);
    if (s.data === "$!") {
        if (n = s.nextSibling && s.nextSibling.dataset,
        n)
            var o = n.dgst;
        return n = o,
        i = Error(V(419)),
        n = sm(i, n, void 0),
        Vc(e, t, a, n)
    }
    if (o = (a & e.childLanes) !== 0,
    Cr || o) {
        if (n = Dt,
        n !== null) {
            switch (a & -a) {
            case 4:
                s = 2;
                break;
            case 16:
                s = 8;
                break;
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
                s = 32;
                break;
            case 536870912:
                s = 268435456;
                break;
            default:
                s = 0
            }
            s = s & (n.suspendedLanes | a) ? 0 : s,
            s !== 0 && s !== i.retryLane && (i.retryLane = s,
            ds(e, s),
            wn(n, e, s, -1))
        }
        return Vg(),
        n = sm(Error(V(421))),
        Vc(e, t, a, n)
    }
    return s.data === "$?" ? (t.flags |= 128,
    t.child = e.child,
    t = QF.bind(null, e),
    s._reactRetry = t,
    null) : (e = i.treeContext,
    Mr = ti(s.nextSibling),
    Lr = t,
    it = !0,
    mn = null,
    e !== null && (Hr[Zr++] = rs,
    Hr[Zr++] = ns,
    Hr[Zr++] = ca,
    rs = e.id,
    ns = e.overflow,
    ca = t),
    t = Ag(t, n.children),
    t.flags |= 4096,
    t)
}
function Fb(e, t, r) {
    e.lanes |= t;
    var n = e.alternate;
    n !== null && (n.lanes |= t),
    Op(e.return, t, r)
}
function im(e, t, r, n, s) {
    var i = e.memoizedState;
    i === null ? e.memoizedState = {
        isBackwards: t,
        rendering: null,
        renderingStartTime: 0,
        last: n,
        tail: r,
        tailMode: s
    } : (i.isBackwards = t,
    i.rendering = null,
    i.renderingStartTime = 0,
    i.last = n,
    i.tail = r,
    i.tailMode = s)
}
function lk(e, t, r) {
    var n = t.pendingProps
      , s = n.revealOrder
      , i = n.tail;
    if (cr(e, t, n.children, r),
    n = lt.current,
    n & 2)
        n = n & 1 | 2,
        t.flags |= 128;
    else {
        if (e !== null && e.flags & 128)
            e: for (e = t.child; e !== null; ) {
                if (e.tag === 13)
                    e.memoizedState !== null && Fb(e, r, t);
                else if (e.tag === 19)
                    Fb(e, r, t);
                else if (e.child !== null) {
                    e.child.return = e,
                    e = e.child;
                    continue
                }
                if (e === t)
                    break e;
                for (; e.sibling === null; ) {
                    if (e.return === null || e.return === t)
                        break e;
                    e = e.return
                }
                e.sibling.return = e.return,
                e = e.sibling
            }
        n &= 1
    }
    if (Ye(lt, n),
    !(t.mode & 1))
        t.memoizedState = null;
    else
        switch (s) {
        case "forwards":
            for (r = t.child,
            s = null; r !== null; )
                e = r.alternate,
                e !== null && uf(e) === null && (s = r),
                r = r.sibling;
            r = s,
            r === null ? (s = t.child,
            t.child = null) : (s = r.sibling,
            r.sibling = null),
            im(t, !1, s, r, i);
            break;
        case "backwards":
            for (r = null,
            s = t.child,
            t.child = null; s !== null; ) {
                if (e = s.alternate,
                e !== null && uf(e) === null) {
                    t.child = s;
                    break
                }
                e = s.sibling,
                s.sibling = r,
                r = s,
                s = e
            }
            im(t, !0, r, null, i);
            break;
        case "together":
            im(t, !1, null, null, void 0);
            break;
        default:
            t.memoizedState = null
        }
    return t.child
}
function md(e, t) {
    !(t.mode & 1) && e !== null && (e.alternate = null,
    t.alternate = null,
    t.flags |= 2)
}
function fs(e, t, r) {
    if (e !== null && (t.dependencies = e.dependencies),
    fa |= t.lanes,
    !(r & t.childLanes))
        return null;
    if (e !== null && t.child !== e.child)
        throw Error(V(153));
    if (t.child !== null) {
        for (e = t.child,
        r = ii(e, e.pendingProps),
        t.child = r,
        r.return = t; e.sibling !== null; )
            e = e.sibling,
            r = r.sibling = ii(e, e.pendingProps),
            r.return = t;
        r.sibling = null
    }
    return t.child
}
function LF(e, t, r) {
    switch (t.tag) {
    case 3:
        ak(t),
        Ro();
        break;
    case 5:
        O2(t);
        break;
    case 1:
        $r(t.type) && rf(t);
        break;
    case 4:
        Pg(t, t.stateNode.containerInfo);
        break;
    case 10:
        var n = t.type._context
          , s = t.memoizedProps.value;
        Ye(af, n._currentValue),
        n._currentValue = s;
        break;
    case 13:
        if (n = t.memoizedState,
        n !== null)
            return n.dehydrated !== null ? (Ye(lt, lt.current & 1),
            t.flags |= 128,
            null) : r & t.child.childLanes ? ok(e, t, r) : (Ye(lt, lt.current & 1),
            e = fs(e, t, r),
            e !== null ? e.sibling : null);
        Ye(lt, lt.current & 1);
        break;
    case 19:
        if (n = (r & t.childLanes) !== 0,
        e.flags & 128) {
            if (n)
                return lk(e, t, r);
            t.flags |= 128
        }
        if (s = t.memoizedState,
        s !== null && (s.rendering = null,
        s.tail = null,
        s.lastEffect = null),
        Ye(lt, lt.current),
        n)
            break;
        return null;
    case 22:
    case 23:
        return t.lanes = 0,
        sk(e, t, r)
    }
    return fs(e, t, r)
}
var uk, Vp, ck, dk;
uk = function(e, t) {
    for (var r = t.child; r !== null; ) {
        if (r.tag === 5 || r.tag === 6)
            e.appendChild(r.stateNode);
        else if (r.tag !== 4 && r.child !== null) {
            r.child.return = r,
            r = r.child;
            continue
        }
        if (r === t)
            break;
        for (; r.sibling === null; ) {
            if (r.return === null || r.return === t)
                return;
            r = r.return
        }
        r.sibling.return = r.return,
        r = r.sibling
    }
}
;
Vp = function() {}
;
ck = function(e, t, r, n) {
    var s = e.memoizedProps;
    if (s !== n) {
        e = t.stateNode,
        Fi(Un.current);
        var i = null;
        switch (r) {
        case "input":
            s = cp(e, s),
            n = cp(e, n),
            i = [];
            break;
        case "select":
            s = dt({}, s, {
                value: void 0
            }),
            n = dt({}, n, {
                value: void 0
            }),
            i = [];
            break;
        case "textarea":
            s = hp(e, s),
            n = hp(e, n),
            i = [];
            break;
        default:
            typeof s.onClick != "function" && typeof n.onClick == "function" && (e.onclick = ef)
        }
        pp(r, n);
        var a;
        r = null;
        for (c in s)
            if (!n.hasOwnProperty(c) && s.hasOwnProperty(c) && s[c] != null)
                if (c === "style") {
                    var o = s[c];
                    for (a in o)
                        o.hasOwnProperty(a) && (r || (r = {}),
                        r[a] = "")
                } else
                    c !== "dangerouslySetInnerHTML" && c !== "children" && c !== "suppressContentEditableWarning" && c !== "suppressHydrationWarning" && c !== "autoFocus" && (bu.hasOwnProperty(c) ? i || (i = []) : (i = i || []).push(c, null));
        for (c in n) {
            var l = n[c];
            if (o = s != null ? s[c] : void 0,
            n.hasOwnProperty(c) && l !== o && (l != null || o != null))
                if (c === "style")
                    if (o) {
                        for (a in o)
                            !o.hasOwnProperty(a) || l && l.hasOwnProperty(a) || (r || (r = {}),
                            r[a] = "");
                        for (a in l)
                            l.hasOwnProperty(a) && o[a] !== l[a] && (r || (r = {}),
                            r[a] = l[a])
                    } else
                        r || (i || (i = []),
                        i.push(c, r)),
                        r = l;
                else
                    c === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0,
                    o = o ? o.__html : void 0,
                    l != null && o !== l && (i = i || []).push(c, l)) : c === "children" ? typeof l != "string" && typeof l != "number" || (i = i || []).push(c, "" + l) : c !== "suppressContentEditableWarning" && c !== "suppressHydrationWarning" && (bu.hasOwnProperty(c) ? (l != null && c === "onScroll" && Xe("scroll", e),
                    i || o === l || (i = [])) : (i = i || []).push(c, l))
        }
        r && (i = i || []).push("style", r);
        var c = i;
        (t.updateQueue = c) && (t.flags |= 4)
    }
}
;
dk = function(e, t, r, n) {
    r !== n && (t.flags |= 4)
}
;
function xl(e, t) {
    if (!it)
        switch (e.tailMode) {
        case "hidden":
            t = e.tail;
            for (var r = null; t !== null; )
                t.alternate !== null && (r = t),
                t = t.sibling;
            r === null ? e.tail = null : r.sibling = null;
            break;
        case "collapsed":
            r = e.tail;
            for (var n = null; r !== null; )
                r.alternate !== null && (n = r),
                r = r.sibling;
            n === null ? t || e.tail === null ? e.tail = null : e.tail.sibling = null : n.sibling = null
        }
}
function Yt(e) {
    var t = e.alternate !== null && e.alternate.child === e.child
      , r = 0
      , n = 0;
    if (t)
        for (var s = e.child; s !== null; )
            r |= s.lanes | s.childLanes,
            n |= s.subtreeFlags & 14680064,
            n |= s.flags & 14680064,
            s.return = e,
            s = s.sibling;
    else
        for (s = e.child; s !== null; )
            r |= s.lanes | s.childLanes,
            n |= s.subtreeFlags,
            n |= s.flags,
            s.return = e,
            s = s.sibling;
    return e.subtreeFlags |= n,
    e.childLanes = r,
    t
}
function DF(e, t, r) {
    var n = t.pendingProps;
    switch (wg(t),
    t.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
        return Yt(t),
        null;
    case 1:
        return $r(t.type) && tf(),
        Yt(t),
        null;
    case 3:
        return n = t.stateNode,
        Mo(),
        rt(Pr),
        rt(sr),
        Ng(),
        n.pendingContext && (n.context = n.pendingContext,
        n.pendingContext = null),
        (e === null || e.child === null) && (zc(t) ? t.flags |= 4 : e === null || e.memoizedState.isDehydrated && !(t.flags & 256) || (t.flags |= 1024,
        mn !== null && (Gp(mn),
        mn = null))),
        Vp(e, t),
        Yt(t),
        null;
    case 5:
        $g(t);
        var s = Fi(ju.current);
        if (r = t.type,
        e !== null && t.stateNode != null)
            ck(e, t, r, n, s),
            e.ref !== t.ref && (t.flags |= 512,
            t.flags |= 2097152);
        else {
            if (!n) {
                if (t.stateNode === null)
                    throw Error(V(166));
                return Yt(t),
                null
            }
            if (e = Fi(Un.current),
            zc(t)) {
                n = t.stateNode,
                r = t.type;
                var i = t.memoizedProps;
                switch (n[Mn] = t,
                n[$u] = i,
                e = (t.mode & 1) !== 0,
                r) {
                case "dialog":
                    Xe("cancel", n),
                    Xe("close", n);
                    break;
                case "iframe":
                case "object":
                case "embed":
                    Xe("load", n);
                    break;
                case "video":
                case "audio":
                    for (s = 0; s < Al.length; s++)
                        Xe(Al[s], n);
                    break;
                case "source":
                    Xe("error", n);
                    break;
                case "img":
                case "image":
                case "link":
                    Xe("error", n),
                    Xe("load", n);
                    break;
                case "details":
                    Xe("toggle", n);
                    break;
                case "input":
                    K0(n, i),
                    Xe("invalid", n);
                    break;
                case "select":
                    n._wrapperState = {
                        wasMultiple: !!i.multiple
                    },
                    Xe("invalid", n);
                    break;
                case "textarea":
                    G0(n, i),
                    Xe("invalid", n)
                }
                pp(r, i),
                s = null;
                for (var a in i)
                    if (i.hasOwnProperty(a)) {
                        var o = i[a];
                        a === "children" ? typeof o == "string" ? n.textContent !== o && (i.suppressHydrationWarning !== !0 && Fc(n.textContent, o, e),
                        s = ["children", o]) : typeof o == "number" && n.textContent !== "" + o && (i.suppressHydrationWarning !== !0 && Fc(n.textContent, o, e),
                        s = ["children", "" + o]) : bu.hasOwnProperty(a) && o != null && a === "onScroll" && Xe("scroll", n)
                    }
                switch (r) {
                case "input":
                    jc(n),
                    Q0(n, i, !0);
                    break;
                case "textarea":
                    jc(n),
                    Y0(n);
                    break;
                case "select":
                case "option":
                    break;
                default:
                    typeof i.onClick == "function" && (n.onclick = ef)
                }
                n = s,
                t.updateQueue = n,
                n !== null && (t.flags |= 4)
            } else {
                a = s.nodeType === 9 ? s : s.ownerDocument,
                e === "http://www.w3.org/1999/xhtml" && (e = FS(r)),
                e === "http://www.w3.org/1999/xhtml" ? r === "script" ? (e = a.createElement("div"),
                e.innerHTML = "<script><\/script>",
                e = e.removeChild(e.firstChild)) : typeof n.is == "string" ? e = a.createElement(r, {
                    is: n.is
                }) : (e = a.createElement(r),
                r === "select" && (a = e,
                n.multiple ? a.multiple = !0 : n.size && (a.size = n.size))) : e = a.createElementNS(e, r),
                e[Mn] = t,
                e[$u] = n,
                uk(e, t, !1, !1),
                t.stateNode = e;
                e: {
                    switch (a = yp(r, n),
                    r) {
                    case "dialog":
                        Xe("cancel", e),
                        Xe("close", e),
                        s = n;
                        break;
                    case "iframe":
                    case "object":
                    case "embed":
                        Xe("load", e),
                        s = n;
                        break;
                    case "video":
                    case "audio":
                        for (s = 0; s < Al.length; s++)
                            Xe(Al[s], e);
                        s = n;
                        break;
                    case "source":
                        Xe("error", e),
                        s = n;
                        break;
                    case "img":
                    case "image":
                    case "link":
                        Xe("error", e),
                        Xe("load", e),
                        s = n;
                        break;
                    case "details":
                        Xe("toggle", e),
                        s = n;
                        break;
                    case "input":
                        K0(e, n),
                        s = cp(e, n),
                        Xe("invalid", e);
                        break;
                    case "option":
                        s = n;
                        break;
                    case "select":
                        e._wrapperState = {
                            wasMultiple: !!n.multiple
                        },
                        s = dt({}, n, {
                            value: void 0
                        }),
                        Xe("invalid", e);
                        break;
                    case "textarea":
                        G0(e, n),
                        s = hp(e, n),
                        Xe("invalid", e);
                        break;
                    default:
                        s = n
                    }
                    pp(r, s),
                    o = s;
                    for (i in o)
                        if (o.hasOwnProperty(i)) {
                            var l = o[i];
                            i === "style" ? VS(e, l) : i === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0,
                            l != null && zS(e, l)) : i === "children" ? typeof l == "string" ? (r !== "textarea" || l !== "") && xu(e, l) : typeof l == "number" && xu(e, "" + l) : i !== "suppressContentEditableWarning" && i !== "suppressHydrationWarning" && i !== "autoFocus" && (bu.hasOwnProperty(i) ? l != null && i === "onScroll" && Xe("scroll", e) : l != null && ag(e, i, l, a))
                        }
                    switch (r) {
                    case "input":
                        jc(e),
                        Q0(e, n, !1);
                        break;
                    case "textarea":
                        jc(e),
                        Y0(e);
                        break;
                    case "option":
                        n.value != null && e.setAttribute("value", "" + hi(n.value));
                        break;
                    case "select":
                        e.multiple = !!n.multiple,
                        i = n.value,
                        i != null ? io(e, !!n.multiple, i, !1) : n.defaultValue != null && io(e, !!n.multiple, n.defaultValue, !0);
                        break;
                    default:
                        typeof s.onClick == "function" && (e.onclick = ef)
                    }
                    switch (r) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                        n = !!n.autoFocus;
                        break e;
                    case "img":
                        n = !0;
                        break e;
                    default:
                        n = !1
                    }
                }
                n && (t.flags |= 4)
            }
            t.ref !== null && (t.flags |= 512,
            t.flags |= 2097152)
        }
        return Yt(t),
        null;
    case 6:
        if (e && t.stateNode != null)
            dk(e, t, e.memoizedProps, n);
        else {
            if (typeof n != "string" && t.stateNode === null)
                throw Error(V(166));
            if (r = Fi(ju.current),
            Fi(Un.current),
            zc(t)) {
                if (n = t.stateNode,
                r = t.memoizedProps,
                n[Mn] = t,
                (i = n.nodeValue !== r) && (e = Lr,
                e !== null))
                    switch (e.tag) {
                    case 3:
                        Fc(n.nodeValue, r, (e.mode & 1) !== 0);
                        break;
                    case 5:
                        e.memoizedProps.suppressHydrationWarning !== !0 && Fc(n.nodeValue, r, (e.mode & 1) !== 0)
                    }
                i && (t.flags |= 4)
            } else
                n = (r.nodeType === 9 ? r : r.ownerDocument).createTextNode(n),
                n[Mn] = t,
                t.stateNode = n
        }
        return Yt(t),
        null;
    case 13:
        if (rt(lt),
        n = t.memoizedState,
        e === null || e.memoizedState !== null && e.memoizedState.dehydrated !== null) {
            if (it && Mr !== null && t.mode & 1 && !(t.flags & 128))
                $2(),
                Ro(),
                t.flags |= 98560,
                i = !1;
            else if (i = zc(t),
            n !== null && n.dehydrated !== null) {
                if (e === null) {
                    if (!i)
                        throw Error(V(318));
                    if (i = t.memoizedState,
                    i = i !== null ? i.dehydrated : null,
                    !i)
                        throw Error(V(317));
                    i[Mn] = t
                } else
                    Ro(),
                    !(t.flags & 128) && (t.memoizedState = null),
                    t.flags |= 4;
                Yt(t),
                i = !1
            } else
                mn !== null && (Gp(mn),
                mn = null),
                i = !0;
            if (!i)
                return t.flags & 65536 ? t : null
        }
        return t.flags & 128 ? (t.lanes = r,
        t) : (n = n !== null,
        n !== (e !== null && e.memoizedState !== null) && n && (t.child.flags |= 8192,
        t.mode & 1 && (e === null || lt.current & 1 ? At === 0 && (At = 3) : Vg())),
        t.updateQueue !== null && (t.flags |= 4),
        Yt(t),
        null);
    case 4:
        return Mo(),
        Vp(e, t),
        e === null && Cu(t.stateNode.containerInfo),
        Yt(t),
        null;
    case 10:
        return _g(t.type._context),
        Yt(t),
        null;
    case 17:
        return $r(t.type) && tf(),
        Yt(t),
        null;
    case 19:
        if (rt(lt),
        i = t.memoizedState,
        i === null)
            return Yt(t),
            null;
        if (n = (t.flags & 128) !== 0,
        a = i.rendering,
        a === null)
            if (n)
                xl(i, !1);
            else {
                if (At !== 0 || e !== null && e.flags & 128)
                    for (e = t.child; e !== null; ) {
                        if (a = uf(e),
                        a !== null) {
                            for (t.flags |= 128,
                            xl(i, !1),
                            n = a.updateQueue,
                            n !== null && (t.updateQueue = n,
                            t.flags |= 4),
                            t.subtreeFlags = 0,
                            n = r,
                            r = t.child; r !== null; )
                                i = r,
                                e = n,
                                i.flags &= 14680066,
                                a = i.alternate,
                                a === null ? (i.childLanes = 0,
                                i.lanes = e,
                                i.child = null,
                                i.subtreeFlags = 0,
                                i.memoizedProps = null,
                                i.memoizedState = null,
                                i.updateQueue = null,
                                i.dependencies = null,
                                i.stateNode = null) : (i.childLanes = a.childLanes,
                                i.lanes = a.lanes,
                                i.child = a.child,
                                i.subtreeFlags = 0,
                                i.deletions = null,
                                i.memoizedProps = a.memoizedProps,
                                i.memoizedState = a.memoizedState,
                                i.updateQueue = a.updateQueue,
                                i.type = a.type,
                                e = a.dependencies,
                                i.dependencies = e === null ? null : {
                                    lanes: e.lanes,
                                    firstContext: e.firstContext
                                }),
                                r = r.sibling;
                            return Ye(lt, lt.current & 1 | 2),
                            t.child
                        }
                        e = e.sibling
                    }
                i.tail !== null && Et() > Lo && (t.flags |= 128,
                n = !0,
                xl(i, !1),
                t.lanes = 4194304)
            }
        else {
            if (!n)
                if (e = uf(a),
                e !== null) {
                    if (t.flags |= 128,
                    n = !0,
                    r = e.updateQueue,
                    r !== null && (t.updateQueue = r,
                    t.flags |= 4),
                    xl(i, !0),
                    i.tail === null && i.tailMode === "hidden" && !a.alternate && !it)
                        return Yt(t),
                        null
                } else
                    2 * Et() - i.renderingStartTime > Lo && r !== 1073741824 && (t.flags |= 128,
                    n = !0,
                    xl(i, !1),
                    t.lanes = 4194304);
            i.isBackwards ? (a.sibling = t.child,
            t.child = a) : (r = i.last,
            r !== null ? r.sibling = a : t.child = a,
            i.last = a)
        }
        return i.tail !== null ? (t = i.tail,
        i.rendering = t,
        i.tail = t.sibling,
        i.renderingStartTime = Et(),
        t.sibling = null,
        r = lt.current,
        Ye(lt, n ? r & 1 | 2 : r & 1),
        t) : (Yt(t),
        null);
    case 22:
    case 23:
        return Ug(),
        n = t.memoizedState !== null,
        e !== null && e.memoizedState !== null !== n && (t.flags |= 8192),
        n && t.mode & 1 ? Rr & 1073741824 && (Yt(t),
        t.subtreeFlags & 6 && (t.flags |= 8192)) : Yt(t),
        null;
    case 24:
        return null;
    case 25:
        return null
    }
    throw Error(V(156, t.tag))
}
function FF(e, t) {
    switch (wg(t),
    t.tag) {
    case 1:
        return $r(t.type) && tf(),
        e = t.flags,
        e & 65536 ? (t.flags = e & -65537 | 128,
        t) : null;
    case 3:
        return Mo(),
        rt(Pr),
        rt(sr),
        Ng(),
        e = t.flags,
        e & 65536 && !(e & 128) ? (t.flags = e & -65537 | 128,
        t) : null;
    case 5:
        return $g(t),
        null;
    case 13:
        if (rt(lt),
        e = t.memoizedState,
        e !== null && e.dehydrated !== null) {
            if (t.alternate === null)
                throw Error(V(340));
            Ro()
        }
        return e = t.flags,
        e & 65536 ? (t.flags = e & -65537 | 128,
        t) : null;
    case 19:
        return rt(lt),
        null;
    case 4:
        return Mo(),
        null;
    case 10:
        return _g(t.type._context),
        null;
    case 22:
    case 23:
        return Ug(),
        null;
    case 24:
        return null;
    default:
        return null
    }
}
var Bc = !1
  , tr = !1
  , zF = typeof WeakSet == "function" ? WeakSet : Set
  , ee = null;
function Xa(e, t) {
    var r = e.ref;
    if (r !== null)
        if (typeof r == "function")
            try {
                r(null)
            } catch (n) {
                bt(e, t, n)
            }
        else
            r.current = null
}
function Bp(e, t, r) {
    try {
        r()
    } catch (n) {
        bt(e, t, n)
    }
}
var zb = !1;
function UF(e, t) {
    if (Tp = Yd,
    e = y2(),
    bg(e)) {
        if ("selectionStart"in e)
            var r = {
                start: e.selectionStart,
                end: e.selectionEnd
            };
        else
            e: {
                r = (r = e.ownerDocument) && r.defaultView || window;
                var n = r.getSelection && r.getSelection();
                if (n && n.rangeCount !== 0) {
                    r = n.anchorNode;
                    var s = n.anchorOffset
                      , i = n.focusNode;
                    n = n.focusOffset;
                    try {
                        r.nodeType,
                        i.nodeType
                    } catch {
                        r = null;
                        break e
                    }
                    var a = 0
                      , o = -1
                      , l = -1
                      , c = 0
                      , f = 0
                      , h = e
                      , m = null;
                    t: for (; ; ) {
                        for (var y; h !== r || s !== 0 && h.nodeType !== 3 || (o = a + s),
                        h !== i || n !== 0 && h.nodeType !== 3 || (l = a + n),
                        h.nodeType === 3 && (a += h.nodeValue.length),
                        (y = h.firstChild) !== null; )
                            m = h,
                            h = y;
                        for (; ; ) {
                            if (h === e)
                                break t;
                            if (m === r && ++c === s && (o = a),
                            m === i && ++f === n && (l = a),
                            (y = h.nextSibling) !== null)
                                break;
                            h = m,
                            m = h.parentNode
                        }
                        h = y
                    }
                    r = o === -1 || l === -1 ? null : {
                        start: o,
                        end: l
                    }
                } else
                    r = null
            }
        r = r || {
            start: 0,
            end: 0
        }
    } else
        r = null;
    for (Cp = {
        focusedElem: e,
        selectionRange: r
    },
    Yd = !1,
    ee = t; ee !== null; )
        if (t = ee,
        e = t.child,
        (t.subtreeFlags & 1028) !== 0 && e !== null)
            e.return = t,
            ee = e;
        else
            for (; ee !== null; ) {
                t = ee;
                try {
                    var k = t.alternate;
                    if (t.flags & 1024)
                        switch (t.tag) {
                        case 0:
                        case 11:
                        case 15:
                            break;
                        case 1:
                            if (k !== null) {
                                var x = k.memoizedProps
                                  , w = k.memoizedState
                                  , v = t.stateNode
                                  , p = v.getSnapshotBeforeUpdate(t.elementType === t.type ? x : ln(t.type, x), w);
                                v.__reactInternalSnapshotBeforeUpdate = p
                            }
                            break;
                        case 3:
                            var S = t.stateNode.containerInfo;
                            S.nodeType === 1 ? S.textContent = "" : S.nodeType === 9 && S.documentElement && S.removeChild(S.documentElement);
                            break;
                        case 5:
                        case 6:
                        case 4:
                        case 17:
                            break;
                        default:
                            throw Error(V(163))
                        }
                } catch (P) {
                    bt(t, t.return, P)
                }
                if (e = t.sibling,
                e !== null) {
                    e.return = t.return,
                    ee = e;
                    break
                }
                ee = t.return
            }
    return k = zb,
    zb = !1,
    k
}
function Ql(e, t, r) {
    var n = t.updateQueue;
    if (n = n !== null ? n.lastEffect : null,
    n !== null) {
        var s = n = n.next;
        do {
            if ((s.tag & e) === e) {
                var i = s.destroy;
                s.destroy = void 0,
                i !== void 0 && Bp(t, r, i)
            }
            s = s.next
        } while (s !== n)
    }
}
function nh(e, t) {
    if (t = t.updateQueue,
    t = t !== null ? t.lastEffect : null,
    t !== null) {
        var r = t = t.next;
        do {
            if ((r.tag & e) === e) {
                var n = r.create;
                r.destroy = n()
            }
            r = r.next
        } while (r !== t)
    }
}
function Wp(e) {
    var t = e.ref;
    if (t !== null) {
        var r = e.stateNode;
        switch (e.tag) {
        case 5:
            e = r;
            break;
        default:
            e = r
        }
        typeof t == "function" ? t(e) : t.current = e
    }
}
function fk(e) {
    var t = e.alternate;
    t !== null && (e.alternate = null,
    fk(t)),
    e.child = null,
    e.deletions = null,
    e.sibling = null,
    e.tag === 5 && (t = e.stateNode,
    t !== null && (delete t[Mn],
    delete t[$u],
    delete t[Np],
    delete t[kF],
    delete t[EF])),
    e.stateNode = null,
    e.return = null,
    e.dependencies = null,
    e.memoizedProps = null,
    e.memoizedState = null,
    e.pendingProps = null,
    e.stateNode = null,
    e.updateQueue = null
}
function hk(e) {
    return e.tag === 5 || e.tag === 3 || e.tag === 4
}
function Ub(e) {
    e: for (; ; ) {
        for (; e.sibling === null; ) {
            if (e.return === null || hk(e.return))
                return null;
            e = e.return
        }
        for (e.sibling.return = e.return,
        e = e.sibling; e.tag !== 5 && e.tag !== 6 && e.tag !== 18; ) {
            if (e.flags & 2 || e.child === null || e.tag === 4)
                continue e;
            e.child.return = e,
            e = e.child
        }
        if (!(e.flags & 2))
            return e.stateNode
    }
}
function qp(e, t, r) {
    var n = e.tag;
    if (n === 5 || n === 6)
        e = e.stateNode,
        t ? r.nodeType === 8 ? r.parentNode.insertBefore(e, t) : r.insertBefore(e, t) : (r.nodeType === 8 ? (t = r.parentNode,
        t.insertBefore(e, r)) : (t = r,
        t.appendChild(e)),
        r = r._reactRootContainer,
        r != null || t.onclick !== null || (t.onclick = ef));
    else if (n !== 4 && (e = e.child,
    e !== null))
        for (qp(e, t, r),
        e = e.sibling; e !== null; )
            qp(e, t, r),
            e = e.sibling
}
function Hp(e, t, r) {
    var n = e.tag;
    if (n === 5 || n === 6)
        e = e.stateNode,
        t ? r.insertBefore(e, t) : r.appendChild(e);
    else if (n !== 4 && (e = e.child,
    e !== null))
        for (Hp(e, t, r),
        e = e.sibling; e !== null; )
            Hp(e, t, r),
            e = e.sibling
}
var qt = null
  , dn = !1;
function Es(e, t, r) {
    for (r = r.child; r !== null; )
        mk(e, t, r),
        r = r.sibling
}
function mk(e, t, r) {
    if (zn && typeof zn.onCommitFiberUnmount == "function")
        try {
            zn.onCommitFiberUnmount(Qf, r)
        } catch {}
    switch (r.tag) {
    case 5:
        tr || Xa(r, t);
    case 6:
        var n = qt
          , s = dn;
        qt = null,
        Es(e, t, r),
        qt = n,
        dn = s,
        qt !== null && (dn ? (e = qt,
        r = r.stateNode,
        e.nodeType === 8 ? e.parentNode.removeChild(r) : e.removeChild(r)) : qt.removeChild(r.stateNode));
        break;
    case 18:
        qt !== null && (dn ? (e = qt,
        r = r.stateNode,
        e.nodeType === 8 ? Jh(e.parentNode, r) : e.nodeType === 1 && Jh(e, r),
        Eu(e)) : Jh(qt, r.stateNode));
        break;
    case 4:
        n = qt,
        s = dn,
        qt = r.stateNode.containerInfo,
        dn = !0,
        Es(e, t, r),
        qt = n,
        dn = s;
        break;
    case 0:
    case 11:
    case 14:
    case 15:
        if (!tr && (n = r.updateQueue,
        n !== null && (n = n.lastEffect,
        n !== null))) {
            s = n = n.next;
            do {
                var i = s
                  , a = i.destroy;
                i = i.tag,
                a !== void 0 && (i & 2 || i & 4) && Bp(r, t, a),
                s = s.next
            } while (s !== n)
        }
        Es(e, t, r);
        break;
    case 1:
        if (!tr && (Xa(r, t),
        n = r.stateNode,
        typeof n.componentWillUnmount == "function"))
            try {
                n.props = r.memoizedProps,
                n.state = r.memoizedState,
                n.componentWillUnmount()
            } catch (o) {
                bt(r, t, o)
            }
        Es(e, t, r);
        break;
    case 21:
        Es(e, t, r);
        break;
    case 22:
        r.mode & 1 ? (tr = (n = tr) || r.memoizedState !== null,
        Es(e, t, r),
        tr = n) : Es(e, t, r);
        break;
    default:
        Es(e, t, r)
    }
}
function Vb(e) {
    var t = e.updateQueue;
    if (t !== null) {
        e.updateQueue = null;
        var r = e.stateNode;
        r === null && (r = e.stateNode = new zF),
        t.forEach(function(n) {
            var s = GF.bind(null, e, n);
            r.has(n) || (r.add(n),
            n.then(s, s))
        })
    }
}
function sn(e, t) {
    var r = t.deletions;
    if (r !== null)
        for (var n = 0; n < r.length; n++) {
            var s = r[n];
            try {
                var i = e
                  , a = t
                  , o = a;
                e: for (; o !== null; ) {
                    switch (o.tag) {
                    case 5:
                        qt = o.stateNode,
                        dn = !1;
                        break e;
                    case 3:
                        qt = o.stateNode.containerInfo,
                        dn = !0;
                        break e;
                    case 4:
                        qt = o.stateNode.containerInfo,
                        dn = !0;
                        break e
                    }
                    o = o.return
                }
                if (qt === null)
                    throw Error(V(160));
                mk(i, a, s),
                qt = null,
                dn = !1;
                var l = s.alternate;
                l !== null && (l.return = null),
                s.return = null
            } catch (c) {
                bt(s, t, c)
            }
        }
    if (t.subtreeFlags & 12854)
        for (t = t.child; t !== null; )
            pk(t, e),
            t = t.sibling
}
function pk(e, t) {
    var r = e.alternate
      , n = e.flags;
    switch (e.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
        if (sn(t, e),
        Pn(e),
        n & 4) {
            try {
                Ql(3, e, e.return),
                nh(3, e)
            } catch (x) {
                bt(e, e.return, x)
            }
            try {
                Ql(5, e, e.return)
            } catch (x) {
                bt(e, e.return, x)
            }
        }
        break;
    case 1:
        sn(t, e),
        Pn(e),
        n & 512 && r !== null && Xa(r, r.return);
        break;
    case 5:
        if (sn(t, e),
        Pn(e),
        n & 512 && r !== null && Xa(r, r.return),
        e.flags & 32) {
            var s = e.stateNode;
            try {
                xu(s, "")
            } catch (x) {
                bt(e, e.return, x)
            }
        }
        if (n & 4 && (s = e.stateNode,
        s != null)) {
            var i = e.memoizedProps
              , a = r !== null ? r.memoizedProps : i
              , o = e.type
              , l = e.updateQueue;
            if (e.updateQueue = null,
            l !== null)
                try {
                    o === "input" && i.type === "radio" && i.name != null && LS(s, i),
                    yp(o, a);
                    var c = yp(o, i);
                    for (a = 0; a < l.length; a += 2) {
                        var f = l[a]
                          , h = l[a + 1];
                        f === "style" ? VS(s, h) : f === "dangerouslySetInnerHTML" ? zS(s, h) : f === "children" ? xu(s, h) : ag(s, f, h, c)
                    }
                    switch (o) {
                    case "input":
                        dp(s, i);
                        break;
                    case "textarea":
                        DS(s, i);
                        break;
                    case "select":
                        var m = s._wrapperState.wasMultiple;
                        s._wrapperState.wasMultiple = !!i.multiple;
                        var y = i.value;
                        y != null ? io(s, !!i.multiple, y, !1) : m !== !!i.multiple && (i.defaultValue != null ? io(s, !!i.multiple, i.defaultValue, !0) : io(s, !!i.multiple, i.multiple ? [] : "", !1))
                    }
                    s[$u] = i
                } catch (x) {
                    bt(e, e.return, x)
                }
        }
        break;
    case 6:
        if (sn(t, e),
        Pn(e),
        n & 4) {
            if (e.stateNode === null)
                throw Error(V(162));
            s = e.stateNode,
            i = e.memoizedProps;
            try {
                s.nodeValue = i
            } catch (x) {
                bt(e, e.return, x)
            }
        }
        break;
    case 3:
        if (sn(t, e),
        Pn(e),
        n & 4 && r !== null && r.memoizedState.isDehydrated)
            try {
                Eu(t.containerInfo)
            } catch (x) {
                bt(e, e.return, x)
            }
        break;
    case 4:
        sn(t, e),
        Pn(e);
        break;
    case 13:
        sn(t, e),
        Pn(e),
        s = e.child,
        s.flags & 8192 && (i = s.memoizedState !== null,
        s.stateNode.isHidden = i,
        !i || s.alternate !== null && s.alternate.memoizedState !== null || (Fg = Et())),
        n & 4 && Vb(e);
        break;
    case 22:
        if (f = r !== null && r.memoizedState !== null,
        e.mode & 1 ? (tr = (c = tr) || f,
        sn(t, e),
        tr = c) : sn(t, e),
        Pn(e),
        n & 8192) {
            if (c = e.memoizedState !== null,
            (e.stateNode.isHidden = c) && !f && e.mode & 1)
                for (ee = e,
                f = e.child; f !== null; ) {
                    for (h = ee = f; ee !== null; ) {
                        switch (m = ee,
                        y = m.child,
                        m.tag) {
                        case 0:
                        case 11:
                        case 14:
                        case 15:
                            Ql(4, m, m.return);
                            break;
                        case 1:
                            Xa(m, m.return);
                            var k = m.stateNode;
                            if (typeof k.componentWillUnmount == "function") {
                                n = m,
                                r = m.return;
                                try {
                                    t = n,
                                    k.props = t.memoizedProps,
                                    k.state = t.memoizedState,
                                    k.componentWillUnmount()
                                } catch (x) {
                                    bt(n, r, x)
                                }
                            }
                            break;
                        case 5:
                            Xa(m, m.return);
                            break;
                        case 22:
                            if (m.memoizedState !== null) {
                                Wb(h);
                                continue
                            }
                        }
                        y !== null ? (y.return = m,
                        ee = y) : Wb(h)
                    }
                    f = f.sibling
                }
            e: for (f = null,
            h = e; ; ) {
                if (h.tag === 5) {
                    if (f === null) {
                        f = h;
                        try {
                            s = h.stateNode,
                            c ? (i = s.style,
                            typeof i.setProperty == "function" ? i.setProperty("display", "none", "important") : i.display = "none") : (o = h.stateNode,
                            l = h.memoizedProps.style,
                            a = l != null && l.hasOwnProperty("display") ? l.display : null,
                            o.style.display = US("display", a))
                        } catch (x) {
                            bt(e, e.return, x)
                        }
                    }
                } else if (h.tag === 6) {
                    if (f === null)
                        try {
                            h.stateNode.nodeValue = c ? "" : h.memoizedProps
                        } catch (x) {
                            bt(e, e.return, x)
                        }
                } else if ((h.tag !== 22 && h.tag !== 23 || h.memoizedState === null || h === e) && h.child !== null) {
                    h.child.return = h,
                    h = h.child;
                    continue
                }
                if (h === e)
                    break e;
                for (; h.sibling === null; ) {
                    if (h.return === null || h.return === e)
                        break e;
                    f === h && (f = null),
                    h = h.return
                }
                f === h && (f = null),
                h.sibling.return = h.return,
                h = h.sibling
            }
        }
        break;
    case 19:
        sn(t, e),
        Pn(e),
        n & 4 && Vb(e);
        break;
    case 21:
        break;
    default:
        sn(t, e),
        Pn(e)
    }
}
function Pn(e) {
    var t = e.flags;
    if (t & 2) {
        try {
            e: {
                for (var r = e.return; r !== null; ) {
                    if (hk(r)) {
                        var n = r;
                        break e
                    }
                    r = r.return
                }
                throw Error(V(160))
            }
            switch (n.tag) {
            case 5:
                var s = n.stateNode;
                n.flags & 32 && (xu(s, ""),
                n.flags &= -33);
                var i = Ub(e);
                Hp(e, i, s);
                break;
            case 3:
            case 4:
                var a = n.stateNode.containerInfo
                  , o = Ub(e);
                qp(e, o, a);
                break;
            default:
                throw Error(V(161))
            }
        } catch (l) {
            bt(e, e.return, l)
        }
        e.flags &= -3
    }
    t & 4096 && (e.flags &= -4097)
}
function VF(e, t, r) {
    ee = e,
    yk(e)
}
function yk(e, t, r) {
    for (var n = (e.mode & 1) !== 0; ee !== null; ) {
        var s = ee
          , i = s.child;
        if (s.tag === 22 && n) {
            var a = s.memoizedState !== null || Bc;
            if (!a) {
                var o = s.alternate
                  , l = o !== null && o.memoizedState !== null || tr;
                o = Bc;
                var c = tr;
                if (Bc = a,
                (tr = l) && !c)
                    for (ee = s; ee !== null; )
                        a = ee,
                        l = a.child,
                        a.tag === 22 && a.memoizedState !== null ? qb(s) : l !== null ? (l.return = a,
                        ee = l) : qb(s);
                for (; i !== null; )
                    ee = i,
                    yk(i),
                    i = i.sibling;
                ee = s,
                Bc = o,
                tr = c
            }
            Bb(e)
        } else
            s.subtreeFlags & 8772 && i !== null ? (i.return = s,
            ee = i) : Bb(e)
    }
}
function Bb(e) {
    for (; ee !== null; ) {
        var t = ee;
        if (t.flags & 8772) {
            var r = t.alternate;
            try {
                if (t.flags & 8772)
                    switch (t.tag) {
                    case 0:
                    case 11:
                    case 15:
                        tr || nh(5, t);
                        break;
                    case 1:
                        var n = t.stateNode;
                        if (t.flags & 4 && !tr)
                            if (r === null)
                                n.componentDidMount();
                            else {
                                var s = t.elementType === t.type ? r.memoizedProps : ln(t.type, r.memoizedProps);
                                n.componentDidUpdate(s, r.memoizedState, n.__reactInternalSnapshotBeforeUpdate)
                            }
                        var i = t.updateQueue;
                        i !== null && Cb(t, i, n);
                        break;
                    case 3:
                        var a = t.updateQueue;
                        if (a !== null) {
                            if (r = null,
                            t.child !== null)
                                switch (t.child.tag) {
                                case 5:
                                    r = t.child.stateNode;
                                    break;
                                case 1:
                                    r = t.child.stateNode
                                }
                            Cb(t, a, r)
                        }
                        break;
                    case 5:
                        var o = t.stateNode;
                        if (r === null && t.flags & 4) {
                            r = o;
                            var l = t.memoizedProps;
                            switch (t.type) {
                            case "button":
                            case "input":
                            case "select":
                            case "textarea":
                                l.autoFocus && r.focus();
                                break;
                            case "img":
                                l.src && (r.src = l.src)
                            }
                        }
                        break;
                    case 6:
                        break;
                    case 4:
                        break;
                    case 12:
                        break;
                    case 13:
                        if (t.memoizedState === null) {
                            var c = t.alternate;
                            if (c !== null) {
                                var f = c.memoizedState;
                                if (f !== null) {
                                    var h = f.dehydrated;
                                    h !== null && Eu(h)
                                }
                            }
                        }
                        break;
                    case 19:
                    case 17:
                    case 21:
                    case 22:
                    case 23:
                    case 25:
                        break;
                    default:
                        throw Error(V(163))
                    }
                tr || t.flags & 512 && Wp(t)
            } catch (m) {
                bt(t, t.return, m)
            }
        }
        if (t === e) {
            ee = null;
            break
        }
        if (r = t.sibling,
        r !== null) {
            r.return = t.return,
            ee = r;
            break
        }
        ee = t.return
    }
}
function Wb(e) {
    for (; ee !== null; ) {
        var t = ee;
        if (t === e) {
            ee = null;
            break
        }
        var r = t.sibling;
        if (r !== null) {
            r.return = t.return,
            ee = r;
            break
        }
        ee = t.return
    }
}
function qb(e) {
    for (; ee !== null; ) {
        var t = ee;
        try {
            switch (t.tag) {
            case 0:
            case 11:
            case 15:
                var r = t.return;
                try {
                    nh(4, t)
                } catch (l) {
                    bt(t, r, l)
                }
                break;
            case 1:
                var n = t.stateNode;
                if (typeof n.componentDidMount == "function") {
                    var s = t.return;
                    try {
                        n.componentDidMount()
                    } catch (l) {
                        bt(t, s, l)
                    }
                }
                var i = t.return;
                try {
                    Wp(t)
                } catch (l) {
                    bt(t, i, l)
                }
                break;
            case 5:
                var a = t.return;
                try {
                    Wp(t)
                } catch (l) {
                    bt(t, a, l)
                }
            }
        } catch (l) {
            bt(t, t.return, l)
        }
        if (t === e) {
            ee = null;
            break
        }
        var o = t.sibling;
        if (o !== null) {
            o.return = t.return,
            ee = o;
            break
        }
        ee = t.return
    }
}
var BF = Math.ceil
  , ff = vs.ReactCurrentDispatcher
  , Lg = vs.ReactCurrentOwner
  , Xr = vs.ReactCurrentBatchConfig
  , Ae = 0
  , Dt = null
  , Nt = null
  , Ht = 0
  , Rr = 0
  , eo = bi(0)
  , At = 0
  , Mu = null
  , fa = 0
  , sh = 0
  , Dg = 0
  , Gl = null
  , Tr = null
  , Fg = 0
  , Lo = 1 / 0
  , Gn = null
  , hf = !1
  , Zp = null
  , ni = null
  , Wc = !1
  , Qs = null
  , mf = 0
  , Yl = 0
  , Kp = null
  , pd = -1
  , yd = 0;
function yr() {
    return Ae & 6 ? Et() : pd !== -1 ? pd : pd = Et()
}
function si(e) {
    return e.mode & 1 ? Ae & 2 && Ht !== 0 ? Ht & -Ht : TF.transition !== null ? (yd === 0 && (yd = e2()),
    yd) : (e = Ze,
    e !== 0 || (e = window.event,
    e = e === void 0 ? 16 : o2(e.type)),
    e) : 1
}
function wn(e, t, r, n) {
    if (50 < Yl)
        throw Yl = 0,
        Kp = null,
        Error(V(185));
    Xu(e, r, n),
    (!(Ae & 2) || e !== Dt) && (e === Dt && (!(Ae & 2) && (sh |= r),
    At === 4 && Ms(e, Ht)),
    Nr(e, n),
    r === 1 && Ae === 0 && !(t.mode & 1) && (Lo = Et() + 500,
    eh && xi()))
}
function Nr(e, t) {
    var r = e.callbackNode;
    TD(e, t);
    var n = Gd(e, e === Dt ? Ht : 0);
    if (n === 0)
        r !== null && eb(r),
        e.callbackNode = null,
        e.callbackPriority = 0;
    else if (t = n & -n,
    e.callbackPriority !== t) {
        if (r != null && eb(r),
        t === 1)
            e.tag === 0 ? _F(Hb.bind(null, e)) : T2(Hb.bind(null, e)),
            wF(function() {
                !(Ae & 6) && xi()
            }),
            r = null;
        else {
            switch (t2(n)) {
            case 1:
                r = dg;
                break;
            case 4:
                r = JS;
                break;
            case 16:
                r = Qd;
                break;
            case 536870912:
                r = XS;
                break;
            default:
                r = Qd
            }
            r = Ek(r, gk.bind(null, e))
        }
        e.callbackPriority = t,
        e.callbackNode = r
    }
}
function gk(e, t) {
    if (pd = -1,
    yd = 0,
    Ae & 6)
        throw Error(V(327));
    var r = e.callbackNode;
    if (co() && e.callbackNode !== r)
        return null;
    var n = Gd(e, e === Dt ? Ht : 0);
    if (n === 0)
        return null;
    if (n & 30 || n & e.expiredLanes || t)
        t = pf(e, n);
    else {
        t = n;
        var s = Ae;
        Ae |= 2;
        var i = bk();
        (Dt !== e || Ht !== t) && (Gn = null,
        Lo = Et() + 500,
        ea(e, t));
        do
            try {
                HF();
                break
            } catch (o) {
                vk(e, o)
            }
        while (!0);
        Eg(),
        ff.current = i,
        Ae = s,
        Nt !== null ? t = 0 : (Dt = null,
        Ht = 0,
        t = At)
    }
    if (t !== 0) {
        if (t === 2 && (s = wp(e),
        s !== 0 && (n = s,
        t = Qp(e, s))),
        t === 1)
            throw r = Mu,
            ea(e, 0),
            Ms(e, n),
            Nr(e, Et()),
            r;
        if (t === 6)
            Ms(e, n);
        else {
            if (s = e.current.alternate,
            !(n & 30) && !WF(s) && (t = pf(e, n),
            t === 2 && (i = wp(e),
            i !== 0 && (n = i,
            t = Qp(e, i))),
            t === 1))
                throw r = Mu,
                ea(e, 0),
                Ms(e, n),
                Nr(e, Et()),
                r;
            switch (e.finishedWork = s,
            e.finishedLanes = n,
            t) {
            case 0:
            case 1:
                throw Error(V(345));
            case 2:
                Oi(e, Tr, Gn);
                break;
            case 3:
                if (Ms(e, n),
                (n & 130023424) === n && (t = Fg + 500 - Et(),
                10 < t)) {
                    if (Gd(e, 0) !== 0)
                        break;
                    if (s = e.suspendedLanes,
                    (s & n) !== n) {
                        yr(),
                        e.pingedLanes |= e.suspendedLanes & s;
                        break
                    }
                    e.timeoutHandle = $p(Oi.bind(null, e, Tr, Gn), t);
                    break
                }
                Oi(e, Tr, Gn);
                break;
            case 4:
                if (Ms(e, n),
                (n & 4194240) === n)
                    break;
                for (t = e.eventTimes,
                s = -1; 0 < n; ) {
                    var a = 31 - xn(n);
                    i = 1 << a,
                    a = t[a],
                    a > s && (s = a),
                    n &= ~i
                }
                if (n = s,
                n = Et() - n,
                n = (120 > n ? 120 : 480 > n ? 480 : 1080 > n ? 1080 : 1920 > n ? 1920 : 3e3 > n ? 3e3 : 4320 > n ? 4320 : 1960 * BF(n / 1960)) - n,
                10 < n) {
                    e.timeoutHandle = $p(Oi.bind(null, e, Tr, Gn), n);
                    break
                }
                Oi(e, Tr, Gn);
                break;
            case 5:
                Oi(e, Tr, Gn);
                break;
            default:
                throw Error(V(329))
            }
        }
    }
    return Nr(e, Et()),
    e.callbackNode === r ? gk.bind(null, e) : null
}
function Qp(e, t) {
    var r = Gl;
    return e.current.memoizedState.isDehydrated && (ea(e, t).flags |= 256),
    e = pf(e, t),
    e !== 2 && (t = Tr,
    Tr = r,
    t !== null && Gp(t)),
    e
}
function Gp(e) {
    Tr === null ? Tr = e : Tr.push.apply(Tr, e)
}
function WF(e) {
    for (var t = e; ; ) {
        if (t.flags & 16384) {
            var r = t.updateQueue;
            if (r !== null && (r = r.stores,
            r !== null))
                for (var n = 0; n < r.length; n++) {
                    var s = r[n]
                      , i = s.getSnapshot;
                    s = s.value;
                    try {
                        if (!kn(i(), s))
                            return !1
                    } catch {
                        return !1
                    }
                }
        }
        if (r = t.child,
        t.subtreeFlags & 16384 && r !== null)
            r.return = t,
            t = r;
        else {
            if (t === e)
                break;
            for (; t.sibling === null; ) {
                if (t.return === null || t.return === e)
                    return !0;
                t = t.return
            }
            t.sibling.return = t.return,
            t = t.sibling
        }
    }
    return !0
}
function Ms(e, t) {
    for (t &= ~Dg,
    t &= ~sh,
    e.suspendedLanes |= t,
    e.pingedLanes &= ~t,
    e = e.expirationTimes; 0 < t; ) {
        var r = 31 - xn(t)
          , n = 1 << r;
        e[r] = -1,
        t &= ~n
    }
}
function Hb(e) {
    if (Ae & 6)
        throw Error(V(327));
    co();
    var t = Gd(e, 0);
    if (!(t & 1))
        return Nr(e, Et()),
        null;
    var r = pf(e, t);
    if (e.tag !== 0 && r === 2) {
        var n = wp(e);
        n !== 0 && (t = n,
        r = Qp(e, n))
    }
    if (r === 1)
        throw r = Mu,
        ea(e, 0),
        Ms(e, t),
        Nr(e, Et()),
        r;
    if (r === 6)
        throw Error(V(345));
    return e.finishedWork = e.current.alternate,
    e.finishedLanes = t,
    Oi(e, Tr, Gn),
    Nr(e, Et()),
    null
}
function zg(e, t) {
    var r = Ae;
    Ae |= 1;
    try {
        return e(t)
    } finally {
        Ae = r,
        Ae === 0 && (Lo = Et() + 500,
        eh && xi())
    }
}
function ha(e) {
    Qs !== null && Qs.tag === 0 && !(Ae & 6) && co();
    var t = Ae;
    Ae |= 1;
    var r = Xr.transition
      , n = Ze;
    try {
        if (Xr.transition = null,
        Ze = 1,
        e)
            return e()
    } finally {
        Ze = n,
        Xr.transition = r,
        Ae = t,
        !(Ae & 6) && xi()
    }
}
function Ug() {
    Rr = eo.current,
    rt(eo)
}
function ea(e, t) {
    e.finishedWork = null,
    e.finishedLanes = 0;
    var r = e.timeoutHandle;
    if (r !== -1 && (e.timeoutHandle = -1,
    xF(r)),
    Nt !== null)
        for (r = Nt.return; r !== null; ) {
            var n = r;
            switch (wg(n),
            n.tag) {
            case 1:
                n = n.type.childContextTypes,
                n != null && tf();
                break;
            case 3:
                Mo(),
                rt(Pr),
                rt(sr),
                Ng();
                break;
            case 5:
                $g(n);
                break;
            case 4:
                Mo();
                break;
            case 13:
                rt(lt);
                break;
            case 19:
                rt(lt);
                break;
            case 10:
                _g(n.type._context);
                break;
            case 22:
            case 23:
                Ug()
            }
            r = r.return
        }
    if (Dt = e,
    Nt = e = ii(e.current, null),
    Ht = Rr = t,
    At = 0,
    Mu = null,
    Dg = sh = fa = 0,
    Tr = Gl = null,
    Di !== null) {
        for (t = 0; t < Di.length; t++)
            if (r = Di[t],
            n = r.interleaved,
            n !== null) {
                r.interleaved = null;
                var s = n.next
                  , i = r.pending;
                if (i !== null) {
                    var a = i.next;
                    i.next = s,
                    n.next = a
                }
                r.pending = n
            }
        Di = null
    }
    return e
}
function vk(e, t) {
    do {
        var r = Nt;
        try {
            if (Eg(),
            fd.current = df,
            cf) {
                for (var n = ut.memoizedState; n !== null; ) {
                    var s = n.queue;
                    s !== null && (s.pending = null),
                    n = n.next
                }
                cf = !1
            }
            if (da = 0,
            Lt = Ot = ut = null,
            Kl = !1,
            Iu = 0,
            Lg.current = null,
            r === null || r.return === null) {
                At = 1,
                Mu = t,
                Nt = null;
                break
            }
            e: {
                var i = e
                  , a = r.return
                  , o = r
                  , l = t;
                if (t = Ht,
                o.flags |= 32768,
                l !== null && typeof l == "object" && typeof l.then == "function") {
                    var c = l
                      , f = o
                      , h = f.tag;
                    if (!(f.mode & 1) && (h === 0 || h === 11 || h === 15)) {
                        var m = f.alternate;
                        m ? (f.updateQueue = m.updateQueue,
                        f.memoizedState = m.memoizedState,
                        f.lanes = m.lanes) : (f.updateQueue = null,
                        f.memoizedState = null)
                    }
                    var y = Rb(a);
                    if (y !== null) {
                        y.flags &= -257,
                        Ob(y, a, o, i, t),
                        y.mode & 1 && Ib(i, c, t),
                        t = y,
                        l = c;
                        var k = t.updateQueue;
                        if (k === null) {
                            var x = new Set;
                            x.add(l),
                            t.updateQueue = x
                        } else
                            k.add(l);
                        break e
                    } else {
                        if (!(t & 1)) {
                            Ib(i, c, t),
                            Vg();
                            break e
                        }
                        l = Error(V(426))
                    }
                } else if (it && o.mode & 1) {
                    var w = Rb(a);
                    if (w !== null) {
                        !(w.flags & 65536) && (w.flags |= 256),
                        Ob(w, a, o, i, t),
                        Sg(Ao(l, o));
                        break e
                    }
                }
                i = l = Ao(l, o),
                At !== 4 && (At = 2),
                Gl === null ? Gl = [i] : Gl.push(i),
                i = a;
                do {
                    switch (i.tag) {
                    case 3:
                        i.flags |= 65536,
                        t &= -t,
                        i.lanes |= t;
                        var v = tk(i, l, t);
                        Tb(i, v);
                        break e;
                    case 1:
                        o = l;
                        var p = i.type
                          , S = i.stateNode;
                        if (!(i.flags & 128) && (typeof p.getDerivedStateFromError == "function" || S !== null && typeof S.componentDidCatch == "function" && (ni === null || !ni.has(S)))) {
                            i.flags |= 65536,
                            t &= -t,
                            i.lanes |= t;
                            var P = rk(i, o, t);
                            Tb(i, P);
                            break e
                        }
                    }
                    i = i.return
                } while (i !== null)
            }
            wk(r)
        } catch (j) {
            t = j,
            Nt === r && r !== null && (Nt = r = r.return);
            continue
        }
        break
    } while (!0)
}
function bk() {
    var e = ff.current;
    return ff.current = df,
    e === null ? df : e
}
function Vg() {
    (At === 0 || At === 3 || At === 2) && (At = 4),
    Dt === null || !(fa & 268435455) && !(sh & 268435455) || Ms(Dt, Ht)
}
function pf(e, t) {
    var r = Ae;
    Ae |= 2;
    var n = bk();
    (Dt !== e || Ht !== t) && (Gn = null,
    ea(e, t));
    do
        try {
            qF();
            break
        } catch (s) {
            vk(e, s)
        }
    while (!0);
    if (Eg(),
    Ae = r,
    ff.current = n,
    Nt !== null)
        throw Error(V(261));
    return Dt = null,
    Ht = 0,
    At
}
function qF() {
    for (; Nt !== null; )
        xk(Nt)
}
function HF() {
    for (; Nt !== null && !gD(); )
        xk(Nt)
}
function xk(e) {
    var t = kk(e.alternate, e, Rr);
    e.memoizedProps = e.pendingProps,
    t === null ? wk(e) : Nt = t,
    Lg.current = null
}
function wk(e) {
    var t = e;
    do {
        var r = t.alternate;
        if (e = t.return,
        t.flags & 32768) {
            if (r = FF(r, t),
            r !== null) {
                r.flags &= 32767,
                Nt = r;
                return
            }
            if (e !== null)
                e.flags |= 32768,
                e.subtreeFlags = 0,
                e.deletions = null;
            else {
                At = 6,
                Nt = null;
                return
            }
        } else if (r = DF(r, t, Rr),
        r !== null) {
            Nt = r;
            return
        }
        if (t = t.sibling,
        t !== null) {
            Nt = t;
            return
        }
        Nt = t = e
    } while (t !== null);
    At === 0 && (At = 5)
}
function Oi(e, t, r) {
    var n = Ze
      , s = Xr.transition;
    try {
        Xr.transition = null,
        Ze = 1,
        ZF(e, t, r, n)
    } finally {
        Xr.transition = s,
        Ze = n
    }
    return null
}
function ZF(e, t, r, n) {
    do
        co();
    while (Qs !== null);
    if (Ae & 6)
        throw Error(V(327));
    r = e.finishedWork;
    var s = e.finishedLanes;
    if (r === null)
        return null;
    if (e.finishedWork = null,
    e.finishedLanes = 0,
    r === e.current)
        throw Error(V(177));
    e.callbackNode = null,
    e.callbackPriority = 0;
    var i = r.lanes | r.childLanes;
    if (CD(e, i),
    e === Dt && (Nt = Dt = null,
    Ht = 0),
    !(r.subtreeFlags & 2064) && !(r.flags & 2064) || Wc || (Wc = !0,
    Ek(Qd, function() {
        return co(),
        null
    })),
    i = (r.flags & 15990) !== 0,
    r.subtreeFlags & 15990 || i) {
        i = Xr.transition,
        Xr.transition = null;
        var a = Ze;
        Ze = 1;
        var o = Ae;
        Ae |= 4,
        Lg.current = null,
        UF(e, r),
        pk(r, e),
        hF(Cp),
        Yd = !!Tp,
        Cp = Tp = null,
        e.current = r,
        VF(r),
        vD(),
        Ae = o,
        Ze = a,
        Xr.transition = i
    } else
        e.current = r;
    if (Wc && (Wc = !1,
    Qs = e,
    mf = s),
    i = e.pendingLanes,
    i === 0 && (ni = null),
    wD(r.stateNode),
    Nr(e, Et()),
    t !== null)
        for (n = e.onRecoverableError,
        r = 0; r < t.length; r++)
            s = t[r],
            n(s.value, {
                componentStack: s.stack,
                digest: s.digest
            });
    if (hf)
        throw hf = !1,
        e = Zp,
        Zp = null,
        e;
    return mf & 1 && e.tag !== 0 && co(),
    i = e.pendingLanes,
    i & 1 ? e === Kp ? Yl++ : (Yl = 0,
    Kp = e) : Yl = 0,
    xi(),
    null
}
function co() {
    if (Qs !== null) {
        var e = t2(mf)
          , t = Xr.transition
          , r = Ze;
        try {
            if (Xr.transition = null,
            Ze = 16 > e ? 16 : e,
            Qs === null)
                var n = !1;
            else {
                if (e = Qs,
                Qs = null,
                mf = 0,
                Ae & 6)
                    throw Error(V(331));
                var s = Ae;
                for (Ae |= 4,
                ee = e.current; ee !== null; ) {
                    var i = ee
                      , a = i.child;
                    if (ee.flags & 16) {
                        var o = i.deletions;
                        if (o !== null) {
                            for (var l = 0; l < o.length; l++) {
                                var c = o[l];
                                for (ee = c; ee !== null; ) {
                                    var f = ee;
                                    switch (f.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        Ql(8, f, i)
                                    }
                                    var h = f.child;
                                    if (h !== null)
                                        h.return = f,
                                        ee = h;
                                    else
                                        for (; ee !== null; ) {
                                            f = ee;
                                            var m = f.sibling
                                              , y = f.return;
                                            if (fk(f),
                                            f === c) {
                                                ee = null;
                                                break
                                            }
                                            if (m !== null) {
                                                m.return = y,
                                                ee = m;
                                                break
                                            }
                                            ee = y
                                        }
                                }
                            }
                            var k = i.alternate;
                            if (k !== null) {
                                var x = k.child;
                                if (x !== null) {
                                    k.child = null;
                                    do {
                                        var w = x.sibling;
                                        x.sibling = null,
                                        x = w
                                    } while (x !== null)
                                }
                            }
                            ee = i
                        }
                    }
                    if (i.subtreeFlags & 2064 && a !== null)
                        a.return = i,
                        ee = a;
                    else
                        e: for (; ee !== null; ) {
                            if (i = ee,
                            i.flags & 2048)
                                switch (i.tag) {
                                case 0:
                                case 11:
                                case 15:
                                    Ql(9, i, i.return)
                                }
                            var v = i.sibling;
                            if (v !== null) {
                                v.return = i.return,
                                ee = v;
                                break e
                            }
                            ee = i.return
                        }
                }
                var p = e.current;
                for (ee = p; ee !== null; ) {
                    a = ee;
                    var S = a.child;
                    if (a.subtreeFlags & 2064 && S !== null)
                        S.return = a,
                        ee = S;
                    else
                        e: for (a = p; ee !== null; ) {
                            if (o = ee,
                            o.flags & 2048)
                                try {
                                    switch (o.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        nh(9, o)
                                    }
                                } catch (j) {
                                    bt(o, o.return, j)
                                }
                            if (o === a) {
                                ee = null;
                                break e
                            }
                            var P = o.sibling;
                            if (P !== null) {
                                P.return = o.return,
                                ee = P;
                                break e
                            }
                            ee = o.return
                        }
                }
                if (Ae = s,
                xi(),
                zn && typeof zn.onPostCommitFiberRoot == "function")
                    try {
                        zn.onPostCommitFiberRoot(Qf, e)
                    } catch {}
                n = !0
            }
            return n
        } finally {
            Ze = r,
            Xr.transition = t
        }
    }
    return !1
}
function Zb(e, t, r) {
    t = Ao(r, t),
    t = tk(e, t, 1),
    e = ri(e, t, 1),
    t = yr(),
    e !== null && (Xu(e, 1, t),
    Nr(e, t))
}
function bt(e, t, r) {
    if (e.tag === 3)
        Zb(e, e, r);
    else
        for (; t !== null; ) {
            if (t.tag === 3) {
                Zb(t, e, r);
                break
            } else if (t.tag === 1) {
                var n = t.stateNode;
                if (typeof t.type.getDerivedStateFromError == "function" || typeof n.componentDidCatch == "function" && (ni === null || !ni.has(n))) {
                    e = Ao(r, e),
                    e = rk(t, e, 1),
                    t = ri(t, e, 1),
                    e = yr(),
                    t !== null && (Xu(t, 1, e),
                    Nr(t, e));
                    break
                }
            }
            t = t.return
        }
}
function KF(e, t, r) {
    var n = e.pingCache;
    n !== null && n.delete(t),
    t = yr(),
    e.pingedLanes |= e.suspendedLanes & r,
    Dt === e && (Ht & r) === r && (At === 4 || At === 3 && (Ht & 130023424) === Ht && 500 > Et() - Fg ? ea(e, 0) : Dg |= r),
    Nr(e, t)
}
function Sk(e, t) {
    t === 0 && (e.mode & 1 ? (t = Oc,
    Oc <<= 1,
    !(Oc & 130023424) && (Oc = 4194304)) : t = 1);
    var r = yr();
    e = ds(e, t),
    e !== null && (Xu(e, t, r),
    Nr(e, r))
}
function QF(e) {
    var t = e.memoizedState
      , r = 0;
    t !== null && (r = t.retryLane),
    Sk(e, r)
}
function GF(e, t) {
    var r = 0;
    switch (e.tag) {
    case 13:
        var n = e.stateNode
          , s = e.memoizedState;
        s !== null && (r = s.retryLane);
        break;
    case 19:
        n = e.stateNode;
        break;
    default:
        throw Error(V(314))
    }
    n !== null && n.delete(t),
    Sk(e, r)
}
var kk;
kk = function(e, t, r) {
    if (e !== null)
        if (e.memoizedProps !== t.pendingProps || Pr.current)
            Cr = !0;
        else {
            if (!(e.lanes & r) && !(t.flags & 128))
                return Cr = !1,
                LF(e, t, r);
            Cr = !!(e.flags & 131072)
        }
    else
        Cr = !1,
        it && t.flags & 1048576 && C2(t, sf, t.index);
    switch (t.lanes = 0,
    t.tag) {
    case 2:
        var n = t.type;
        md(e, t),
        e = t.pendingProps;
        var s = Io(t, sr.current);
        uo(t, r),
        s = Ig(null, t, n, e, s, r);
        var i = Rg();
        return t.flags |= 1,
        typeof s == "object" && s !== null && typeof s.render == "function" && s.$$typeof === void 0 ? (t.tag = 1,
        t.memoizedState = null,
        t.updateQueue = null,
        $r(n) ? (i = !0,
        rf(t)) : i = !1,
        t.memoizedState = s.state !== null && s.state !== void 0 ? s.state : null,
        Cg(t),
        s.updater = rh,
        t.stateNode = s,
        s._reactInternals = t,
        Ap(t, n, e, r),
        t = Fp(null, t, n, !0, i, r)) : (t.tag = 0,
        it && i && xg(t),
        cr(null, t, s, r),
        t = t.child),
        t;
    case 16:
        n = t.elementType;
        e: {
            switch (md(e, t),
            e = t.pendingProps,
            s = n._init,
            n = s(n._payload),
            t.type = n,
            s = t.tag = JF(n),
            e = ln(n, e),
            s) {
            case 0:
                t = Dp(null, t, n, e, r);
                break e;
            case 1:
                t = Lb(null, t, n, e, r);
                break e;
            case 11:
                t = Mb(null, t, n, e, r);
                break e;
            case 14:
                t = Ab(null, t, n, ln(n.type, e), r);
                break e
            }
            throw Error(V(306, n, ""))
        }
        return t;
    case 0:
        return n = t.type,
        s = t.pendingProps,
        s = t.elementType === n ? s : ln(n, s),
        Dp(e, t, n, s, r);
    case 1:
        return n = t.type,
        s = t.pendingProps,
        s = t.elementType === n ? s : ln(n, s),
        Lb(e, t, n, s, r);
    case 3:
        e: {
            if (ak(t),
            e === null)
                throw Error(V(387));
            n = t.pendingProps,
            i = t.memoizedState,
            s = i.element,
            R2(e, t),
            lf(t, n, null, r);
            var a = t.memoizedState;
            if (n = a.element,
            i.isDehydrated)
                if (i = {
                    element: n,
                    isDehydrated: !1,
                    cache: a.cache,
                    pendingSuspenseBoundaries: a.pendingSuspenseBoundaries,
                    transitions: a.transitions
                },
                t.updateQueue.baseState = i,
                t.memoizedState = i,
                t.flags & 256) {
                    s = Ao(Error(V(423)), t),
                    t = Db(e, t, n, r, s);
                    break e
                } else if (n !== s) {
                    s = Ao(Error(V(424)), t),
                    t = Db(e, t, n, r, s);
                    break e
                } else
                    for (Mr = ti(t.stateNode.containerInfo.firstChild),
                    Lr = t,
                    it = !0,
                    mn = null,
                    r = j2(t, null, n, r),
                    t.child = r; r; )
                        r.flags = r.flags & -3 | 4096,
                        r = r.sibling;
            else {
                if (Ro(),
                n === s) {
                    t = fs(e, t, r);
                    break e
                }
                cr(e, t, n, r)
            }
            t = t.child
        }
        return t;
    case 5:
        return O2(t),
        e === null && Rp(t),
        n = t.type,
        s = t.pendingProps,
        i = e !== null ? e.memoizedProps : null,
        a = s.children,
        Pp(n, s) ? a = null : i !== null && Pp(n, i) && (t.flags |= 32),
        ik(e, t),
        cr(e, t, a, r),
        t.child;
    case 6:
        return e === null && Rp(t),
        null;
    case 13:
        return ok(e, t, r);
    case 4:
        return Pg(t, t.stateNode.containerInfo),
        n = t.pendingProps,
        e === null ? t.child = Oo(t, null, n, r) : cr(e, t, n, r),
        t.child;
    case 11:
        return n = t.type,
        s = t.pendingProps,
        s = t.elementType === n ? s : ln(n, s),
        Mb(e, t, n, s, r);
    case 7:
        return cr(e, t, t.pendingProps, r),
        t.child;
    case 8:
        return cr(e, t, t.pendingProps.children, r),
        t.child;
    case 12:
        return cr(e, t, t.pendingProps.children, r),
        t.child;
    case 10:
        e: {
            if (n = t.type._context,
            s = t.pendingProps,
            i = t.memoizedProps,
            a = s.value,
            Ye(af, n._currentValue),
            n._currentValue = a,
            i !== null)
                if (kn(i.value, a)) {
                    if (i.children === s.children && !Pr.current) {
                        t = fs(e, t, r);
                        break e
                    }
                } else
                    for (i = t.child,
                    i !== null && (i.return = t); i !== null; ) {
                        var o = i.dependencies;
                        if (o !== null) {
                            a = i.child;
                            for (var l = o.firstContext; l !== null; ) {
                                if (l.context === n) {
                                    if (i.tag === 1) {
                                        l = ss(-1, r & -r),
                                        l.tag = 2;
                                        var c = i.updateQueue;
                                        if (c !== null) {
                                            c = c.shared;
                                            var f = c.pending;
                                            f === null ? l.next = l : (l.next = f.next,
                                            f.next = l),
                                            c.pending = l
                                        }
                                    }
                                    i.lanes |= r,
                                    l = i.alternate,
                                    l !== null && (l.lanes |= r),
                                    Op(i.return, r, t),
                                    o.lanes |= r;
                                    break
                                }
                                l = l.next
                            }
                        } else if (i.tag === 10)
                            a = i.type === t.type ? null : i.child;
                        else if (i.tag === 18) {
                            if (a = i.return,
                            a === null)
                                throw Error(V(341));
                            a.lanes |= r,
                            o = a.alternate,
                            o !== null && (o.lanes |= r),
                            Op(a, r, t),
                            a = i.sibling
                        } else
                            a = i.child;
                        if (a !== null)
                            a.return = i;
                        else
                            for (a = i; a !== null; ) {
                                if (a === t) {
                                    a = null;
                                    break
                                }
                                if (i = a.sibling,
                                i !== null) {
                                    i.return = a.return,
                                    a = i;
                                    break
                                }
                                a = a.return
                            }
                        i = a
                    }
            cr(e, t, s.children, r),
            t = t.child
        }
        return t;
    case 9:
        return s = t.type,
        n = t.pendingProps.children,
        uo(t, r),
        s = en(s),
        n = n(s),
        t.flags |= 1,
        cr(e, t, n, r),
        t.child;
    case 14:
        return n = t.type,
        s = ln(n, t.pendingProps),
        s = ln(n.type, s),
        Ab(e, t, n, s, r);
    case 15:
        return nk(e, t, t.type, t.pendingProps, r);
    case 17:
        return n = t.type,
        s = t.pendingProps,
        s = t.elementType === n ? s : ln(n, s),
        md(e, t),
        t.tag = 1,
        $r(n) ? (e = !0,
        rf(t)) : e = !1,
        uo(t, r),
        ek(t, n, s),
        Ap(t, n, s, r),
        Fp(null, t, n, !0, e, r);
    case 19:
        return lk(e, t, r);
    case 22:
        return sk(e, t, r)
    }
    throw Error(V(156, t.tag))
}
;
function Ek(e, t) {
    return YS(e, t)
}
function YF(e, t, r, n) {
    this.tag = e,
    this.key = r,
    this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null,
    this.index = 0,
    this.ref = null,
    this.pendingProps = t,
    this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null,
    this.mode = n,
    this.subtreeFlags = this.flags = 0,
    this.deletions = null,
    this.childLanes = this.lanes = 0,
    this.alternate = null
}
function Gr(e, t, r, n) {
    return new YF(e,t,r,n)
}
function Bg(e) {
    return e = e.prototype,
    !(!e || !e.isReactComponent)
}
function JF(e) {
    if (typeof e == "function")
        return Bg(e) ? 1 : 0;
    if (e != null) {
        if (e = e.$$typeof,
        e === lg)
            return 11;
        if (e === ug)
            return 14
    }
    return 2
}
function ii(e, t) {
    var r = e.alternate;
    return r === null ? (r = Gr(e.tag, t, e.key, e.mode),
    r.elementType = e.elementType,
    r.type = e.type,
    r.stateNode = e.stateNode,
    r.alternate = e,
    e.alternate = r) : (r.pendingProps = t,
    r.type = e.type,
    r.flags = 0,
    r.subtreeFlags = 0,
    r.deletions = null),
    r.flags = e.flags & 14680064,
    r.childLanes = e.childLanes,
    r.lanes = e.lanes,
    r.child = e.child,
    r.memoizedProps = e.memoizedProps,
    r.memoizedState = e.memoizedState,
    r.updateQueue = e.updateQueue,
    t = e.dependencies,
    r.dependencies = t === null ? null : {
        lanes: t.lanes,
        firstContext: t.firstContext
    },
    r.sibling = e.sibling,
    r.index = e.index,
    r.ref = e.ref,
    r
}
function gd(e, t, r, n, s, i) {
    var a = 2;
    if (n = e,
    typeof e == "function")
        Bg(e) && (a = 1);
    else if (typeof e == "string")
        a = 5;
    else
        e: switch (e) {
        case Wa:
            return ta(r.children, s, i, t);
        case og:
            a = 8,
            s |= 8;
            break;
        case ap:
            return e = Gr(12, r, t, s | 2),
            e.elementType = ap,
            e.lanes = i,
            e;
        case op:
            return e = Gr(13, r, t, s),
            e.elementType = op,
            e.lanes = i,
            e;
        case lp:
            return e = Gr(19, r, t, s),
            e.elementType = lp,
            e.lanes = i,
            e;
        case OS:
            return ih(r, s, i, t);
        default:
            if (typeof e == "object" && e !== null)
                switch (e.$$typeof) {
                case IS:
                    a = 10;
                    break e;
                case RS:
                    a = 9;
                    break e;
                case lg:
                    a = 11;
                    break e;
                case ug:
                    a = 14;
                    break e;
                case js:
                    a = 16,
                    n = null;
                    break e
                }
            throw Error(V(130, e == null ? e : typeof e, ""))
        }
    return t = Gr(a, r, t, s),
    t.elementType = e,
    t.type = n,
    t.lanes = i,
    t
}
function ta(e, t, r, n) {
    return e = Gr(7, e, n, t),
    e.lanes = r,
    e
}
function ih(e, t, r, n) {
    return e = Gr(22, e, n, t),
    e.elementType = OS,
    e.lanes = r,
    e.stateNode = {
        isHidden: !1
    },
    e
}
function am(e, t, r) {
    return e = Gr(6, e, null, t),
    e.lanes = r,
    e
}
function om(e, t, r) {
    return t = Gr(4, e.children !== null ? e.children : [], e.key, t),
    t.lanes = r,
    t.stateNode = {
        containerInfo: e.containerInfo,
        pendingChildren: null,
        implementation: e.implementation
    },
    t
}
function XF(e, t, r, n, s) {
    this.tag = t,
    this.containerInfo = e,
    this.finishedWork = this.pingCache = this.current = this.pendingChildren = null,
    this.timeoutHandle = -1,
    this.callbackNode = this.pendingContext = this.context = null,
    this.callbackPriority = 0,
    this.eventTimes = Uh(0),
    this.expirationTimes = Uh(-1),
    this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0,
    this.entanglements = Uh(0),
    this.identifierPrefix = n,
    this.onRecoverableError = s,
    this.mutableSourceEagerHydrationData = null
}
function Wg(e, t, r, n, s, i, a, o, l) {
    return e = new XF(e,t,r,o,l),
    t === 1 ? (t = 1,
    i === !0 && (t |= 8)) : t = 0,
    i = Gr(3, null, null, t),
    e.current = i,
    i.stateNode = e,
    i.memoizedState = {
        element: n,
        isDehydrated: r,
        cache: null,
        transitions: null,
        pendingSuspenseBoundaries: null
    },
    Cg(i),
    e
}
function ez(e, t, r) {
    var n = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
        $$typeof: Ba,
        key: n == null ? null : "" + n,
        children: e,
        containerInfo: t,
        implementation: r
    }
}
function _k(e) {
    if (!e)
        return mi;
    e = e._reactInternals;
    e: {
        if (ba(e) !== e || e.tag !== 1)
            throw Error(V(170));
        var t = e;
        do {
            switch (t.tag) {
            case 3:
                t = t.stateNode.context;
                break e;
            case 1:
                if ($r(t.type)) {
                    t = t.stateNode.__reactInternalMemoizedMergedChildContext;
                    break e
                }
            }
            t = t.return
        } while (t !== null);
        throw Error(V(171))
    }
    if (e.tag === 1) {
        var r = e.type;
        if ($r(r))
            return _2(e, r, t)
    }
    return t
}
function Tk(e, t, r, n, s, i, a, o, l) {
    return e = Wg(r, n, !0, e, s, i, a, o, l),
    e.context = _k(null),
    r = e.current,
    n = yr(),
    s = si(r),
    i = ss(n, s),
    i.callback = t ?? null,
    ri(r, i, s),
    e.current.lanes = s,
    Xu(e, s, n),
    Nr(e, n),
    e
}
function ah(e, t, r, n) {
    var s = t.current
      , i = yr()
      , a = si(s);
    return r = _k(r),
    t.context === null ? t.context = r : t.pendingContext = r,
    t = ss(i, a),
    t.payload = {
        element: e
    },
    n = n === void 0 ? null : n,
    n !== null && (t.callback = n),
    e = ri(s, t, a),
    e !== null && (wn(e, s, a, i),
    dd(e, s, a)),
    a
}
function yf(e) {
    if (e = e.current,
    !e.child)
        return null;
    switch (e.child.tag) {
    case 5:
        return e.child.stateNode;
    default:
        return e.child.stateNode
    }
}
function Kb(e, t) {
    if (e = e.memoizedState,
    e !== null && e.dehydrated !== null) {
        var r = e.retryLane;
        e.retryLane = r !== 0 && r < t ? r : t
    }
}
function qg(e, t) {
    Kb(e, t),
    (e = e.alternate) && Kb(e, t)
}
function tz() {
    return null
}
var Ck = typeof reportError == "function" ? reportError : function(e) {
    console.error(e)
}
;
function Hg(e) {
    this._internalRoot = e
}
oh.prototype.render = Hg.prototype.render = function(e) {
    var t = this._internalRoot;
    if (t === null)
        throw Error(V(409));
    ah(e, t, null, null)
}
;
oh.prototype.unmount = Hg.prototype.unmount = function() {
    var e = this._internalRoot;
    if (e !== null) {
        this._internalRoot = null;
        var t = e.containerInfo;
        ha(function() {
            ah(null, e, null, null)
        }),
        t[cs] = null
    }
}
;
function oh(e) {
    this._internalRoot = e
}
oh.prototype.unstable_scheduleHydration = function(e) {
    if (e) {
        var t = s2();
        e = {
            blockedOn: null,
            target: e,
            priority: t
        };
        for (var r = 0; r < Os.length && t !== 0 && t < Os[r].priority; r++)
            ;
        Os.splice(r, 0, e),
        r === 0 && a2(e)
    }
}
;
function Zg(e) {
    return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11)
}
function lh(e) {
    return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11 && (e.nodeType !== 8 || e.nodeValue !== " react-mount-point-unstable "))
}
function Qb() {}
function rz(e, t, r, n, s) {
    if (s) {
        if (typeof n == "function") {
            var i = n;
            n = function() {
                var c = yf(a);
                i.call(c)
            }
        }
        var a = Tk(t, n, e, 0, null, !1, !1, "", Qb);
        return e._reactRootContainer = a,
        e[cs] = a.current,
        Cu(e.nodeType === 8 ? e.parentNode : e),
        ha(),
        a
    }
    for (; s = e.lastChild; )
        e.removeChild(s);
    if (typeof n == "function") {
        var o = n;
        n = function() {
            var c = yf(l);
            o.call(c)
        }
    }
    var l = Wg(e, 0, !1, null, null, !1, !1, "", Qb);
    return e._reactRootContainer = l,
    e[cs] = l.current,
    Cu(e.nodeType === 8 ? e.parentNode : e),
    ha(function() {
        ah(t, l, r, n)
    }),
    l
}
function uh(e, t, r, n, s) {
    var i = r._reactRootContainer;
    if (i) {
        var a = i;
        if (typeof s == "function") {
            var o = s;
            s = function() {
                var l = yf(a);
                o.call(l)
            }
        }
        ah(t, a, e, s)
    } else
        a = rz(r, t, e, s, n);
    return yf(a)
}
r2 = function(e) {
    switch (e.tag) {
    case 3:
        var t = e.stateNode;
        if (t.current.memoizedState.isDehydrated) {
            var r = Ml(t.pendingLanes);
            r !== 0 && (fg(t, r | 1),
            Nr(t, Et()),
            !(Ae & 6) && (Lo = Et() + 500,
            xi()))
        }
        break;
    case 13:
        ha(function() {
            var n = ds(e, 1);
            if (n !== null) {
                var s = yr();
                wn(n, e, 1, s)
            }
        }),
        qg(e, 1)
    }
}
;
hg = function(e) {
    if (e.tag === 13) {
        var t = ds(e, 134217728);
        if (t !== null) {
            var r = yr();
            wn(t, e, 134217728, r)
        }
        qg(e, 134217728)
    }
}
;
n2 = function(e) {
    if (e.tag === 13) {
        var t = si(e)
          , r = ds(e, t);
        if (r !== null) {
            var n = yr();
            wn(r, e, t, n)
        }
        qg(e, t)
    }
}
;
s2 = function() {
    return Ze
}
;
i2 = function(e, t) {
    var r = Ze;
    try {
        return Ze = e,
        t()
    } finally {
        Ze = r
    }
}
;
vp = function(e, t, r) {
    switch (t) {
    case "input":
        if (dp(e, r),
        t = r.name,
        r.type === "radio" && t != null) {
            for (r = e; r.parentNode; )
                r = r.parentNode;
            for (r = r.querySelectorAll("input[name=" + JSON.stringify("" + t) + '][type="radio"]'),
            t = 0; t < r.length; t++) {
                var n = r[t];
                if (n !== e && n.form === e.form) {
                    var s = Xf(n);
                    if (!s)
                        throw Error(V(90));
                    AS(n),
                    dp(n, s)
                }
            }
        }
        break;
    case "textarea":
        DS(e, r);
        break;
    case "select":
        t = r.value,
        t != null && io(e, !!r.multiple, t, !1)
    }
}
;
qS = zg;
HS = ha;
var nz = {
    usingClientEntryPoint: !1,
    Events: [tc, Ka, Xf, BS, WS, zg]
}
  , wl = {
    findFiberByHostInstance: Li,
    bundleType: 0,
    version: "18.3.1",
    rendererPackageName: "react-dom"
}
  , sz = {
    bundleType: wl.bundleType,
    version: wl.version,
    rendererPackageName: wl.rendererPackageName,
    rendererConfig: wl.rendererConfig,
    overrideHookState: null,
    overrideHookStateDeletePath: null,
    overrideHookStateRenamePath: null,
    overrideProps: null,
    overridePropsDeletePath: null,
    overridePropsRenamePath: null,
    setErrorHandler: null,
    setSuspenseHandler: null,
    scheduleUpdate: null,
    currentDispatcherRef: vs.ReactCurrentDispatcher,
    findHostInstanceByFiber: function(e) {
        return e = QS(e),
        e === null ? null : e.stateNode
    },
    findFiberByHostInstance: wl.findFiberByHostInstance || tz,
    findHostInstancesForRefresh: null,
    scheduleRefresh: null,
    scheduleRoot: null,
    setRefreshHandler: null,
    getCurrentFiber: null,
    reconcilerVersion: "18.3.1-next-f1338f8080-20240426"
};
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var qc = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!qc.isDisabled && qc.supportsFiber)
        try {
            Qf = qc.inject(sz),
            zn = qc
        } catch {}
}
zr.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = nz;
zr.createPortal = function(e, t) {
    var r = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!Zg(t))
        throw Error(V(200));
    return ez(e, t, null, r)
}
;
zr.createRoot = function(e, t) {
    if (!Zg(e))
        throw Error(V(299));
    var r = !1
      , n = ""
      , s = Ck;
    return t != null && (t.unstable_strictMode === !0 && (r = !0),
    t.identifierPrefix !== void 0 && (n = t.identifierPrefix),
    t.onRecoverableError !== void 0 && (s = t.onRecoverableError)),
    t = Wg(e, 1, !1, null, null, r, !1, n, s),
    e[cs] = t.current,
    Cu(e.nodeType === 8 ? e.parentNode : e),
    new Hg(t)
}
;
zr.findDOMNode = function(e) {
    if (e == null)
        return null;
    if (e.nodeType === 1)
        return e;
    var t = e._reactInternals;
    if (t === void 0)
        throw typeof e.render == "function" ? Error(V(188)) : (e = Object.keys(e).join(","),
        Error(V(268, e)));
    return e = QS(t),
    e = e === null ? null : e.stateNode,
    e
}
;
zr.flushSync = function(e) {
    return ha(e)
}
;
zr.hydrate = function(e, t, r) {
    if (!lh(t))
        throw Error(V(200));
    return uh(null, e, t, !0, r)
}
;
zr.hydrateRoot = function(e, t, r) {
    if (!Zg(e))
        throw Error(V(405));
    var n = r != null && r.hydratedSources || null
      , s = !1
      , i = ""
      , a = Ck;
    if (r != null && (r.unstable_strictMode === !0 && (s = !0),
    r.identifierPrefix !== void 0 && (i = r.identifierPrefix),
    r.onRecoverableError !== void 0 && (a = r.onRecoverableError)),
    t = Tk(t, null, e, 1, r ?? null, s, !1, i, a),
    e[cs] = t.current,
    Cu(e),
    n)
        for (e = 0; e < n.length; e++)
            r = n[e],
            s = r._getVersion,
            s = s(r._source),
            t.mutableSourceEagerHydrationData == null ? t.mutableSourceEagerHydrationData = [r, s] : t.mutableSourceEagerHydrationData.push(r, s);
    return new oh(t)
}
;
zr.render = function(e, t, r) {
    if (!lh(t))
        throw Error(V(200));
    return uh(null, e, t, !1, r)
}
;
zr.unmountComponentAtNode = function(e) {
    if (!lh(e))
        throw Error(V(40));
    return e._reactRootContainer ? (ha(function() {
        uh(null, null, e, !1, function() {
            e._reactRootContainer = null,
            e[cs] = null
        })
    }),
    !0) : !1
}
;
zr.unstable_batchedUpdates = zg;
zr.unstable_renderSubtreeIntoContainer = function(e, t, r, n) {
    if (!lh(r))
        throw Error(V(200));
    if (e == null || e._reactInternals === void 0)
        throw Error(V(38));
    return uh(e, t, r, !1, n)
}
;
zr.version = "18.3.1-next-f1338f8080-20240426";
function Pk() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
        try {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(Pk)
        } catch (e) {
            console.error(e)
        }
}
Pk(),
PS.exports = zr;
var ch = PS.exports;
const iz = _y(ch)
  , az = z1({
    __proto__: null,
    default: iz
}, [ch]);
/**
 * @remix-run/router v1.23.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function st() {
    return st = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var r = arguments[t];
            for (var n in r)
                Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n])
        }
        return e
    }
    ,
    st.apply(this, arguments)
}
var Pt;
(function(e) {
    e.Pop = "POP",
    e.Push = "PUSH",
    e.Replace = "REPLACE"
}
)(Pt || (Pt = {}));
const Gb = "popstate";
function oz(e) {
    e === void 0 && (e = {});
    function t(n, s) {
        let {pathname: i, search: a, hash: o} = n.location;
        return Au("", {
            pathname: i,
            search: a,
            hash: o
        }, s.state && s.state.usr || null, s.state && s.state.key || "default")
    }
    function r(n, s) {
        return typeof s == "string" ? s : ma(s)
    }
    return uz(t, r, null, e)
}
function Ne(e, t) {
    if (e === !1 || e === null || typeof e > "u")
        throw new Error(t)
}
function Do(e, t) {
    if (!e) {
        typeof console < "u" && console.warn(t);
        try {
            throw new Error(t)
        } catch {}
    }
}
function lz() {
    return Math.random().toString(36).substr(2, 8)
}
function Yb(e, t) {
    return {
        usr: e.state,
        key: e.key,
        idx: t
    }
}
function Au(e, t, r, n) {
    return r === void 0 && (r = null),
    st({
        pathname: typeof e == "string" ? e : e.pathname,
        search: "",
        hash: ""
    }, typeof t == "string" ? wi(t) : t, {
        state: r,
        key: t && t.key || n || lz()
    })
}
function ma(e) {
    let {pathname: t="/", search: r="", hash: n=""} = e;
    return r && r !== "?" && (t += r.charAt(0) === "?" ? r : "?" + r),
    n && n !== "#" && (t += n.charAt(0) === "#" ? n : "#" + n),
    t
}
function wi(e) {
    let t = {};
    if (e) {
        let r = e.indexOf("#");
        r >= 0 && (t.hash = e.substr(r),
        e = e.substr(0, r));
        let n = e.indexOf("?");
        n >= 0 && (t.search = e.substr(n),
        e = e.substr(0, n)),
        e && (t.pathname = e)
    }
    return t
}
function uz(e, t, r, n) {
    n === void 0 && (n = {});
    let {window: s=document.defaultView, v5Compat: i=!1} = n
      , a = s.history
      , o = Pt.Pop
      , l = null
      , c = f();
    c == null && (c = 0,
    a.replaceState(st({}, a.state, {
        idx: c
    }), ""));
    function f() {
        return (a.state || {
            idx: null
        }).idx
    }
    function h() {
        o = Pt.Pop;
        let w = f()
          , v = w == null ? null : w - c;
        c = w,
        l && l({
            action: o,
            location: x.location,
            delta: v
        })
    }
    function m(w, v) {
        o = Pt.Push;
        let p = Au(x.location, w, v);
        c = f() + 1;
        let S = Yb(p, c)
          , P = x.createHref(p);
        try {
            a.pushState(S, "", P)
        } catch (j) {
            if (j instanceof DOMException && j.name === "DataCloneError")
                throw j;
            s.location.assign(P)
        }
        i && l && l({
            action: o,
            location: x.location,
            delta: 1
        })
    }
    function y(w, v) {
        o = Pt.Replace;
        let p = Au(x.location, w, v);
        c = f();
        let S = Yb(p, c)
          , P = x.createHref(p);
        a.replaceState(S, "", P),
        i && l && l({
            action: o,
            location: x.location,
            delta: 0
        })
    }
    function k(w) {
        let v = s.location.origin !== "null" ? s.location.origin : s.location.href
          , p = typeof w == "string" ? w : ma(w);
        return p = p.replace(/ $/, "%20"),
        Ne(v, "No window.location.(origin|href) available to create URL for href: " + p),
        new URL(p,v)
    }
    let x = {
        get action() {
            return o
        },
        get location() {
            return e(s, a)
        },
        listen(w) {
            if (l)
                throw new Error("A history only accepts one active listener");
            return s.addEventListener(Gb, h),
            l = w,
            () => {
                s.removeEventListener(Gb, h),
                l = null
            }
        },
        createHref(w) {
            return t(s, w)
        },
        createURL: k,
        encodeLocation(w) {
            let v = k(w);
            return {
                pathname: v.pathname,
                search: v.search,
                hash: v.hash
            }
        },
        push: m,
        replace: y,
        go(w) {
            return a.go(w)
        }
    };
    return x
}
var He;
(function(e) {
    e.data = "data",
    e.deferred = "deferred",
    e.redirect = "redirect",
    e.error = "error"
}
)(He || (He = {}));
const cz = new Set(["lazy", "caseSensitive", "path", "id", "index", "children"]);
function dz(e) {
    return e.index === !0
}
function gf(e, t, r, n) {
    return r === void 0 && (r = []),
    n === void 0 && (n = {}),
    e.map( (s, i) => {
        let a = [...r, String(i)]
          , o = typeof s.id == "string" ? s.id : a.join("-");
        if (Ne(s.index !== !0 || !s.children, "Cannot specify children on an index route"),
        Ne(!n[o], 'Found a route id collision on id "' + o + `".  Route id's must be globally unique within Data Router usages`),
        dz(s)) {
            let l = st({}, s, t(s), {
                id: o
            });
            return n[o] = l,
            l
        } else {
            let l = st({}, s, t(s), {
                id: o,
                children: void 0
            });
            return n[o] = l,
            s.children && (l.children = gf(s.children, t, a, n)),
            l
        }
    }
    )
}
function Mi(e, t, r) {
    return r === void 0 && (r = "/"),
    vd(e, t, r, !1)
}
function vd(e, t, r, n) {
    let s = typeof t == "string" ? wi(t) : t
      , i = hs(s.pathname || "/", r);
    if (i == null)
        return null;
    let a = $k(e);
    hz(a);
    let o = null;
    for (let l = 0; o == null && l < a.length; ++l) {
        let c = Ez(i);
        o = Sz(a[l], c, n)
    }
    return o
}
function fz(e, t) {
    let {route: r, pathname: n, params: s} = e;
    return {
        id: r.id,
        pathname: n,
        params: s,
        data: t[r.id],
        handle: r.handle
    }
}
function $k(e, t, r, n) {
    t === void 0 && (t = []),
    r === void 0 && (r = []),
    n === void 0 && (n = "");
    let s = (i, a, o) => {
        let l = {
            relativePath: o === void 0 ? i.path || "" : o,
            caseSensitive: i.caseSensitive === !0,
            childrenIndex: a,
            route: i
        };
        l.relativePath.startsWith("/") && (Ne(l.relativePath.startsWith(n), 'Absolute route path "' + l.relativePath + '" nested under path ' + ('"' + n + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes."),
        l.relativePath = l.relativePath.slice(n.length));
        let c = is([n, l.relativePath])
          , f = r.concat(l);
        i.children && i.children.length > 0 && (Ne(i.index !== !0, "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + c + '".')),
        $k(i.children, t, f, c)),
        !(i.path == null && !i.index) && t.push({
            path: c,
            score: xz(c, i.index),
            routesMeta: f
        })
    }
    ;
    return e.forEach( (i, a) => {
        var o;
        if (i.path === "" || !((o = i.path) != null && o.includes("?")))
            s(i, a);
        else
            for (let l of Nk(i.path))
                s(i, a, l)
    }
    ),
    t
}
function Nk(e) {
    let t = e.split("/");
    if (t.length === 0)
        return [];
    let[r,...n] = t
      , s = r.endsWith("?")
      , i = r.replace(/\?$/, "");
    if (n.length === 0)
        return s ? [i, ""] : [i];
    let a = Nk(n.join("/"))
      , o = [];
    return o.push(...a.map(l => l === "" ? i : [i, l].join("/"))),
    s && o.push(...a),
    o.map(l => e.startsWith("/") && l === "" ? "/" : l)
}
function hz(e) {
    e.sort( (t, r) => t.score !== r.score ? r.score - t.score : wz(t.routesMeta.map(n => n.childrenIndex), r.routesMeta.map(n => n.childrenIndex)))
}
const mz = /^:[\w-]+$/
  , pz = 3
  , yz = 2
  , gz = 1
  , vz = 10
  , bz = -2
  , Jb = e => e === "*";
function xz(e, t) {
    let r = e.split("/")
      , n = r.length;
    return r.some(Jb) && (n += bz),
    t && (n += yz),
    r.filter(s => !Jb(s)).reduce( (s, i) => s + (mz.test(i) ? pz : i === "" ? gz : vz), n)
}
function wz(e, t) {
    return e.length === t.length && e.slice(0, -1).every( (n, s) => n === t[s]) ? e[e.length - 1] - t[t.length - 1] : 0
}
function Sz(e, t, r) {
    r === void 0 && (r = !1);
    let {routesMeta: n} = e
      , s = {}
      , i = "/"
      , a = [];
    for (let o = 0; o < n.length; ++o) {
        let l = n[o]
          , c = o === n.length - 1
          , f = i === "/" ? t : t.slice(i.length) || "/"
          , h = vf({
            path: l.relativePath,
            caseSensitive: l.caseSensitive,
            end: c
        }, f)
          , m = l.route;
        if (!h && c && r && !n[n.length - 1].route.index && (h = vf({
            path: l.relativePath,
            caseSensitive: l.caseSensitive,
            end: !1
        }, f)),
        !h)
            return null;
        Object.assign(s, h.params),
        a.push({
            params: s,
            pathname: is([i, h.pathname]),
            pathnameBase: Cz(is([i, h.pathnameBase])),
            route: m
        }),
        h.pathnameBase !== "/" && (i = is([i, h.pathnameBase]))
    }
    return a
}
function vf(e, t) {
    typeof e == "string" && (e = {
        path: e,
        caseSensitive: !1,
        end: !0
    });
    let[r,n] = kz(e.path, e.caseSensitive, e.end)
      , s = t.match(r);
    if (!s)
        return null;
    let i = s[0]
      , a = i.replace(/(.)\/+$/, "$1")
      , o = s.slice(1);
    return {
        params: n.reduce( (c, f, h) => {
            let {paramName: m, isOptional: y} = f;
            if (m === "*") {
                let x = o[h] || "";
                a = i.slice(0, i.length - x.length).replace(/(.)\/+$/, "$1")
            }
            const k = o[h];
            return y && !k ? c[m] = void 0 : c[m] = (k || "").replace(/%2F/g, "/"),
            c
        }
        , {}),
        pathname: i,
        pathnameBase: a,
        pattern: e
    }
}
function kz(e, t, r) {
    t === void 0 && (t = !1),
    r === void 0 && (r = !0),
    Do(e === "*" || !e.endsWith("*") || e.endsWith("/*"), 'Route path "' + e + '" will be treated as if it were ' + ('"' + e.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + e.replace(/\*$/, "/*") + '".'));
    let n = []
      , s = "^" + e.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (a, o, l) => (n.push({
        paramName: o,
        isOptional: l != null
    }),
    l ? "/?([^\\/]+)?" : "/([^\\/]+)"));
    return e.endsWith("*") ? (n.push({
        paramName: "*"
    }),
    s += e === "*" || e === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : r ? s += "\\/*$" : e !== "" && e !== "/" && (s += "(?:(?=\\/|$))"),
    [new RegExp(s,t ? void 0 : "i"), n]
}
function Ez(e) {
    try {
        return e.split("/").map(t => decodeURIComponent(t).replace(/\//g, "%2F")).join("/")
    } catch (t) {
        return Do(!1, 'The URL path "' + e + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + t + ").")),
        e
    }
}
function hs(e, t) {
    if (t === "/")
        return e;
    if (!e.toLowerCase().startsWith(t.toLowerCase()))
        return null;
    let r = t.endsWith("/") ? t.length - 1 : t.length
      , n = e.charAt(r);
    return n && n !== "/" ? null : e.slice(r) || "/"
}
function _z(e, t) {
    t === void 0 && (t = "/");
    let {pathname: r, search: n="", hash: s=""} = typeof e == "string" ? wi(e) : e;
    return {
        pathname: r ? r.startsWith("/") ? r : Tz(r, t) : t,
        search: Pz(n),
        hash: $z(s)
    }
}
function Tz(e, t) {
    let r = t.replace(/\/+$/, "").split("/");
    return e.split("/").forEach(s => {
        s === ".." ? r.length > 1 && r.pop() : s !== "." && r.push(s)
    }
    ),
    r.length > 1 ? r.join("/") : "/"
}
function lm(e, t, r, n) {
    return "Cannot include a '" + e + "' character in a manually specified " + ("`to." + t + "` field [" + JSON.stringify(n) + "].  Please separate it out to the ") + ("`to." + r + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.'
}
function jk(e) {
    return e.filter( (t, r) => r === 0 || t.route.path && t.route.path.length > 0)
}
function Kg(e, t) {
    let r = jk(e);
    return t ? r.map( (n, s) => s === r.length - 1 ? n.pathname : n.pathnameBase) : r.map(n => n.pathnameBase)
}
function Qg(e, t, r, n) {
    n === void 0 && (n = !1);
    let s;
    typeof e == "string" ? s = wi(e) : (s = st({}, e),
    Ne(!s.pathname || !s.pathname.includes("?"), lm("?", "pathname", "search", s)),
    Ne(!s.pathname || !s.pathname.includes("#"), lm("#", "pathname", "hash", s)),
    Ne(!s.search || !s.search.includes("#"), lm("#", "search", "hash", s)));
    let i = e === "" || s.pathname === "", a = i ? "/" : s.pathname, o;
    if (a == null)
        o = r;
    else {
        let h = t.length - 1;
        if (!n && a.startsWith("..")) {
            let m = a.split("/");
            for (; m[0] === ".."; )
                m.shift(),
                h -= 1;
            s.pathname = m.join("/")
        }
        o = h >= 0 ? t[h] : "/"
    }
    let l = _z(s, o)
      , c = a && a !== "/" && a.endsWith("/")
      , f = (i || a === ".") && r.endsWith("/");
    return !l.pathname.endsWith("/") && (c || f) && (l.pathname += "/"),
    l
}
const is = e => e.join("/").replace(/\/\/+/g, "/")
  , Cz = e => e.replace(/\/+$/, "").replace(/^\/*/, "/")
  , Pz = e => !e || e === "?" ? "" : e.startsWith("?") ? e : "?" + e
  , $z = e => !e || e === "#" ? "" : e.startsWith("#") ? e : "#" + e;
class bf {
    constructor(t, r, n, s) {
        s === void 0 && (s = !1),
        this.status = t,
        this.statusText = r || "",
        this.internal = s,
        n instanceof Error ? (this.data = n.toString(),
        this.error = n) : this.data = n
    }
}
function Lu(e) {
    return e != null && typeof e.status == "number" && typeof e.statusText == "string" && typeof e.internal == "boolean" && "data"in e
}
const Ik = ["post", "put", "patch", "delete"]
  , Nz = new Set(Ik)
  , jz = ["get", ...Ik]
  , Iz = new Set(jz)
  , Rz = new Set([301, 302, 303, 307, 308])
  , Oz = new Set([307, 308])
  , um = {
    state: "idle",
    location: void 0,
    formMethod: void 0,
    formAction: void 0,
    formEncType: void 0,
    formData: void 0,
    json: void 0,
    text: void 0
}
  , Mz = {
    state: "idle",
    data: void 0,
    formMethod: void 0,
    formAction: void 0,
    formEncType: void 0,
    formData: void 0,
    json: void 0,
    text: void 0
}
  , Sl = {
    state: "unblocked",
    proceed: void 0,
    reset: void 0,
    location: void 0
}
  , Gg = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i
  , Az = e => ({
    hasErrorBoundary: !!e.hasErrorBoundary
})
  , Rk = "remix-router-transitions";
function Lz(e) {
    const t = e.window ? e.window : typeof window < "u" ? window : void 0
      , r = typeof t < "u" && typeof t.document < "u" && typeof t.document.createElement < "u"
      , n = !r;
    Ne(e.routes.length > 0, "You must provide a non-empty routes array to createRouter");
    let s;
    if (e.mapRouteProperties)
        s = e.mapRouteProperties;
    else if (e.detectErrorBoundary) {
        let T = e.detectErrorBoundary;
        s = N => ({
            hasErrorBoundary: T(N)
        })
    } else
        s = Az;
    let i = {}, a = gf(e.routes, s, void 0, i), o, l = e.basename || "/", c = e.dataStrategy || Uz, f = e.patchRoutesOnNavigation, h = st({
        v7_fetcherPersist: !1,
        v7_normalizeFormMethod: !1,
        v7_partialHydration: !1,
        v7_prependBasename: !1,
        v7_relativeSplatPath: !1,
        v7_skipActionErrorRevalidation: !1
    }, e.future), m = null, y = new Set, k = null, x = null, w = null, v = e.hydrationData != null, p = Mi(a, e.history.location, l), S = !1, P = null;
    if (p == null && !f) {
        let T = Er(404, {
            pathname: e.history.location.pathname
        })
          , {matches: N, route: R} = ux(a);
        p = N,
        P = {
            [R.id]: T
        }
    }
    p && !e.hydrationData && gc(p, a, e.history.location.pathname).active && (p = null);
    let j;
    if (p)
        if (p.some(T => T.route.lazy))
            j = !1;
        else if (!p.some(T => T.route.loader))
            j = !0;
        else if (h.v7_partialHydration) {
            let T = e.hydrationData ? e.hydrationData.loaderData : null
              , N = e.hydrationData ? e.hydrationData.errors : null;
            if (N) {
                let R = p.findIndex(F => N[F.route.id] !== void 0);
                j = p.slice(0, R + 1).every(F => !Jp(F.route, T, N))
            } else
                j = p.every(R => !Jp(R.route, T, N))
        } else
            j = e.hydrationData != null;
    else if (j = !1,
    p = [],
    h.v7_partialHydration) {
        let T = gc(null, a, e.history.location.pathname);
        T.active && T.matches && (S = !0,
        p = T.matches)
    }
    let L, E = {
        historyAction: e.history.action,
        location: e.history.location,
        matches: p,
        initialized: j,
        navigation: um,
        restoreScrollPosition: e.hydrationData != null ? !1 : null,
        preventScrollReset: !1,
        revalidation: "idle",
        loaderData: e.hydrationData && e.hydrationData.loaderData || {},
        actionData: e.hydrationData && e.hydrationData.actionData || null,
        errors: e.hydrationData && e.hydrationData.errors || P,
        fetchers: new Map,
        blockers: new Map
    }, b = Pt.Pop, O = !1, M, D = !1, z = new Map, $ = null, Y = !1, ce = !1, Ke = [], xt = new Set, B = new Map, he = 0, me = -1, De = new Map, Fe = new Set, Ir = new Map, Qt = new Map, zt = new Set, It = new Map, or = new Map, xs;
    function hc() {
        if (m = e.history.listen(T => {
            let {action: N, location: R, delta: F} = T;
            if (xs) {
                xs(),
                xs = void 0;
                return
            }
            Do(or.size === 0 || F != null, "You are trying to use a blocker on a POP navigation to a location that was not created by @remix-run/router. This will fail silently in production. This can happen if you are navigating outside the router via `window.history.pushState`/`window.location.hash` instead of using router navigation APIs.  This can also happen if you are using createHashRouter and the user manually changes the URL.");
            let Z = zv({
                currentLocation: E.location,
                nextLocation: R,
                historyAction: N
            });
            if (Z && F != null) {
                let ue = new Promise(be => {
                    xs = be
                }
                );
                e.history.go(F * -1),
                yc(Z, {
                    state: "blocked",
                    location: R,
                    proceed() {
                        yc(Z, {
                            state: "proceeding",
                            proceed: void 0,
                            reset: void 0,
                            location: R
                        }),
                        ue.then( () => e.history.go(F))
                    },
                    reset() {
                        let be = new Map(E.blockers);
                        be.set(Z, Sl),
                        Ut({
                            blockers: be
                        })
                    }
                });
                return
            }
            return ws(N, R)
        }
        ),
        r) {
            t7(t, z);
            let T = () => r7(t, z);
            t.addEventListener("pagehide", T),
            $ = () => t.removeEventListener("pagehide", T)
        }
        return E.initialized || ws(Pt.Pop, E.location, {
            initialHydration: !0
        }),
        L
    }
    function kh() {
        m && m(),
        $ && $(),
        y.clear(),
        M && M.abort(),
        E.fetchers.forEach( (T, N) => Ss(N)),
        E.blockers.forEach( (T, N) => Fv(N))
    }
    function mc(T) {
        return y.add(T),
        () => y.delete(T)
    }
    function Ut(T, N) {
        N === void 0 && (N = {}),
        E = st({}, E, T);
        let R = []
          , F = [];
        h.v7_fetcherPersist && E.fetchers.forEach( (Z, ue) => {
            Z.state === "idle" && (zt.has(ue) ? F.push(ue) : R.push(ue))
        }
        ),
        zt.forEach(Z => {
            !E.fetchers.has(Z) && !B.has(Z) && F.push(Z)
        }
        ),
        [...y].forEach(Z => Z(E, {
            deletedFetchers: F,
            viewTransitionOpts: N.viewTransitionOpts,
            flushSync: N.flushSync === !0
        })),
        h.v7_fetcherPersist ? (R.forEach(Z => E.fetchers.delete(Z)),
        F.forEach(Z => Ss(Z))) : F.forEach(Z => zt.delete(Z))
    }
    function Wn(T, N, R) {
        var F, Z;
        let {flushSync: ue} = R === void 0 ? {} : R, be = E.actionData != null && E.navigation.formMethod != null && fn(E.navigation.formMethod) && E.navigation.state === "loading" && ((F = T.state) == null ? void 0 : F._isRedirect) !== !0, re;
        N.actionData ? Object.keys(N.actionData).length > 0 ? re = N.actionData : re = null : be ? re = E.actionData : re = null;
        let se = N.loaderData ? ox(E.loaderData, N.loaderData, N.matches || [], N.errors) : E.loaderData
          , te = E.blockers;
        te.size > 0 && (te = new Map(te),
        te.forEach( (Re, Bt) => te.set(Bt, Sl)));
        let oe = O === !0 || E.navigation.formMethod != null && fn(E.navigation.formMethod) && ((Z = T.state) == null ? void 0 : Z._isRedirect) !== !0;
        o && (a = o,
        o = void 0),
        Y || b === Pt.Pop || (b === Pt.Push ? e.history.push(T, T.state) : b === Pt.Replace && e.history.replace(T, T.state));
        let Ce;
        if (b === Pt.Pop) {
            let Re = z.get(E.location.pathname);
            Re && Re.has(T.pathname) ? Ce = {
                currentLocation: E.location,
                nextLocation: T
            } : z.has(T.pathname) && (Ce = {
                currentLocation: T,
                nextLocation: E.location
            })
        } else if (D) {
            let Re = z.get(E.location.pathname);
            Re ? Re.add(T.pathname) : (Re = new Set([T.pathname]),
            z.set(E.location.pathname, Re)),
            Ce = {
                currentLocation: E.location,
                nextLocation: T
            }
        }
        Ut(st({}, N, {
            actionData: re,
            loaderData: se,
            historyAction: b,
            location: T,
            initialized: !0,
            navigation: um,
            revalidation: "idle",
            restoreScrollPosition: Vv(T, N.matches || E.matches),
            preventScrollReset: oe,
            blockers: te
        }), {
            viewTransitionOpts: Ce,
            flushSync: ue === !0
        }),
        b = Pt.Pop,
        O = !1,
        D = !1,
        Y = !1,
        ce = !1,
        Ke = []
    }
    async function ol(T, N) {
        if (typeof T == "number") {
            e.history.go(T);
            return
        }
        let R = Yp(E.location, E.matches, l, h.v7_prependBasename, T, h.v7_relativeSplatPath, N == null ? void 0 : N.fromRouteId, N == null ? void 0 : N.relative)
          , {path: F, submission: Z, error: ue} = Xb(h.v7_normalizeFormMethod, !1, R, N)
          , be = E.location
          , re = Au(E.location, F, N && N.state);
        re = st({}, re, e.history.encodeLocation(re));
        let se = N && N.replace != null ? N.replace : void 0
          , te = Pt.Push;
        se === !0 ? te = Pt.Replace : se === !1 || Z != null && fn(Z.formMethod) && Z.formAction === E.location.pathname + E.location.search && (te = Pt.Replace);
        let oe = N && "preventScrollReset"in N ? N.preventScrollReset === !0 : void 0
          , Ce = (N && N.flushSync) === !0
          , Re = zv({
            currentLocation: be,
            nextLocation: re,
            historyAction: te
        });
        if (Re) {
            yc(Re, {
                state: "blocked",
                location: re,
                proceed() {
                    yc(Re, {
                        state: "proceeding",
                        proceed: void 0,
                        reset: void 0,
                        location: re
                    }),
                    ol(T, N)
                },
                reset() {
                    let Bt = new Map(E.blockers);
                    Bt.set(Re, Sl),
                    Ut({
                        blockers: Bt
                    })
                }
            });
            return
        }
        return await ws(te, re, {
            submission: Z,
            pendingError: ue,
            preventScrollReset: oe,
            replace: N && N.replace,
            enableViewTransition: N && N.viewTransition,
            flushSync: Ce
        })
    }
    function Av() {
        if (ft(),
        Ut({
            revalidation: "loading"
        }),
        E.navigation.state !== "submitting") {
            if (E.navigation.state === "idle") {
                ws(E.historyAction, E.location, {
                    startUninterruptedRevalidation: !0
                });
                return
            }
            ws(b || E.historyAction, E.navigation.location, {
                overrideNavigation: E.navigation,
                enableViewTransition: D === !0
            })
        }
    }
    async function ws(T, N, R) {
        M && M.abort(),
        M = null,
        b = T,
        Y = (R && R.startUninterruptedRevalidation) === !0,
        fT(E.location, E.matches),
        O = (R && R.preventScrollReset) === !0,
        D = (R && R.enableViewTransition) === !0;
        let F = o || a
          , Z = R && R.overrideNavigation
          , ue = R != null && R.initialHydration && E.matches && E.matches.length > 0 && !S ? E.matches : Mi(F, N, l)
          , be = (R && R.flushSync) === !0;
        if (ue && E.initialized && !ce && Zz(E.location, N) && !(R && R.submission && fn(R.submission.formMethod))) {
            Wn(N, {
                matches: ue
            }, {
                flushSync: be
            });
            return
        }
        let re = gc(ue, F, N.pathname);
        if (re.active && re.matches && (ue = re.matches),
        !ue) {
            let {error: Ge, notFoundMatches: ze, route: ht} = _h(N.pathname);
            Wn(N, {
                matches: ze,
                loaderData: {},
                errors: {
                    [ht.id]: Ge
                }
            }, {
                flushSync: be
            });
            return
        }
        M = new AbortController;
        let se = Na(e.history, N, M.signal, R && R.submission), te;
        if (R && R.pendingError)
            te = [Ai(ue).route.id, {
                type: He.error,
                error: R.pendingError
            }];
        else if (R && R.submission && fn(R.submission.formMethod)) {
            let Ge = await Lv(se, N, R.submission, ue, re.active, {
                replace: R.replace,
                flushSync: be
            });
            if (Ge.shortCircuited)
                return;
            if (Ge.pendingActionResult) {
                let[ze,ht] = Ge.pendingActionResult;
                if (Or(ht) && Lu(ht.error) && ht.error.status === 404) {
                    M = null,
                    Wn(N, {
                        matches: Ge.matches,
                        loaderData: {},
                        errors: {
                            [ze]: ht.error
                        }
                    });
                    return
                }
            }
            ue = Ge.matches || ue,
            te = Ge.pendingActionResult,
            Z = cm(N, R.submission),
            be = !1,
            re.active = !1,
            se = Na(e.history, se.url, se.signal)
        }
        let {shortCircuited: oe, matches: Ce, loaderData: Re, errors: Bt} = await C(se, N, ue, re.active, Z, R && R.submission, R && R.fetcherSubmission, R && R.replace, R && R.initialHydration === !0, be, te);
        oe || (M = null,
        Wn(N, st({
            matches: Ce || ue
        }, lx(te), {
            loaderData: Re,
            errors: Bt
        })))
    }
    async function Lv(T, N, R, F, Z, ue) {
        ue === void 0 && (ue = {}),
        ft();
        let be = Xz(N, R);
        if (Ut({
            navigation: be
        }, {
            flushSync: ue.flushSync === !0
        }),
        Z) {
            let te = await vc(F, N.pathname, T.signal);
            if (te.type === "aborted")
                return {
                    shortCircuited: !0
                };
            if (te.type === "error") {
                let oe = Ai(te.partialMatches).route.id;
                return {
                    matches: te.partialMatches,
                    pendingActionResult: [oe, {
                        type: He.error,
                        error: te.error
                    }]
                }
            } else if (te.matches)
                F = te.matches;
            else {
                let {notFoundMatches: oe, error: Ce, route: Re} = _h(N.pathname);
                return {
                    matches: oe,
                    pendingActionResult: [Re.id, {
                        type: He.error,
                        error: Ce
                    }]
                }
            }
        }
        let re, se = Ll(F, N);
        if (!se.route.action && !se.route.lazy)
            re = {
                type: He.error,
                error: Er(405, {
                    method: T.method,
                    pathname: N.pathname,
                    routeId: se.route.id
                })
            };
        else if (re = (await Ee("action", E, T, [se], F, null))[se.route.id],
        T.signal.aborted)
            return {
                shortCircuited: !0
            };
        if (zi(re)) {
            let te;
            return ue && ue.replace != null ? te = ue.replace : te = sx(re.response.headers.get("Location"), new URL(T.url), l) === E.location.pathname + E.location.search,
            await ae(T, re, !0, {
                submission: R,
                replace: te
            }),
            {
                shortCircuited: !0
            }
        }
        if (Gs(re))
            throw Er(400, {
                type: "defer-action"
            });
        if (Or(re)) {
            let te = Ai(F, se.route.id);
            return (ue && ue.replace) !== !0 && (b = Pt.Push),
            {
                matches: F,
                pendingActionResult: [te.route.id, re]
            }
        }
        return {
            matches: F,
            pendingActionResult: [se.route.id, re]
        }
    }
    async function C(T, N, R, F, Z, ue, be, re, se, te, oe) {
        let Ce = Z || cm(N, ue)
          , Re = ue || be || dx(Ce)
          , Bt = !Y && (!h.v7_partialHydration || !se);
        if (F) {
            if (Bt) {
                let mt = I(oe);
                Ut(st({
                    navigation: Ce
                }, mt !== void 0 ? {
                    actionData: mt
                } : {}), {
                    flushSync: te
                })
            }
            let Le = await vc(R, N.pathname, T.signal);
            if (Le.type === "aborted")
                return {
                    shortCircuited: !0
                };
            if (Le.type === "error") {
                let mt = Ai(Le.partialMatches).route.id;
                return {
                    matches: Le.partialMatches,
                    loaderData: {},
                    errors: {
                        [mt]: Le.error
                    }
                }
            } else if (Le.matches)
                R = Le.matches;
            else {
                let {error: mt, notFoundMatches: _a, route: dl} = _h(N.pathname);
                return {
                    matches: _a,
                    loaderData: {},
                    errors: {
                        [dl.id]: mt
                    }
                }
            }
        }
        let Ge = o || a
          , [ze,ht] = tx(e.history, E, R, Re, N, h.v7_partialHydration && se === !0, h.v7_skipActionErrorRevalidation, ce, Ke, xt, zt, Ir, Fe, Ge, l, oe);
        if (Th(Le => !(R && R.some(mt => mt.route.id === Le)) || ze && ze.some(mt => mt.route.id === Le)),
        me = ++he,
        ze.length === 0 && ht.length === 0) {
            let Le = ll();
            return Wn(N, st({
                matches: R,
                loaderData: {},
                errors: oe && Or(oe[1]) ? {
                    [oe[0]]: oe[1].error
                } : null
            }, lx(oe), Le ? {
                fetchers: new Map(E.fetchers)
            } : {}), {
                flushSync: te
            }),
            {
                shortCircuited: !0
            }
        }
        if (Bt) {
            let Le = {};
            if (!F) {
                Le.navigation = Ce;
                let mt = I(oe);
                mt !== void 0 && (Le.actionData = mt)
            }
            ht.length > 0 && (Le.fetchers = A(ht)),
            Ut(Le, {
                flushSync: te
            })
        }
        ht.forEach(Le => {
            nn(Le.key),
            Le.controller && B.set(Le.key, Le.controller)
        }
        );
        let Ea = () => ht.forEach(Le => nn(Le.key));
        M && M.signal.addEventListener("abort", Ea);
        let {loaderResults: ul, fetcherResults: qn} = await wt(E, R, ze, ht, T);
        if (T.signal.aborted)
            return {
                shortCircuited: !0
            };
        M && M.signal.removeEventListener("abort", Ea),
        ht.forEach(Le => B.delete(Le.key));
        let Tn = Hc(ul);
        if (Tn)
            return await ae(T, Tn.result, !0, {
                replace: re
            }),
            {
                shortCircuited: !0
            };
        if (Tn = Hc(qn),
        Tn)
            return Fe.add(Tn.key),
            await ae(T, Tn.result, !0, {
                replace: re
            }),
            {
                shortCircuited: !0
            };
        let {loaderData: Ch, errors: cl} = ax(E, R, ul, oe, ht, qn, It);
        It.forEach( (Le, mt) => {
            Le.subscribe(_a => {
                (_a || Le.done) && It.delete(mt)
            }
            )
        }
        ),
        h.v7_partialHydration && se && E.errors && (cl = st({}, E.errors, cl));
        let Ci = ll()
          , bc = Dv(me)
          , xc = Ci || bc || ht.length > 0;
        return st({
            matches: R,
            loaderData: Ch,
            errors: cl
        }, xc ? {
            fetchers: new Map(E.fetchers)
        } : {})
    }
    function I(T) {
        if (T && !Or(T[1]))
            return {
                [T[0]]: T[1].data
            };
        if (E.actionData)
            return Object.keys(E.actionData).length === 0 ? null : E.actionData
    }
    function A(T) {
        return T.forEach(N => {
            let R = E.fetchers.get(N.key)
              , F = kl(void 0, R ? R.data : void 0);
            E.fetchers.set(N.key, F)
        }
        ),
        new Map(E.fetchers)
    }
    function G(T, N, R, F) {
        if (n)
            throw new Error("router.fetch() was called during the server render, but it shouldn't be. You are likely calling a useFetcher() method in the body of your component. Try moving it to a useEffect or a callback.");
        nn(T);
        let Z = (F && F.flushSync) === !0
          , ue = o || a
          , be = Yp(E.location, E.matches, l, h.v7_prependBasename, R, h.v7_relativeSplatPath, N, F == null ? void 0 : F.relative)
          , re = Mi(ue, be, l)
          , se = gc(re, ue, be);
        if (se.active && se.matches && (re = se.matches),
        !re) {
            rn(T, N, Er(404, {
                pathname: be
            }), {
                flushSync: Z
            });
            return
        }
        let {path: te, submission: oe, error: Ce} = Xb(h.v7_normalizeFormMethod, !0, be, F);
        if (Ce) {
            rn(T, N, Ce, {
                flushSync: Z
            });
            return
        }
        let Re = Ll(re, te)
          , Bt = (F && F.preventScrollReset) === !0;
        if (oe && fn(oe.formMethod)) {
            H(T, N, te, Re, re, se.active, Z, Bt, oe);
            return
        }
        Ir.set(T, {
            routeId: N,
            path: te
        }),
        W(T, N, te, Re, re, se.active, Z, Bt, oe)
    }
    async function H(T, N, R, F, Z, ue, be, re, se) {
        ft(),
        Ir.delete(T);
        function te(Ct) {
            if (!Ct.route.action && !Ct.route.lazy) {
                let Ta = Er(405, {
                    method: se.formMethod,
                    pathname: R,
                    routeId: N
                });
                return rn(T, N, Ta, {
                    flushSync: be
                }),
                !0
            }
            return !1
        }
        if (!ue && te(F))
            return;
        let oe = E.fetchers.get(T);
        Vt(T, e7(se, oe), {
            flushSync: be
        });
        let Ce = new AbortController
          , Re = Na(e.history, R, Ce.signal, se);
        if (ue) {
            let Ct = await vc(Z, new URL(Re.url).pathname, Re.signal, T);
            if (Ct.type === "aborted")
                return;
            if (Ct.type === "error") {
                rn(T, N, Ct.error, {
                    flushSync: be
                });
                return
            } else if (Ct.matches) {
                if (Z = Ct.matches,
                F = Ll(Z, R),
                te(F))
                    return
            } else {
                rn(T, N, Er(404, {
                    pathname: R
                }), {
                    flushSync: be
                });
                return
            }
        }
        B.set(T, Ce);
        let Bt = he
          , ze = (await Ee("action", E, Re, [F], Z, T))[F.route.id];
        if (Re.signal.aborted) {
            B.get(T) === Ce && B.delete(T);
            return
        }
        if (h.v7_fetcherPersist && zt.has(T)) {
            if (zi(ze) || Or(ze)) {
                Vt(T, $s(void 0));
                return
            }
        } else {
            if (zi(ze))
                if (B.delete(T),
                me > Bt) {
                    Vt(T, $s(void 0));
                    return
                } else
                    return Fe.add(T),
                    Vt(T, kl(se)),
                    ae(Re, ze, !1, {
                        fetcherSubmission: se,
                        preventScrollReset: re
                    });
            if (Or(ze)) {
                rn(T, N, ze.error);
                return
            }
        }
        if (Gs(ze))
            throw Er(400, {
                type: "defer-action"
            });
        let ht = E.navigation.location || E.location
          , Ea = Na(e.history, ht, Ce.signal)
          , ul = o || a
          , qn = E.navigation.state !== "idle" ? Mi(ul, E.navigation.location, l) : E.matches;
        Ne(qn, "Didn't find any matches after fetcher action");
        let Tn = ++he;
        De.set(T, Tn);
        let Ch = kl(se, ze.data);
        E.fetchers.set(T, Ch);
        let[cl,Ci] = tx(e.history, E, qn, se, ht, !1, h.v7_skipActionErrorRevalidation, ce, Ke, xt, zt, Ir, Fe, ul, l, [F.route.id, ze]);
        Ci.filter(Ct => Ct.key !== T).forEach(Ct => {
            let Ta = Ct.key
              , Bv = E.fetchers.get(Ta)
              , pT = kl(void 0, Bv ? Bv.data : void 0);
            E.fetchers.set(Ta, pT),
            nn(Ta),
            Ct.controller && B.set(Ta, Ct.controller)
        }
        ),
        Ut({
            fetchers: new Map(E.fetchers)
        });
        let bc = () => Ci.forEach(Ct => nn(Ct.key));
        Ce.signal.addEventListener("abort", bc);
        let {loaderResults: xc, fetcherResults: Le} = await wt(E, qn, cl, Ci, Ea);
        if (Ce.signal.aborted)
            return;
        Ce.signal.removeEventListener("abort", bc),
        De.delete(T),
        B.delete(T),
        Ci.forEach(Ct => B.delete(Ct.key));
        let mt = Hc(xc);
        if (mt)
            return ae(Ea, mt.result, !1, {
                preventScrollReset: re
            });
        if (mt = Hc(Le),
        mt)
            return Fe.add(mt.key),
            ae(Ea, mt.result, !1, {
                preventScrollReset: re
            });
        let {loaderData: _a, errors: dl} = ax(E, qn, xc, void 0, Ci, Le, It);
        if (E.fetchers.has(T)) {
            let Ct = $s(ze.data);
            E.fetchers.set(T, Ct)
        }
        Dv(Tn),
        E.navigation.state === "loading" && Tn > me ? (Ne(b, "Expected pending action"),
        M && M.abort(),
        Wn(E.navigation.location, {
            matches: qn,
            loaderData: _a,
            errors: dl,
            fetchers: new Map(E.fetchers)
        })) : (Ut({
            errors: dl,
            loaderData: ox(E.loaderData, _a, qn, dl),
            fetchers: new Map(E.fetchers)
        }),
        ce = !1)
    }
    async function W(T, N, R, F, Z, ue, be, re, se) {
        let te = E.fetchers.get(T);
        Vt(T, kl(se, te ? te.data : void 0), {
            flushSync: be
        });
        let oe = new AbortController
          , Ce = Na(e.history, R, oe.signal);
        if (ue) {
            let ze = await vc(Z, new URL(Ce.url).pathname, Ce.signal, T);
            if (ze.type === "aborted")
                return;
            if (ze.type === "error") {
                rn(T, N, ze.error, {
                    flushSync: be
                });
                return
            } else if (ze.matches)
                Z = ze.matches,
                F = Ll(Z, R);
            else {
                rn(T, N, Er(404, {
                    pathname: R
                }), {
                    flushSync: be
                });
                return
            }
        }
        B.set(T, oe);
        let Re = he
          , Ge = (await Ee("loader", E, Ce, [F], Z, T))[F.route.id];
        if (Gs(Ge) && (Ge = await Yg(Ge, Ce.signal, !0) || Ge),
        B.get(T) === oe && B.delete(T),
        !Ce.signal.aborted) {
            if (zt.has(T)) {
                Vt(T, $s(void 0));
                return
            }
            if (zi(Ge))
                if (me > Re) {
                    Vt(T, $s(void 0));
                    return
                } else {
                    Fe.add(T),
                    await ae(Ce, Ge, !1, {
                        preventScrollReset: re
                    });
                    return
                }
            if (Or(Ge)) {
                rn(T, N, Ge.error);
                return
            }
            Ne(!Gs(Ge), "Unhandled fetcher deferred data"),
            Vt(T, $s(Ge.data))
        }
    }
    async function ae(T, N, R, F) {
        let {submission: Z, fetcherSubmission: ue, preventScrollReset: be, replace: re} = F === void 0 ? {} : F;
        N.response.headers.has("X-Remix-Revalidate") && (ce = !0);
        let se = N.response.headers.get("Location");
        Ne(se, "Expected a Location header on the redirect Response"),
        se = sx(se, new URL(T.url), l);
        let te = Au(E.location, se, {
            _isRedirect: !0
        });
        if (r) {
            let ze = !1;
            if (N.response.headers.has("X-Remix-Reload-Document"))
                ze = !0;
            else if (Gg.test(se)) {
                const ht = e.history.createURL(se);
                ze = ht.origin !== t.location.origin || hs(ht.pathname, l) == null
            }
            if (ze) {
                re ? t.location.replace(se) : t.location.assign(se);
                return
            }
        }
        M = null;
        let oe = re === !0 || N.response.headers.has("X-Remix-Replace") ? Pt.Replace : Pt.Push
          , {formMethod: Ce, formAction: Re, formEncType: Bt} = E.navigation;
        !Z && !ue && Ce && Re && Bt && (Z = dx(E.navigation));
        let Ge = Z || ue;
        if (Oz.has(N.response.status) && Ge && fn(Ge.formMethod))
            await ws(oe, te, {
                submission: st({}, Ge, {
                    formAction: se
                }),
                preventScrollReset: be || O,
                enableViewTransition: R ? D : void 0
            });
        else {
            let ze = cm(te, Z);
            await ws(oe, te, {
                overrideNavigation: ze,
                fetcherSubmission: ue,
                preventScrollReset: be || O,
                enableViewTransition: R ? D : void 0
            })
        }
    }
    async function Ee(T, N, R, F, Z, ue) {
        let be, re = {};
        try {
            be = await Vz(c, T, N, R, F, Z, ue, i, s)
        } catch (se) {
            return F.forEach(te => {
                re[te.route.id] = {
                    type: He.error,
                    error: se
                }
            }
            ),
            re
        }
        for (let[se,te] of Object.entries(be))
            if (Kz(te)) {
                let oe = te.result;
                re[se] = {
                    type: He.redirect,
                    response: qz(oe, R, se, Z, l, h.v7_relativeSplatPath)
                }
            } else
                re[se] = await Wz(te);
        return re
    }
    async function wt(T, N, R, F, Z) {
        let ue = T.matches
          , be = Ee("loader", T, Z, R, N, null)
          , re = Promise.all(F.map(async oe => {
            if (oe.matches && oe.match && oe.controller) {
                let Re = (await Ee("loader", T, Na(e.history, oe.path, oe.controller.signal), [oe.match], oe.matches, oe.key))[oe.match.route.id];
                return {
                    [oe.key]: Re
                }
            } else
                return Promise.resolve({
                    [oe.key]: {
                        type: He.error,
                        error: Er(404, {
                            pathname: oe.path
                        })
                    }
                })
        }
        ))
          , se = await be
          , te = (await re).reduce( (oe, Ce) => Object.assign(oe, Ce), {});
        return await Promise.all([Yz(N, se, Z.signal, ue, T.loaderData), Jz(N, te, F)]),
        {
            loaderResults: se,
            fetcherResults: te
        }
    }
    function ft() {
        ce = !0,
        Ke.push(...Th()),
        Ir.forEach( (T, N) => {
            B.has(N) && xt.add(N),
            nn(N)
        }
        )
    }
    function Vt(T, N, R) {
        R === void 0 && (R = {}),
        E.fetchers.set(T, N),
        Ut({
            fetchers: new Map(E.fetchers)
        }, {
            flushSync: (R && R.flushSync) === !0
        })
    }
    function rn(T, N, R, F) {
        F === void 0 && (F = {});
        let Z = Ai(E.matches, N);
        Ss(T),
        Ut({
            errors: {
                [Z.route.id]: R
            },
            fetchers: new Map(E.fetchers)
        }, {
            flushSync: (F && F.flushSync) === !0
        })
    }
    function ka(T) {
        return Qt.set(T, (Qt.get(T) || 0) + 1),
        zt.has(T) && zt.delete(T),
        E.fetchers.get(T) || Mz
    }
    function Ss(T) {
        let N = E.fetchers.get(T);
        B.has(T) && !(N && N.state === "loading" && De.has(T)) && nn(T),
        Ir.delete(T),
        De.delete(T),
        Fe.delete(T),
        h.v7_fetcherPersist && zt.delete(T),
        xt.delete(T),
        E.fetchers.delete(T)
    }
    function Eh(T) {
        let N = (Qt.get(T) || 0) - 1;
        N <= 0 ? (Qt.delete(T),
        zt.add(T),
        h.v7_fetcherPersist || Ss(T)) : Qt.set(T, N),
        Ut({
            fetchers: new Map(E.fetchers)
        })
    }
    function nn(T) {
        let N = B.get(T);
        N && (N.abort(),
        B.delete(T))
    }
    function pc(T) {
        for (let N of T) {
            let R = ka(N)
              , F = $s(R.data);
            E.fetchers.set(N, F)
        }
    }
    function ll() {
        let T = []
          , N = !1;
        for (let R of Fe) {
            let F = E.fetchers.get(R);
            Ne(F, "Expected fetcher: " + R),
            F.state === "loading" && (Fe.delete(R),
            T.push(R),
            N = !0)
        }
        return pc(T),
        N
    }
    function Dv(T) {
        let N = [];
        for (let[R,F] of De)
            if (F < T) {
                let Z = E.fetchers.get(R);
                Ne(Z, "Expected fetcher: " + R),
                Z.state === "loading" && (nn(R),
                De.delete(R),
                N.push(R))
            }
        return pc(N),
        N.length > 0
    }
    function cT(T, N) {
        let R = E.blockers.get(T) || Sl;
        return or.get(T) !== N && or.set(T, N),
        R
    }
    function Fv(T) {
        E.blockers.delete(T),
        or.delete(T)
    }
    function yc(T, N) {
        let R = E.blockers.get(T) || Sl;
        Ne(R.state === "unblocked" && N.state === "blocked" || R.state === "blocked" && N.state === "blocked" || R.state === "blocked" && N.state === "proceeding" || R.state === "blocked" && N.state === "unblocked" || R.state === "proceeding" && N.state === "unblocked", "Invalid blocker state transition: " + R.state + " -> " + N.state);
        let F = new Map(E.blockers);
        F.set(T, N),
        Ut({
            blockers: F
        })
    }
    function zv(T) {
        let {currentLocation: N, nextLocation: R, historyAction: F} = T;
        if (or.size === 0)
            return;
        or.size > 1 && Do(!1, "A router only supports one blocker at a time");
        let Z = Array.from(or.entries())
          , [ue,be] = Z[Z.length - 1]
          , re = E.blockers.get(ue);
        if (!(re && re.state === "proceeding") && be({
            currentLocation: N,
            nextLocation: R,
            historyAction: F
        }))
            return ue
    }
    function _h(T) {
        let N = Er(404, {
            pathname: T
        })
          , R = o || a
          , {matches: F, route: Z} = ux(R);
        return Th(),
        {
            notFoundMatches: F,
            route: Z,
            error: N
        }
    }
    function Th(T) {
        let N = [];
        return It.forEach( (R, F) => {
            (!T || T(F)) && (R.cancel(),
            N.push(F),
            It.delete(F))
        }
        ),
        N
    }
    function dT(T, N, R) {
        if (k = T,
        w = N,
        x = R || null,
        !v && E.navigation === um) {
            v = !0;
            let F = Vv(E.location, E.matches);
            F != null && Ut({
                restoreScrollPosition: F
            })
        }
        return () => {
            k = null,
            w = null,
            x = null
        }
    }
    function Uv(T, N) {
        return x && x(T, N.map(F => fz(F, E.loaderData))) || T.key
    }
    function fT(T, N) {
        if (k && w) {
            let R = Uv(T, N);
            k[R] = w()
        }
    }
    function Vv(T, N) {
        if (k) {
            let R = Uv(T, N)
              , F = k[R];
            if (typeof F == "number")
                return F
        }
        return null
    }
    function gc(T, N, R) {
        if (f)
            if (T) {
                if (Object.keys(T[0].params).length > 0)
                    return {
                        active: !0,
                        matches: vd(N, R, l, !0)
                    }
            } else
                return {
                    active: !0,
                    matches: vd(N, R, l, !0) || []
                };
        return {
            active: !1,
            matches: null
        }
    }
    async function vc(T, N, R, F) {
        if (!f)
            return {
                type: "success",
                matches: T
            };
        let Z = T;
        for (; ; ) {
            let ue = o == null
              , be = o || a
              , re = i;
            try {
                await f({
                    signal: R,
                    path: N,
                    matches: Z,
                    fetcherKey: F,
                    patch: (oe, Ce) => {
                        R.aborted || nx(oe, Ce, be, re, s)
                    }
                })
            } catch (oe) {
                return {
                    type: "error",
                    error: oe,
                    partialMatches: Z
                }
            } finally {
                ue && !R.aborted && (a = [...a])
            }
            if (R.aborted)
                return {
                    type: "aborted"
                };
            let se = Mi(be, N, l);
            if (se)
                return {
                    type: "success",
                    matches: se
                };
            let te = vd(be, N, l, !0);
            if (!te || Z.length === te.length && Z.every( (oe, Ce) => oe.route.id === te[Ce].route.id))
                return {
                    type: "success",
                    matches: null
                };
            Z = te
        }
    }
    function hT(T) {
        i = {},
        o = gf(T, s, void 0, i)
    }
    function mT(T, N) {
        let R = o == null;
        nx(T, N, o || a, i, s),
        R && (a = [...a],
        Ut({}))
    }
    return L = {
        get basename() {
            return l
        },
        get future() {
            return h
        },
        get state() {
            return E
        },
        get routes() {
            return a
        },
        get window() {
            return t
        },
        initialize: hc,
        subscribe: mc,
        enableScrollRestoration: dT,
        navigate: ol,
        fetch: G,
        revalidate: Av,
        createHref: T => e.history.createHref(T),
        encodeLocation: T => e.history.encodeLocation(T),
        getFetcher: ka,
        deleteFetcher: Eh,
        dispose: kh,
        getBlocker: cT,
        deleteBlocker: Fv,
        patchRoutes: mT,
        _internalFetchControllers: B,
        _internalActiveDeferreds: It,
        _internalSetRoutes: hT
    },
    L
}
function Dz(e) {
    return e != null && ("formData"in e && e.formData != null || "body"in e && e.body !== void 0)
}
function Yp(e, t, r, n, s, i, a, o) {
    let l, c;
    if (a) {
        l = [];
        for (let h of t)
            if (l.push(h),
            h.route.id === a) {
                c = h;
                break
            }
    } else
        l = t,
        c = t[t.length - 1];
    let f = Qg(s || ".", Kg(l, i), hs(e.pathname, r) || e.pathname, o === "path");
    if (s == null && (f.search = e.search,
    f.hash = e.hash),
    (s == null || s === "" || s === ".") && c) {
        let h = Jg(f.search);
        if (c.route.index && !h)
            f.search = f.search ? f.search.replace(/^\?/, "?index&") : "?index";
        else if (!c.route.index && h) {
            let m = new URLSearchParams(f.search)
              , y = m.getAll("index");
            m.delete("index"),
            y.filter(x => x).forEach(x => m.append("index", x));
            let k = m.toString();
            f.search = k ? "?" + k : ""
        }
    }
    return n && r !== "/" && (f.pathname = f.pathname === "/" ? r : is([r, f.pathname])),
    ma(f)
}
function Xb(e, t, r, n) {
    if (!n || !Dz(n))
        return {
            path: r
        };
    if (n.formMethod && !Gz(n.formMethod))
        return {
            path: r,
            error: Er(405, {
                method: n.formMethod
            })
        };
    let s = () => ({
        path: r,
        error: Er(400, {
            type: "invalid-body"
        })
    })
      , i = n.formMethod || "get"
      , a = e ? i.toUpperCase() : i.toLowerCase()
      , o = Ak(r);
    if (n.body !== void 0) {
        if (n.formEncType === "text/plain") {
            if (!fn(a))
                return s();
            let m = typeof n.body == "string" ? n.body : n.body instanceof FormData || n.body instanceof URLSearchParams ? Array.from(n.body.entries()).reduce( (y, k) => {
                let[x,w] = k;
                return "" + y + x + "=" + w + `
`
            }
            , "") : String(n.body);
            return {
                path: r,
                submission: {
                    formMethod: a,
                    formAction: o,
                    formEncType: n.formEncType,
                    formData: void 0,
                    json: void 0,
                    text: m
                }
            }
        } else if (n.formEncType === "application/json") {
            if (!fn(a))
                return s();
            try {
                let m = typeof n.body == "string" ? JSON.parse(n.body) : n.body;
                return {
                    path: r,
                    submission: {
                        formMethod: a,
                        formAction: o,
                        formEncType: n.formEncType,
                        formData: void 0,
                        json: m,
                        text: void 0
                    }
                }
            } catch {
                return s()
            }
        }
    }
    Ne(typeof FormData == "function", "FormData is not available in this environment");
    let l, c;
    if (n.formData)
        l = Xp(n.formData),
        c = n.formData;
    else if (n.body instanceof FormData)
        l = Xp(n.body),
        c = n.body;
    else if (n.body instanceof URLSearchParams)
        l = n.body,
        c = ix(l);
    else if (n.body == null)
        l = new URLSearchParams,
        c = new FormData;
    else
        try {
            l = new URLSearchParams(n.body),
            c = ix(l)
        } catch {
            return s()
        }
    let f = {
        formMethod: a,
        formAction: o,
        formEncType: n && n.formEncType || "application/x-www-form-urlencoded",
        formData: c,
        json: void 0,
        text: void 0
    };
    if (fn(f.formMethod))
        return {
            path: r,
            submission: f
        };
    let h = wi(r);
    return t && h.search && Jg(h.search) && l.append("index", ""),
    h.search = "?" + l,
    {
        path: ma(h),
        submission: f
    }
}
function ex(e, t, r) {
    r === void 0 && (r = !1);
    let n = e.findIndex(s => s.route.id === t);
    return n >= 0 ? e.slice(0, r ? n + 1 : n) : e
}
function tx(e, t, r, n, s, i, a, o, l, c, f, h, m, y, k, x) {
    let w = x ? Or(x[1]) ? x[1].error : x[1].data : void 0
      , v = e.createURL(t.location)
      , p = e.createURL(s)
      , S = r;
    i && t.errors ? S = ex(r, Object.keys(t.errors)[0], !0) : x && Or(x[1]) && (S = ex(r, x[0]));
    let P = x ? x[1].statusCode : void 0
      , j = a && P && P >= 400
      , L = S.filter( (b, O) => {
        let {route: M} = b;
        if (M.lazy)
            return !0;
        if (M.loader == null)
            return !1;
        if (i)
            return Jp(M, t.loaderData, t.errors);
        if (Fz(t.loaderData, t.matches[O], b) || l.some($ => $ === b.route.id))
            return !0;
        let D = t.matches[O]
          , z = b;
        return rx(b, st({
            currentUrl: v,
            currentParams: D.params,
            nextUrl: p,
            nextParams: z.params
        }, n, {
            actionResult: w,
            actionStatus: P,
            defaultShouldRevalidate: j ? !1 : o || v.pathname + v.search === p.pathname + p.search || v.search !== p.search || Ok(D, z)
        }))
    }
    )
      , E = [];
    return h.forEach( (b, O) => {
        if (i || !r.some(Y => Y.route.id === b.routeId) || f.has(O))
            return;
        let M = Mi(y, b.path, k);
        if (!M) {
            E.push({
                key: O,
                routeId: b.routeId,
                path: b.path,
                matches: null,
                match: null,
                controller: null
            });
            return
        }
        let D = t.fetchers.get(O)
          , z = Ll(M, b.path)
          , $ = !1;
        m.has(O) ? $ = !1 : c.has(O) ? (c.delete(O),
        $ = !0) : D && D.state !== "idle" && D.data === void 0 ? $ = o : $ = rx(z, st({
            currentUrl: v,
            currentParams: t.matches[t.matches.length - 1].params,
            nextUrl: p,
            nextParams: r[r.length - 1].params
        }, n, {
            actionResult: w,
            actionStatus: P,
            defaultShouldRevalidate: j ? !1 : o
        })),
        $ && E.push({
            key: O,
            routeId: b.routeId,
            path: b.path,
            matches: M,
            match: z,
            controller: new AbortController
        })
    }
    ),
    [L, E]
}
function Jp(e, t, r) {
    if (e.lazy)
        return !0;
    if (!e.loader)
        return !1;
    let n = t != null && t[e.id] !== void 0
      , s = r != null && r[e.id] !== void 0;
    return !n && s ? !1 : typeof e.loader == "function" && e.loader.hydrate === !0 ? !0 : !n && !s
}
function Fz(e, t, r) {
    let n = !t || r.route.id !== t.route.id
      , s = e[r.route.id] === void 0;
    return n || s
}
function Ok(e, t) {
    let r = e.route.path;
    return e.pathname !== t.pathname || r != null && r.endsWith("*") && e.params["*"] !== t.params["*"]
}
function rx(e, t) {
    if (e.route.shouldRevalidate) {
        let r = e.route.shouldRevalidate(t);
        if (typeof r == "boolean")
            return r
    }
    return t.defaultShouldRevalidate
}
function nx(e, t, r, n, s) {
    var i;
    let a;
    if (e) {
        let c = n[e];
        Ne(c, "No route found to patch children into: routeId = " + e),
        c.children || (c.children = []),
        a = c.children
    } else
        a = r;
    let o = t.filter(c => !a.some(f => Mk(c, f)))
      , l = gf(o, s, [e || "_", "patch", String(((i = a) == null ? void 0 : i.length) || "0")], n);
    a.push(...l)
}
function Mk(e, t) {
    return "id"in e && "id"in t && e.id === t.id ? !0 : e.index === t.index && e.path === t.path && e.caseSensitive === t.caseSensitive ? (!e.children || e.children.length === 0) && (!t.children || t.children.length === 0) ? !0 : e.children.every( (r, n) => {
        var s;
        return (s = t.children) == null ? void 0 : s.some(i => Mk(r, i))
    }
    ) : !1
}
async function zz(e, t, r) {
    if (!e.lazy)
        return;
    let n = await e.lazy();
    if (!e.lazy)
        return;
    let s = r[e.id];
    Ne(s, "No route found in manifest");
    let i = {};
    for (let a in n) {
        let l = s[a] !== void 0 && a !== "hasErrorBoundary";
        Do(!l, 'Route "' + s.id + '" has a static property "' + a + '" defined but its lazy function is also returning a value for this property. ' + ('The lazy route property "' + a + '" will be ignored.')),
        !l && !cz.has(a) && (i[a] = n[a])
    }
    Object.assign(s, i),
    Object.assign(s, st({}, t(s), {
        lazy: void 0
    }))
}
async function Uz(e) {
    let {matches: t} = e
      , r = t.filter(s => s.shouldLoad);
    return (await Promise.all(r.map(s => s.resolve()))).reduce( (s, i, a) => Object.assign(s, {
        [r[a].route.id]: i
    }), {})
}
async function Vz(e, t, r, n, s, i, a, o, l, c) {
    let f = i.map(y => y.route.lazy ? zz(y.route, l, o) : void 0)
      , h = i.map( (y, k) => {
        let x = f[k]
          , w = s.some(p => p.route.id === y.route.id);
        return st({}, y, {
            shouldLoad: w,
            resolve: async p => (p && n.method === "GET" && (y.route.lazy || y.route.loader) && (w = !0),
            w ? Bz(t, n, y, x, p, c) : Promise.resolve({
                type: He.data,
                result: void 0
            }))
        })
    }
    )
      , m = await e({
        matches: h,
        request: n,
        params: i[0].params,
        fetcherKey: a,
        context: c
    });
    try {
        await Promise.all(f)
    } catch {}
    return m
}
async function Bz(e, t, r, n, s, i) {
    let a, o, l = c => {
        let f, h = new Promise( (k, x) => f = x);
        o = () => f(),
        t.signal.addEventListener("abort", o);
        let m = k => typeof c != "function" ? Promise.reject(new Error("You cannot call the handler for a route which defines a boolean " + ('"' + e + '" [routeId: ' + r.route.id + "]"))) : c({
            request: t,
            params: r.params,
            context: i
        }, ...k !== void 0 ? [k] : [])
          , y = (async () => {
            try {
                return {
                    type: "data",
                    result: await (s ? s(x => m(x)) : m())
                }
            } catch (k) {
                return {
                    type: "error",
                    result: k
                }
            }
        }
        )();
        return Promise.race([y, h])
    }
    ;
    try {
        let c = r.route[e];
        if (n)
            if (c) {
                let f, [h] = await Promise.all([l(c).catch(m => {
                    f = m
                }
                ), n]);
                if (f !== void 0)
                    throw f;
                a = h
            } else if (await n,
            c = r.route[e],
            c)
                a = await l(c);
            else if (e === "action") {
                let f = new URL(t.url)
                  , h = f.pathname + f.search;
                throw Er(405, {
                    method: t.method,
                    pathname: h,
                    routeId: r.route.id
                })
            } else
                return {
                    type: He.data,
                    result: void 0
                };
        else if (c)
            a = await l(c);
        else {
            let f = new URL(t.url)
              , h = f.pathname + f.search;
            throw Er(404, {
                pathname: h
            })
        }
        Ne(a.result !== void 0, "You defined " + (e === "action" ? "an action" : "a loader") + " for route " + ('"' + r.route.id + "\" but didn't return anything from your `" + e + "` ") + "function. Please return a value or `null`.")
    } catch (c) {
        return {
            type: He.error,
            result: c
        }
    } finally {
        o && t.signal.removeEventListener("abort", o)
    }
    return a
}
async function Wz(e) {
    let {result: t, type: r} = e;
    if (Lk(t)) {
        let h;
        try {
            let m = t.headers.get("Content-Type");
            m && /\bapplication\/json\b/.test(m) ? t.body == null ? h = null : h = await t.json() : h = await t.text()
        } catch (m) {
            return {
                type: He.error,
                error: m
            }
        }
        return r === He.error ? {
            type: He.error,
            error: new bf(t.status,t.statusText,h),
            statusCode: t.status,
            headers: t.headers
        } : {
            type: He.data,
            data: h,
            statusCode: t.status,
            headers: t.headers
        }
    }
    if (r === He.error) {
        if (cx(t)) {
            var n, s;
            if (t.data instanceof Error) {
                var i, a;
                return {
                    type: He.error,
                    error: t.data,
                    statusCode: (i = t.init) == null ? void 0 : i.status,
                    headers: (a = t.init) != null && a.headers ? new Headers(t.init.headers) : void 0
                }
            }
            return {
                type: He.error,
                error: new bf(((n = t.init) == null ? void 0 : n.status) || 500,void 0,t.data),
                statusCode: Lu(t) ? t.status : void 0,
                headers: (s = t.init) != null && s.headers ? new Headers(t.init.headers) : void 0
            }
        }
        return {
            type: He.error,
            error: t,
            statusCode: Lu(t) ? t.status : void 0
        }
    }
    if (Qz(t)) {
        var o, l;
        return {
            type: He.deferred,
            deferredData: t,
            statusCode: (o = t.init) == null ? void 0 : o.status,
            headers: ((l = t.init) == null ? void 0 : l.headers) && new Headers(t.init.headers)
        }
    }
    if (cx(t)) {
        var c, f;
        return {
            type: He.data,
            data: t.data,
            statusCode: (c = t.init) == null ? void 0 : c.status,
            headers: (f = t.init) != null && f.headers ? new Headers(t.init.headers) : void 0
        }
    }
    return {
        type: He.data,
        data: t
    }
}
function qz(e, t, r, n, s, i) {
    let a = e.headers.get("Location");
    if (Ne(a, "Redirects returned/thrown from loaders/actions must have a Location header"),
    !Gg.test(a)) {
        let o = n.slice(0, n.findIndex(l => l.route.id === r) + 1);
        a = Yp(new URL(t.url), o, s, !0, a, i),
        e.headers.set("Location", a)
    }
    return e
}
function sx(e, t, r) {
    if (Gg.test(e)) {
        let n = e
          , s = n.startsWith("//") ? new URL(t.protocol + n) : new URL(n)
          , i = hs(s.pathname, r) != null;
        if (s.origin === t.origin && i)
            return s.pathname + s.search + s.hash
    }
    return e
}
function Na(e, t, r, n) {
    let s = e.createURL(Ak(t)).toString()
      , i = {
        signal: r
    };
    if (n && fn(n.formMethod)) {
        let {formMethod: a, formEncType: o} = n;
        i.method = a.toUpperCase(),
        o === "application/json" ? (i.headers = new Headers({
            "Content-Type": o
        }),
        i.body = JSON.stringify(n.json)) : o === "text/plain" ? i.body = n.text : o === "application/x-www-form-urlencoded" && n.formData ? i.body = Xp(n.formData) : i.body = n.formData
    }
    return new Request(s,i)
}
function Xp(e) {
    let t = new URLSearchParams;
    for (let[r,n] of e.entries())
        t.append(r, typeof n == "string" ? n : n.name);
    return t
}
function ix(e) {
    let t = new FormData;
    for (let[r,n] of e.entries())
        t.append(r, n);
    return t
}
function Hz(e, t, r, n, s) {
    let i = {}, a = null, o, l = !1, c = {}, f = r && Or(r[1]) ? r[1].error : void 0;
    return e.forEach(h => {
        if (!(h.route.id in t))
            return;
        let m = h.route.id
          , y = t[m];
        if (Ne(!zi(y), "Cannot handle redirect results in processLoaderData"),
        Or(y)) {
            let k = y.error;
            f !== void 0 && (k = f,
            f = void 0),
            a = a || {};
            {
                let x = Ai(e, m);
                a[x.route.id] == null && (a[x.route.id] = k)
            }
            i[m] = void 0,
            l || (l = !0,
            o = Lu(y.error) ? y.error.status : 500),
            y.headers && (c[m] = y.headers)
        } else
            Gs(y) ? (n.set(m, y.deferredData),
            i[m] = y.deferredData.data,
            y.statusCode != null && y.statusCode !== 200 && !l && (o = y.statusCode),
            y.headers && (c[m] = y.headers)) : (i[m] = y.data,
            y.statusCode && y.statusCode !== 200 && !l && (o = y.statusCode),
            y.headers && (c[m] = y.headers))
    }
    ),
    f !== void 0 && r && (a = {
        [r[0]]: f
    },
    i[r[0]] = void 0),
    {
        loaderData: i,
        errors: a,
        statusCode: o || 200,
        loaderHeaders: c
    }
}
function ax(e, t, r, n, s, i, a) {
    let {loaderData: o, errors: l} = Hz(t, r, n, a);
    return s.forEach(c => {
        let {key: f, match: h, controller: m} = c
          , y = i[f];
        if (Ne(y, "Did not find corresponding fetcher result"),
        !(m && m.signal.aborted))
            if (Or(y)) {
                let k = Ai(e.matches, h == null ? void 0 : h.route.id);
                l && l[k.route.id] || (l = st({}, l, {
                    [k.route.id]: y.error
                })),
                e.fetchers.delete(f)
            } else if (zi(y))
                Ne(!1, "Unhandled fetcher revalidation redirect");
            else if (Gs(y))
                Ne(!1, "Unhandled fetcher deferred data");
            else {
                let k = $s(y.data);
                e.fetchers.set(f, k)
            }
    }
    ),
    {
        loaderData: o,
        errors: l
    }
}
function ox(e, t, r, n) {
    let s = st({}, t);
    for (let i of r) {
        let a = i.route.id;
        if (t.hasOwnProperty(a) ? t[a] !== void 0 && (s[a] = t[a]) : e[a] !== void 0 && i.route.loader && (s[a] = e[a]),
        n && n.hasOwnProperty(a))
            break
    }
    return s
}
function lx(e) {
    return e ? Or(e[1]) ? {
        actionData: {}
    } : {
        actionData: {
            [e[0]]: e[1].data
        }
    } : {}
}
function Ai(e, t) {
    return (t ? e.slice(0, e.findIndex(n => n.route.id === t) + 1) : [...e]).reverse().find(n => n.route.hasErrorBoundary === !0) || e[0]
}
function ux(e) {
    let t = e.length === 1 ? e[0] : e.find(r => r.index || !r.path || r.path === "/") || {
        id: "__shim-error-route__"
    };
    return {
        matches: [{
            params: {},
            pathname: "",
            pathnameBase: "",
            route: t
        }],
        route: t
    }
}
function Er(e, t) {
    let {pathname: r, routeId: n, method: s, type: i, message: a} = t === void 0 ? {} : t
      , o = "Unknown Server Error"
      , l = "Unknown @remix-run/router error";
    return e === 400 ? (o = "Bad Request",
    s && r && n ? l = "You made a " + s + ' request to "' + r + '" but ' + ('did not provide a `loader` for route "' + n + '", ') + "so there is no way to handle the request." : i === "defer-action" ? l = "defer() is not supported in actions" : i === "invalid-body" && (l = "Unable to encode submission body")) : e === 403 ? (o = "Forbidden",
    l = 'Route "' + n + '" does not match URL "' + r + '"') : e === 404 ? (o = "Not Found",
    l = 'No route matches URL "' + r + '"') : e === 405 && (o = "Method Not Allowed",
    s && r && n ? l = "You made a " + s.toUpperCase() + ' request to "' + r + '" but ' + ('did not provide an `action` for route "' + n + '", ') + "so there is no way to handle the request." : s && (l = 'Invalid request method "' + s.toUpperCase() + '"')),
    new bf(e || 500,o,new Error(l),!0)
}
function Hc(e) {
    let t = Object.entries(e);
    for (let r = t.length - 1; r >= 0; r--) {
        let[n,s] = t[r];
        if (zi(s))
            return {
                key: n,
                result: s
            }
    }
}
function Ak(e) {
    let t = typeof e == "string" ? wi(e) : e;
    return ma(st({}, t, {
        hash: ""
    }))
}
function Zz(e, t) {
    return e.pathname !== t.pathname || e.search !== t.search ? !1 : e.hash === "" ? t.hash !== "" : e.hash === t.hash ? !0 : t.hash !== ""
}
function Kz(e) {
    return Lk(e.result) && Rz.has(e.result.status)
}
function Gs(e) {
    return e.type === He.deferred
}
function Or(e) {
    return e.type === He.error
}
function zi(e) {
    return (e && e.type) === He.redirect
}
function cx(e) {
    return typeof e == "object" && e != null && "type"in e && "data"in e && "init"in e && e.type === "DataWithResponseInit"
}
function Qz(e) {
    let t = e;
    return t && typeof t == "object" && typeof t.data == "object" && typeof t.subscribe == "function" && typeof t.cancel == "function" && typeof t.resolveData == "function"
}
function Lk(e) {
    return e != null && typeof e.status == "number" && typeof e.statusText == "string" && typeof e.headers == "object" && typeof e.body < "u"
}
function Gz(e) {
    return Iz.has(e.toLowerCase())
}
function fn(e) {
    return Nz.has(e.toLowerCase())
}
async function Yz(e, t, r, n, s) {
    let i = Object.entries(t);
    for (let a = 0; a < i.length; a++) {
        let[o,l] = i[a]
          , c = e.find(m => (m == null ? void 0 : m.route.id) === o);
        if (!c)
            continue;
        let f = n.find(m => m.route.id === c.route.id)
          , h = f != null && !Ok(f, c) && (s && s[c.route.id]) !== void 0;
        Gs(l) && h && await Yg(l, r, !1).then(m => {
            m && (t[o] = m)
        }
        )
    }
}
async function Jz(e, t, r) {
    for (let n = 0; n < r.length; n++) {
        let {key: s, routeId: i, controller: a} = r[n]
          , o = t[s];
        e.find(c => (c == null ? void 0 : c.route.id) === i) && Gs(o) && (Ne(a, "Expected an AbortController for revalidating fetcher deferred result"),
        await Yg(o, a.signal, !0).then(c => {
            c && (t[s] = c)
        }
        ))
    }
}
async function Yg(e, t, r) {
    if (r === void 0 && (r = !1),
    !await e.deferredData.resolveData(t)) {
        if (r)
            try {
                return {
                    type: He.data,
                    data: e.deferredData.unwrappedData
                }
            } catch (s) {
                return {
                    type: He.error,
                    error: s
                }
            }
        return {
            type: He.data,
            data: e.deferredData.data
        }
    }
}
function Jg(e) {
    return new URLSearchParams(e).getAll("index").some(t => t === "")
}
function Ll(e, t) {
    let r = typeof t == "string" ? wi(t).search : t.search;
    if (e[e.length - 1].route.index && Jg(r || ""))
        return e[e.length - 1];
    let n = jk(e);
    return n[n.length - 1]
}
function dx(e) {
    let {formMethod: t, formAction: r, formEncType: n, text: s, formData: i, json: a} = e;
    if (!(!t || !r || !n)) {
        if (s != null)
            return {
                formMethod: t,
                formAction: r,
                formEncType: n,
                formData: void 0,
                json: void 0,
                text: s
            };
        if (i != null)
            return {
                formMethod: t,
                formAction: r,
                formEncType: n,
                formData: i,
                json: void 0,
                text: void 0
            };
        if (a !== void 0)
            return {
                formMethod: t,
                formAction: r,
                formEncType: n,
                formData: void 0,
                json: a,
                text: void 0
            }
    }
}
function cm(e, t) {
    return t ? {
        state: "loading",
        location: e,
        formMethod: t.formMethod,
        formAction: t.formAction,
        formEncType: t.formEncType,
        formData: t.formData,
        json: t.json,
        text: t.text
    } : {
        state: "loading",
        location: e,
        formMethod: void 0,
        formAction: void 0,
        formEncType: void 0,
        formData: void 0,
        json: void 0,
        text: void 0
    }
}
function Xz(e, t) {
    return {
        state: "submitting",
        location: e,
        formMethod: t.formMethod,
        formAction: t.formAction,
        formEncType: t.formEncType,
        formData: t.formData,
        json: t.json,
        text: t.text
    }
}
function kl(e, t) {
    return e ? {
        state: "loading",
        formMethod: e.formMethod,
        formAction: e.formAction,
        formEncType: e.formEncType,
        formData: e.formData,
        json: e.json,
        text: e.text,
        data: t
    } : {
        state: "loading",
        formMethod: void 0,
        formAction: void 0,
        formEncType: void 0,
        formData: void 0,
        json: void 0,
        text: void 0,
        data: t
    }
}
function e7(e, t) {
    return {
        state: "submitting",
        formMethod: e.formMethod,
        formAction: e.formAction,
        formEncType: e.formEncType,
        formData: e.formData,
        json: e.json,
        text: e.text,
        data: t ? t.data : void 0
    }
}
function $s(e) {
    return {
        state: "idle",
        formMethod: void 0,
        formAction: void 0,
        formEncType: void 0,
        formData: void 0,
        json: void 0,
        text: void 0,
        data: e
    }
}
function t7(e, t) {
    try {
        let r = e.sessionStorage.getItem(Rk);
        if (r) {
            let n = JSON.parse(r);
            for (let[s,i] of Object.entries(n || {}))
                i && Array.isArray(i) && t.set(s, new Set(i || []))
        }
    } catch {}
}
function r7(e, t) {
    if (t.size > 0) {
        let r = {};
        for (let[n,s] of t)
            r[n] = [...s];
        try {
            e.sessionStorage.setItem(Rk, JSON.stringify(r))
        } catch (n) {
            Do(!1, "Failed to save applied view transitions in sessionStorage (" + n + ").")
        }
    }
}
/**
 * React Router v6.30.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function xf() {
    return xf = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var r = arguments[t];
            for (var n in r)
                Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n])
        }
        return e
    }
    ,
    xf.apply(this, arguments)
}
const nc = g.createContext(null)
  , Xg = g.createContext(null)
  , Si = g.createContext(null)
  , ev = g.createContext(null)
  , bs = g.createContext({
    outlet: null,
    matches: [],
    isDataRoute: !1
})
  , Dk = g.createContext(null);
function n7(e, t) {
    let {relative: r} = t === void 0 ? {} : t;
    sc() || Ne(!1);
    let {basename: n, navigator: s} = g.useContext(Si)
      , {hash: i, pathname: a, search: o} = dh(e, {
        relative: r
    })
      , l = a;
    return n !== "/" && (l = a === "/" ? n : is([n, a])),
    s.createHref({
        pathname: l,
        search: o,
        hash: i
    })
}
function sc() {
    return g.useContext(ev) != null
}
function Xo() {
    return sc() || Ne(!1),
    g.useContext(ev).location
}
function Fk(e) {
    g.useContext(Si).static || g.useLayoutEffect(e)
}
function ki() {
    let {isDataRoute: e} = g.useContext(bs);
    return e ? g7() : s7()
}
function s7() {
    sc() || Ne(!1);
    let e = g.useContext(nc)
      , {basename: t, future: r, navigator: n} = g.useContext(Si)
      , {matches: s} = g.useContext(bs)
      , {pathname: i} = Xo()
      , a = JSON.stringify(Kg(s, r.v7_relativeSplatPath))
      , o = g.useRef(!1);
    return Fk( () => {
        o.current = !0
    }
    ),
    g.useCallback(function(c, f) {
        if (f === void 0 && (f = {}),
        !o.current)
            return;
        if (typeof c == "number") {
            n.go(c);
            return
        }
        let h = Qg(c, JSON.parse(a), i, f.relative === "path");
        e == null && t !== "/" && (h.pathname = h.pathname === "/" ? t : is([t, h.pathname])),
        (f.replace ? n.replace : n.push)(h, f.state, f)
    }, [t, n, a, i, e])
}
const i7 = g.createContext(null);
function a7(e) {
    let t = g.useContext(bs).outlet;
    return t && g.createElement(i7.Provider, {
        value: e
    }, t)
}
function zk() {
    let {matches: e} = g.useContext(bs)
      , t = e[e.length - 1];
    return t ? t.params : {}
}
function dh(e, t) {
    let {relative: r} = t === void 0 ? {} : t
      , {future: n} = g.useContext(Si)
      , {matches: s} = g.useContext(bs)
      , {pathname: i} = Xo()
      , a = JSON.stringify(Kg(s, n.v7_relativeSplatPath));
    return g.useMemo( () => Qg(e, JSON.parse(a), i, r === "path"), [e, a, i, r])
}
function o7(e, t, r, n) {
    sc() || Ne(!1);
    let {navigator: s, static: i} = g.useContext(Si)
      , {matches: a} = g.useContext(bs)
      , o = a[a.length - 1]
      , l = o ? o.params : {};
    o && o.pathname;
    let c = o ? o.pathnameBase : "/";
    o && o.route;
    let f = Xo(), h;
    h = f;
    let m = h.pathname || "/"
      , y = m;
    if (c !== "/") {
        let w = c.replace(/^\//, "").split("/");
        y = "/" + m.replace(/^\//, "").split("/").slice(w.length).join("/")
    }
    let k = !i && r && r.matches && r.matches.length > 0 ? r.matches : Mi(e, {
        pathname: y
    });
    return f7(k && k.map(w => Object.assign({}, w, {
        params: Object.assign({}, l, w.params),
        pathname: is([c, s.encodeLocation ? s.encodeLocation(w.pathname).pathname : w.pathname]),
        pathnameBase: w.pathnameBase === "/" ? c : is([c, s.encodeLocation ? s.encodeLocation(w.pathnameBase).pathname : w.pathnameBase])
    })), a, r, n)
}
function l7() {
    let e = y7()
      , t = Lu(e) ? e.status + " " + e.statusText : e instanceof Error ? e.message : JSON.stringify(e)
      , r = e instanceof Error ? e.stack : null
      , s = {
        padding: "0.5rem",
        backgroundColor: "rgba(200,200,200, 0.5)"
    };
    return g.createElement(g.Fragment, null, g.createElement("h2", null, "Unexpected Application Error!"), g.createElement("h3", {
        style: {
            fontStyle: "italic"
        }
    }, t), r ? g.createElement("pre", {
        style: s
    }, r) : null, null)
}
const u7 = g.createElement(l7, null);
class c7 extends g.Component {
    constructor(t) {
        super(t),
        this.state = {
            location: t.location,
            revalidation: t.revalidation,
            error: t.error
        }
    }
    static getDerivedStateFromError(t) {
        return {
            error: t
        }
    }
    static getDerivedStateFromProps(t, r) {
        return r.location !== t.location || r.revalidation !== "idle" && t.revalidation === "idle" ? {
            error: t.error,
            location: t.location,
            revalidation: t.revalidation
        } : {
            error: t.error !== void 0 ? t.error : r.error,
            location: r.location,
            revalidation: t.revalidation || r.revalidation
        }
    }
    componentDidCatch(t, r) {
        console.error("React Router caught the following error during render", t, r)
    }
    render() {
        return this.state.error !== void 0 ? g.createElement(bs.Provider, {
            value: this.props.routeContext
        }, g.createElement(Dk.Provider, {
            value: this.state.error,
            children: this.props.component
        })) : this.props.children
    }
}
function d7(e) {
    let {routeContext: t, match: r, children: n} = e
      , s = g.useContext(nc);
    return s && s.static && s.staticContext && (r.route.errorElement || r.route.ErrorBoundary) && (s.staticContext._deepestRenderedBoundaryId = r.route.id),
    g.createElement(bs.Provider, {
        value: t
    }, n)
}
function f7(e, t, r, n) {
    var s;
    if (t === void 0 && (t = []),
    r === void 0 && (r = null),
    n === void 0 && (n = null),
    e == null) {
        var i;
        if (!r)
            return null;
        if (r.errors)
            e = r.matches;
        else if ((i = n) != null && i.v7_partialHydration && t.length === 0 && !r.initialized && r.matches.length > 0)
            e = r.matches;
        else
            return null
    }
    let a = e
      , o = (s = r) == null ? void 0 : s.errors;
    if (o != null) {
        let f = a.findIndex(h => h.route.id && (o == null ? void 0 : o[h.route.id]) !== void 0);
        f >= 0 || Ne(!1),
        a = a.slice(0, Math.min(a.length, f + 1))
    }
    let l = !1
      , c = -1;
    if (r && n && n.v7_partialHydration)
        for (let f = 0; f < a.length; f++) {
            let h = a[f];
            if ((h.route.HydrateFallback || h.route.hydrateFallbackElement) && (c = f),
            h.route.id) {
                let {loaderData: m, errors: y} = r
                  , k = h.route.loader && m[h.route.id] === void 0 && (!y || y[h.route.id] === void 0);
                if (h.route.lazy || k) {
                    l = !0,
                    c >= 0 ? a = a.slice(0, c + 1) : a = [a[0]];
                    break
                }
            }
        }
    return a.reduceRight( (f, h, m) => {
        let y, k = !1, x = null, w = null;
        r && (y = o && h.route.id ? o[h.route.id] : void 0,
        x = h.route.errorElement || u7,
        l && (c < 0 && m === 0 ? (v7("route-fallback"),
        k = !0,
        w = null) : c === m && (k = !0,
        w = h.route.hydrateFallbackElement || null)));
        let v = t.concat(a.slice(0, m + 1))
          , p = () => {
            let S;
            return y ? S = x : k ? S = w : h.route.Component ? S = g.createElement(h.route.Component, null) : h.route.element ? S = h.route.element : S = f,
            g.createElement(d7, {
                match: h,
                routeContext: {
                    outlet: f,
                    matches: v,
                    isDataRoute: r != null
                },
                children: S
            })
        }
        ;
        return r && (h.route.ErrorBoundary || h.route.errorElement || m === 0) ? g.createElement(c7, {
            location: r.location,
            revalidation: r.revalidation,
            component: x,
            error: y,
            children: p(),
            routeContext: {
                outlet: null,
                matches: v,
                isDataRoute: !0
            }
        }) : p()
    }
    , null)
}
var Uk = function(e) {
    return e.UseBlocker = "useBlocker",
    e.UseRevalidator = "useRevalidator",
    e.UseNavigateStable = "useNavigate",
    e
}(Uk || {})
  , Vk = function(e) {
    return e.UseBlocker = "useBlocker",
    e.UseLoaderData = "useLoaderData",
    e.UseActionData = "useActionData",
    e.UseRouteError = "useRouteError",
    e.UseNavigation = "useNavigation",
    e.UseRouteLoaderData = "useRouteLoaderData",
    e.UseMatches = "useMatches",
    e.UseRevalidator = "useRevalidator",
    e.UseNavigateStable = "useNavigate",
    e.UseRouteId = "useRouteId",
    e
}(Vk || {});
function h7(e) {
    let t = g.useContext(nc);
    return t || Ne(!1),
    t
}
function m7(e) {
    let t = g.useContext(Xg);
    return t || Ne(!1),
    t
}
function p7(e) {
    let t = g.useContext(bs);
    return t || Ne(!1),
    t
}
function Bk(e) {
    let t = p7()
      , r = t.matches[t.matches.length - 1];
    return r.route.id || Ne(!1),
    r.route.id
}
function y7() {
    var e;
    let t = g.useContext(Dk)
      , r = m7(Vk.UseRouteError)
      , n = Bk();
    return t !== void 0 ? t : (e = r.errors) == null ? void 0 : e[n]
}
function g7() {
    let {router: e} = h7(Uk.UseNavigateStable)
      , t = Bk()
      , r = g.useRef(!1);
    return Fk( () => {
        r.current = !0
    }
    ),
    g.useCallback(function(s, i) {
        i === void 0 && (i = {}),
        r.current && (typeof s == "number" ? e.navigate(s) : e.navigate(s, xf({
            fromRouteId: t
        }, i)))
    }, [e, t])
}
const fx = {};
function v7(e, t, r) {
    fx[e] || (fx[e] = !0)
}
function b7(e, t) {
    e == null || e.v7_startTransition,
    (e == null ? void 0 : e.v7_relativeSplatPath) === void 0 && (!t || t.v7_relativeSplatPath),
    t && (t.v7_fetcherPersist,
    t.v7_normalizeFormMethod,
    t.v7_partialHydration,
    t.v7_skipActionErrorRevalidation)
}
function el(e) {
    return a7(e.context)
}
function x7(e) {
    let {basename: t="/", children: r=null, location: n, navigationType: s=Pt.Pop, navigator: i, static: a=!1, future: o} = e;
    sc() && Ne(!1);
    let l = t.replace(/^\/*/, "/")
      , c = g.useMemo( () => ({
        basename: l,
        navigator: i,
        static: a,
        future: xf({
            v7_relativeSplatPath: !1
        }, o)
    }), [l, o, i, a]);
    typeof n == "string" && (n = wi(n));
    let {pathname: f="/", search: h="", hash: m="", state: y=null, key: k="default"} = n
      , x = g.useMemo( () => {
        let w = hs(f, l);
        return w == null ? null : {
            location: {
                pathname: w,
                search: h,
                hash: m,
                state: y,
                key: k
            },
            navigationType: s
        }
    }
    , [l, f, h, m, y, k, s]);
    return x == null ? null : g.createElement(Si.Provider, {
        value: c
    }, g.createElement(ev.Provider, {
        children: r,
        value: x
    }))
}
new Promise( () => {}
);
function w7(e) {
    let t = {
        hasErrorBoundary: e.ErrorBoundary != null || e.errorElement != null
    };
    return e.Component && Object.assign(t, {
        element: g.createElement(e.Component),
        Component: void 0
    }),
    e.HydrateFallback && Object.assign(t, {
        hydrateFallbackElement: g.createElement(e.HydrateFallback),
        HydrateFallback: void 0
    }),
    e.ErrorBoundary && Object.assign(t, {
        errorElement: g.createElement(e.ErrorBoundary),
        ErrorBoundary: void 0
    }),
    t
}
/**
 * React Router DOM v6.30.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function Fo() {
    return Fo = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var r = arguments[t];
            for (var n in r)
                Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n])
        }
        return e
    }
    ,
    Fo.apply(this, arguments)
}
function Wk(e, t) {
    if (e == null)
        return {};
    var r = {}, n = Object.keys(e), s, i;
    for (i = 0; i < n.length; i++)
        s = n[i],
        !(t.indexOf(s) >= 0) && (r[s] = e[s]);
    return r
}
function S7(e) {
    return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)
}
function k7(e, t) {
    return e.button === 0 && (!t || t === "_self") && !S7(e)
}
function ey(e) {
    return e === void 0 && (e = ""),
    new URLSearchParams(typeof e == "string" || Array.isArray(e) || e instanceof URLSearchParams ? e : Object.keys(e).reduce( (t, r) => {
        let n = e[r];
        return t.concat(Array.isArray(n) ? n.map(s => [r, s]) : [[r, n]])
    }
    , []))
}
function E7(e, t) {
    let r = ey(e);
    return t && t.forEach( (n, s) => {
        r.has(s) || t.getAll(s).forEach(i => {
            r.append(s, i)
        }
        )
    }
    ),
    r
}
const _7 = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset", "viewTransition"]
  , T7 = ["aria-current", "caseSensitive", "className", "end", "style", "to", "viewTransition", "children"]
  , C7 = "6";
try {
    window.__reactRouterVersion = C7
} catch {}
function P7(e, t) {
    return Lz({
        basename: void 0,
        future: Fo({}, void 0, {
            v7_prependBasename: !0
        }),
        history: oz({
            window: void 0
        }),
        hydrationData: $7(),
        routes: e,
        mapRouteProperties: w7,
        dataStrategy: void 0,
        patchRoutesOnNavigation: void 0,
        window: void 0
    }).initialize()
}
function $7() {
    var e;
    let t = (e = window) == null ? void 0 : e.__staticRouterHydrationData;
    return t && t.errors && (t = Fo({}, t, {
        errors: N7(t.errors)
    })),
    t
}
function N7(e) {
    if (!e)
        return null;
    let t = Object.entries(e)
      , r = {};
    for (let[n,s] of t)
        if (s && s.__type === "RouteErrorResponse")
            r[n] = new bf(s.status,s.statusText,s.data,s.internal === !0);
        else if (s && s.__type === "Error") {
            if (s.__subType) {
                let i = window[s.__subType];
                if (typeof i == "function")
                    try {
                        let a = new i(s.message);
                        a.stack = "",
                        r[n] = a
                    } catch {}
            }
            if (r[n] == null) {
                let i = new Error(s.message);
                i.stack = "",
                r[n] = i
            }
        } else
            r[n] = s;
    return r
}
const qk = g.createContext({
    isTransitioning: !1
})
  , j7 = g.createContext(new Map)
  , I7 = "startTransition"
  , hx = RT[I7]
  , R7 = "flushSync"
  , mx = az[R7];
function O7(e) {
    hx ? hx(e) : e()
}
function El(e) {
    mx ? mx(e) : e()
}
class M7 {
    constructor() {
        this.status = "pending",
        this.promise = new Promise( (t, r) => {
            this.resolve = n => {
                this.status === "pending" && (this.status = "resolved",
                t(n))
            }
            ,
            this.reject = n => {
                this.status === "pending" && (this.status = "rejected",
                r(n))
            }
        }
        )
    }
}
function A7(e) {
    let {fallbackElement: t, router: r, future: n} = e
      , [s,i] = g.useState(r.state)
      , [a,o] = g.useState()
      , [l,c] = g.useState({
        isTransitioning: !1
    })
      , [f,h] = g.useState()
      , [m,y] = g.useState()
      , [k,x] = g.useState()
      , w = g.useRef(new Map)
      , {v7_startTransition: v} = n || {}
      , p = g.useCallback(b => {
        v ? O7(b) : b()
    }
    , [v])
      , S = g.useCallback( (b, O) => {
        let {deletedFetchers: M, flushSync: D, viewTransitionOpts: z} = O;
        b.fetchers.forEach( (Y, ce) => {
            Y.data !== void 0 && w.current.set(ce, Y.data)
        }
        ),
        M.forEach(Y => w.current.delete(Y));
        let $ = r.window == null || r.window.document == null || typeof r.window.document.startViewTransition != "function";
        if (!z || $) {
            D ? El( () => i(b)) : p( () => i(b));
            return
        }
        if (D) {
            El( () => {
                m && (f && f.resolve(),
                m.skipTransition()),
                c({
                    isTransitioning: !0,
                    flushSync: !0,
                    currentLocation: z.currentLocation,
                    nextLocation: z.nextLocation
                })
            }
            );
            let Y = r.window.document.startViewTransition( () => {
                El( () => i(b))
            }
            );
            Y.finished.finally( () => {
                El( () => {
                    h(void 0),
                    y(void 0),
                    o(void 0),
                    c({
                        isTransitioning: !1
                    })
                }
                )
            }
            ),
            El( () => y(Y));
            return
        }
        m ? (f && f.resolve(),
        m.skipTransition(),
        x({
            state: b,
            currentLocation: z.currentLocation,
            nextLocation: z.nextLocation
        })) : (o(b),
        c({
            isTransitioning: !0,
            flushSync: !1,
            currentLocation: z.currentLocation,
            nextLocation: z.nextLocation
        }))
    }
    , [r.window, m, f, w, p]);
    g.useLayoutEffect( () => r.subscribe(S), [r, S]),
    g.useEffect( () => {
        l.isTransitioning && !l.flushSync && h(new M7)
    }
    , [l]),
    g.useEffect( () => {
        if (f && a && r.window) {
            let b = a
              , O = f.promise
              , M = r.window.document.startViewTransition(async () => {
                p( () => i(b)),
                await O
            }
            );
            M.finished.finally( () => {
                h(void 0),
                y(void 0),
                o(void 0),
                c({
                    isTransitioning: !1
                })
            }
            ),
            y(M)
        }
    }
    , [p, a, f, r.window]),
    g.useEffect( () => {
        f && a && s.location.key === a.location.key && f.resolve()
    }
    , [f, m, s.location, a]),
    g.useEffect( () => {
        !l.isTransitioning && k && (o(k.state),
        c({
            isTransitioning: !0,
            flushSync: !1,
            currentLocation: k.currentLocation,
            nextLocation: k.nextLocation
        }),
        x(void 0))
    }
    , [l.isTransitioning, k]),
    g.useEffect( () => {}
    , []);
    let P = g.useMemo( () => ({
        createHref: r.createHref,
        encodeLocation: r.encodeLocation,
        go: b => r.navigate(b),
        push: (b, O, M) => r.navigate(b, {
            state: O,
            preventScrollReset: M == null ? void 0 : M.preventScrollReset
        }),
        replace: (b, O, M) => r.navigate(b, {
            replace: !0,
            state: O,
            preventScrollReset: M == null ? void 0 : M.preventScrollReset
        })
    }), [r])
      , j = r.basename || "/"
      , L = g.useMemo( () => ({
        router: r,
        navigator: P,
        static: !1,
        basename: j
    }), [r, P, j])
      , E = g.useMemo( () => ({
        v7_relativeSplatPath: r.future.v7_relativeSplatPath
    }), [r.future.v7_relativeSplatPath]);
    return g.useEffect( () => b7(n, r.future), [n, r.future]),
    g.createElement(g.Fragment, null, g.createElement(nc.Provider, {
        value: L
    }, g.createElement(Xg.Provider, {
        value: s
    }, g.createElement(j7.Provider, {
        value: w.current
    }, g.createElement(qk.Provider, {
        value: l
    }, g.createElement(x7, {
        basename: j,
        location: s.location,
        navigationType: s.historyAction,
        navigator: P,
        future: E
    }, s.initialized || r.future.v7_partialHydration ? g.createElement(L7, {
        routes: r.routes,
        future: r.future,
        state: s
    }) : t))))), null)
}
const L7 = g.memo(D7);
function D7(e) {
    let {routes: t, future: r, state: n} = e;
    return o7(t, void 0, n, r)
}
const F7 = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u"
  , z7 = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i
  , Kt = g.forwardRef(function(t, r) {
    let {onClick: n, relative: s, reloadDocument: i, replace: a, state: o, target: l, to: c, preventScrollReset: f, viewTransition: h} = t, m = Wk(t, _7), {basename: y} = g.useContext(Si), k, x = !1;
    if (typeof c == "string" && z7.test(c) && (k = c,
    F7))
        try {
            let S = new URL(window.location.href)
              , P = c.startsWith("//") ? new URL(S.protocol + c) : new URL(c)
              , j = hs(P.pathname, y);
            P.origin === S.origin && j != null ? c = j + P.search + P.hash : x = !0
        } catch {}
    let w = n7(c, {
        relative: s
    })
      , v = V7(c, {
        replace: a,
        state: o,
        target: l,
        preventScrollReset: f,
        relative: s,
        viewTransition: h
    });
    function p(S) {
        n && n(S),
        S.defaultPrevented || v(S)
    }
    return g.createElement("a", Fo({}, m, {
        href: k || w,
        onClick: x || i ? n : p,
        ref: r,
        target: l
    }))
})
  , On = g.forwardRef(function(t, r) {
    let {"aria-current": n="page", caseSensitive: s=!1, className: i="", end: a=!1, style: o, to: l, viewTransition: c, children: f} = t
      , h = Wk(t, T7)
      , m = dh(l, {
        relative: h.relative
    })
      , y = Xo()
      , k = g.useContext(Xg)
      , {navigator: x, basename: w} = g.useContext(Si)
      , v = k != null && B7(m) && c === !0
      , p = x.encodeLocation ? x.encodeLocation(m).pathname : m.pathname
      , S = y.pathname
      , P = k && k.navigation && k.navigation.location ? k.navigation.location.pathname : null;
    s || (S = S.toLowerCase(),
    P = P ? P.toLowerCase() : null,
    p = p.toLowerCase()),
    P && w && (P = hs(P, w) || P);
    const j = p !== "/" && p.endsWith("/") ? p.length - 1 : p.length;
    let L = S === p || !a && S.startsWith(p) && S.charAt(j) === "/", E = P != null && (P === p || !a && P.startsWith(p) && P.charAt(p.length) === "/"), b = {
        isActive: L,
        isPending: E,
        isTransitioning: v
    }, O = L ? n : void 0, M;
    typeof i == "function" ? M = i(b) : M = [i, L ? "active" : null, E ? "pending" : null, v ? "transitioning" : null].filter(Boolean).join(" ");
    let D = typeof o == "function" ? o(b) : o;
    return g.createElement(Kt, Fo({}, h, {
        "aria-current": O,
        className: M,
        ref: r,
        style: D,
        to: l,
        viewTransition: c
    }), typeof f == "function" ? f(b) : f)
});
var ty;
(function(e) {
    e.UseScrollRestoration = "useScrollRestoration",
    e.UseSubmit = "useSubmit",
    e.UseSubmitFetcher = "useSubmitFetcher",
    e.UseFetcher = "useFetcher",
    e.useViewTransitionState = "useViewTransitionState"
}
)(ty || (ty = {}));
var px;
(function(e) {
    e.UseFetcher = "useFetcher",
    e.UseFetchers = "useFetchers",
    e.UseScrollRestoration = "useScrollRestoration"
}
)(px || (px = {}));
function U7(e) {
    let t = g.useContext(nc);
    return t || Ne(!1),
    t
}
function V7(e, t) {
    let {target: r, replace: n, state: s, preventScrollReset: i, relative: a, viewTransition: o} = t === void 0 ? {} : t
      , l = ki()
      , c = Xo()
      , f = dh(e, {
        relative: a
    });
    return g.useCallback(h => {
        if (k7(h, r)) {
            h.preventDefault();
            let m = n !== void 0 ? n : ma(c) === ma(f);
            l(e, {
                replace: m,
                state: s,
                preventScrollReset: i,
                relative: a,
                viewTransition: o
            })
        }
    }
    , [c, l, f, n, s, r, e, i, a, o])
}
function ir(e) {
    let t = g.useRef(ey(e))
      , r = g.useRef(!1)
      , n = Xo()
      , s = g.useMemo( () => E7(n.search, r.current ? null : t.current), [n.search])
      , i = ki()
      , a = g.useCallback( (o, l) => {
        const c = ey(typeof o == "function" ? o(s) : o);
        r.current = !0,
        i("?" + c, l)
    }
    , [i, s]);
    return [s, a]
}
function B7(e, t) {
    t === void 0 && (t = {});
    let r = g.useContext(qk);
    r == null && Ne(!1);
    let {basename: n} = U7(ty.useViewTransitionState)
      , s = dh(e, {
        relative: t.relative
    });
    if (!r.isTransitioning)
        return !1;
    let i = hs(r.currentLocation.pathname, n) || r.currentLocation.pathname
      , a = hs(r.nextLocation.pathname, n) || r.nextLocation.pathname;
    return vf(s.pathname, a) != null || vf(s.pathname, i) != null
}
function W7() {
    const e = ng();
    return Ft({
        async mutationFn(t) {
            return A6(t.id)
        },
        async onMutate() {
            await e.update({
                inventoryRemaining: "increment"
            })
        },
        async onError() {
            await e.update({
                inventoryRemaining: "decrement"
            })
        },
        async onSuccess(t) {
            Om(t);
            const r = Se.balance - t.value.amount;
            Ve.emit("sync:store", {
                balance: r
            })
        }
    })
}
function q7(e) {
    const t = jt();
    return Ft({
        ...e,
        async mutationFn() {
            const r = await D6();
            if (!r.ok)
                throw new Error(r.error.message);
            return r.value
        },
        async onSuccess() {
            const r = await Ww();
            if (!r.ok)
                throw new Error(r.error.message);
            await Ve.emit("sync:store", {
                balance: r.value
            }),
            await t.invalidateQueries({
                queryKey: ["me"]
            })
        }
    })
}
function H7(e) {
    return Ft({
        ...e,
        async mutationFn(t) {
            return V6(t.id, t.data)
        }
    })
}
function Z7(e) {
    return Ft({
        ...e,
        async mutationFn(t) {
            return er( () => W6(t.id, t.data))
        }
    })
}
function tv(e) {
    return Ft({
        ...e,
        mutationFn(t) {
            return er( () => H6(t.id, t.data))
        },
        onMutate(t) {
            const r = Se.isJoinable;
            return typeof t.data.isJoinable == "boolean" && (Se.isJoinable = t.data.isJoinable),
            {
                prevValue: r
            }
        },
        onError(t, r, n) {
            typeof (n == null ? void 0 : n.prevValue) == "boolean" && (Se.isJoinable = n.prevValue)
        }
    })
}
function K7() {
    return Ft({
        async mutationFn({username: e, ...t}) {
            return B5(e, t)
        }
    })
}
function Hk(e) {
    const t = jt();
    return Ft({
        ...e,
        async mutationFn(r) {
            const n = await er( () => w5(r));
            if (!n.ok)
                throw new Error(n.error.message);
            return n.value
        },
        onSettled(r, n, {blobId: s}) {
            t.invalidateQueries({
                queryKey: ["admin", "inventory"]
            })
        }
    })
}
function Zk() {
    return Ft({
        mutationFn: async e => gw(e.id, () => k5(e.id))
    })
}
function Q7() {
    return Ft({
        mutationFn: async e => er( () => _5(e.id))
    })
}
function G7() {
    return Ft({
        async mutationFn({username: e}) {
            const t = await j5(e);
            if (!t.ok)
                throw new Error(t.error.message);
            return await Ve.emit("friend:goto", {
                room: t.value.room,
                friend: {
                    username: t.value.user.displayName,
                    displayName: t.value.user.displayName,
                    friendshipId: "n/a",
                    ggwpStatus: "active",
                    isJoinable: !0,
                    userId: t.value.user.id,
                    currentRoomId: t.value.room.id
                }
            }),
            t.value
        }
    })
}
function Y7(e) {
    const t = jt();
    return Ft({
        ...e,
        async mutationFn({id: r, ...n}) {
            const s = await er( () => U5(r, n));
            if (!s.ok)
                throw new Error(s.error.message);
            return s.value
        },
        onSuccess() {
            t.invalidateQueries({
                queryKey: ["admin", "reports"]
            })
        }
    })
}
function J7(e) {
    return _n({
        queryKey: ["me", "inventory", e],
        queryFn: e ? () => Da(e) : ga
    })
}
function X7(e, t) {
    return _n({
        ...t,
        queryKey: ["products", e],
        queryFn: () => c6(e)
    })
}
function rv() {
    return _n({
        queryKey: ["me", "limits", "products"],
        queryFn: () => g6()
    })
}
function Kk(e) {
    return rg({
        queryKey: ["me", "friend-requests"],
        queryFn({pageParam: t}) {
            return k6({
                cursor: t || void 0,
                limit: 100,
                ...e
            })
        },
        getNextPageParam: t => t.ok ? t.value.nextCursor : null,
        initialPageParam: ""
    })
}
function e9() {
    return _n({
        queryKey: ["lost-found"],
        queryFn: () => w6()
    })
}
function Qk(e) {
    return _n({
        ...e,
        queryKey: ["me", "friends"],
        queryFn: async () => {
            let t = !0, r, n = new Array;
            for (; t; ) {
                const s = await _6({
                    cursor: r,
                    limit: 250
                });
                s.ok && (n = [...n, ...s.value.items],
                r = s.value.nextCursor,
                t = !!s.value.nextCursor)
            }
            return n
        }
    })
}
let yx = 0;
function Gk(e, t) {
    const [r,n] = g.useState(yx);
    return {
        ...rg({
            ...t,
            queryKey: ["products", e, r],
            queryFn: ({pageParam: i}) => $6({
                ...e,
                cursor: i
            }),
            initialPageParam: void 0,
            getNextPageParam: i => i.ok ? i.value.nextCursor : void 0,
            staleTime: 1e3 * 3,
            maxPages: 25
        }),
        refresh() {
            n(++yx)
        }
    }
}
function t9(e) {
    return _n({
        queryKey: ["users", e],
        queryFn: e.name ? async () => qw(e) : ga
    })
}
function r9(e) {
    return _n({
        queryKey: ["admin", "reports", e, "blob"],
        queryFn: () => C5(e)
    })
}
function n9(e) {
    return _n({
        queryKey: ["admin", "reports", e],
        queryFn: () => $5(e)
    })
}
function s9(e) {
    return _n({
        queryKey: ["admin", "inventory", e],
        queryFn: e ? () => R5(e) : ga
    })
}
function i9(e) {
    return _n({
        queryKey: ["admin", "lost-found", e],
        queryFn: e ? async () => M5(e) : ga
    })
}
function a9(e, t) {
    return _n({
        ...t,
        queryKey: ["admin", "products", e],
        queryFn: async () => L5(e)
    })
}
function o9(e) {
    const t = jt();
    return {
        ...rg({
            queryKey: ["admin", "reports", e],
            queryFn({pageParam: n}) {
                return console.log(n),
                F5({
                    cursor: n,
                    ...e
                })
            },
            initialPageParam: void 0,
            getNextPageParam(n, s, i) {
                console.log(n);
                const a = n.ok && n.value.nextCursor;
                return a && a !== i ? a : void 0
            },
            staleTime: 1e3 * 3,
            maxPages: 25
        }),
        refresh() {
            t.invalidateQueries({
                queryKey: ["admin", "reports"]
            })
        }
    }
}
const l9 = u.union([u.object({
    type: u.literal("error"),
    error: u.string(),
    challenge: u.string().nullable().optional()
}), u.object({
    type: u.literal("subscribed"),
    attrs: u.object({
        id: u.string(),
        challenge: u.string().nullable().optional()
    })
}), u.object({
    type: u.literal("product_purchased"),
    attrs: u.object({
        productId: u.string(),
        productName: u.string(),
        productPrice: u.number()
    })
}), u.object({
    type: u.literal("user_balance_changed"),
    attrs: u.object({
        balance: u.number()
    })
}), u.object({
    type: u.literal("user_usage_limits_changed")
})])
  , gx = JSON.stringify({
    type: "ping"
});
class u9 {
    constructor(t) {
        St(this, "url");
        St(this, "ws", null);
        St(this, "isVrProxied", !!Ve.client);
        St(this, "isConnected", !1);
        St(this, "handlers");
        St(this, "pingInterval");
        St(this, "reconnectInterval");
        St(this, "vuplexUnsub");
        St(this, "maxAttempts", 10);
        St(this, "baseDelay", 3e3);
        St(this, "maxDelay", 6e3);
        St(this, "attempt", 0);
        St(this, "handleOnline", () => {
            this.isVrProxied || (console.log("[SubscriptionClient] Internet is back online. Reconnecting WebSocket..."),
            this.connect().catch(t => console.error("[SubscriptionClient] Error reconnecting WebSocket:", t)))
        }
        );
        St(this, "handleOffline", () => {
            this.isVrProxied || (console.log("[SubscriptionClient] Internet is offline. Disconnecting WebSocket..."),
            this.disconnect().catch(t => console.error("[SubscriptionClient] Error disconnecting WebSocket:", t)))
        }
        );
        St(this, "connect", async () => {
            if (!(this.attempt >= this.maxAttempts))
                return this.isVrProxied && (this.isConnected = !0,
                this.vuplexUnsub = Ve.listen(t => {
                    t.type === "sync:ws_message" && this.handleMessage(t.attrs.value)
                }
                )),
                this.isConnected || this.attempt >= this.maxAttempts || !Se.accessToken ? Promise.resolve() : new Promise( (t, r) => {
                    try {
                        const n = Ve.client ? "proxied" : "browser";
                        this.ws = new WebSocket(`${this.url}?context=web&debug=${n}&token=${Se.accessToken}`),
                        this.ws.onopen = () => {
                            var s;
                            this.attempt = 0,
                            this.isConnected = !0,
                            console.log("[SubscriptionClient.connect] WebSocket connection established."),
                            this.pingInterval = setInterval( () => {
                                var i;
                                (i = this.ws) == null || i.send(gx)
                            }
                            , 1e3 * 5),
                            (s = this.ws) == null || s.send(gx),
                            t()
                        }
                        ,
                        this.ws.onerror = s => {
                            console.error("[SubscriptionClient.connect] WebSocket error:", s),
                            r(s)
                        }
                        ,
                        this.ws.onmessage = s => {
                            this.handleMessage(s.data)
                        }
                        ,
                        this.ws.onclose = s => {
                            console.log("[SubscriptionClient.connect] WebSocket connection closed.", s),
                            this.isConnected = !1,
                            this.ws = null,
                            this.pingInterval && clearInterval(this.pingInterval);
                            const i = this.calculateBackoff();
                            this.reconnectInterval = setTimeout( () => {
                                this.attempt += 1,
                                this.connect()
                            }
                            , i)
                        }
                    } catch (n) {
                        console.error("[SubscriptionClient.connect] WebSocket error during connection:", n),
                        r(n)
                    }
                }
                )
        }
        );
        St(this, "disconnect", async () => {
            var t;
            this.ws && (this.ws.close(),
            this.ws = null,
            console.log("[SubscriptionClient.disconnect] WebSocket connection closed manually.")),
            (t = this.vuplexUnsub) == null || t.call(this),
            this.isConnected = !1
        }
        );
        St(this, "registerHandler", async t => (this.handlers.add(t),
        () => {
            this.handlers.delete(t)
        }
        ));
        St(this, "handleMessage", t => {
            const r = l9.safeParse(JSON.parse(t));
            if (!r.success) {
                console.error("[SubscriptionClient.handleMessage] Invalid message received", {
                    error: r.error,
                    event: t
                });
                return
            }
            switch (r.data.type) {
            case "subscribed":
            case "error":
                break;
            case "user_usage_limits_changed":
            case "product_purchased":
            case "user_balance_changed":
                {
                    for (const n of [...this.handlers])
                        n(r.data);
                    break
                }
            default:
                r.data
            }
        }
        );
        St(this, "unsubscribe", t => {
            this.handlers.delete(t)
        }
        );
        St(this, "cleanup", () => {
            window.removeEventListener("online", this.handleOnline),
            window.removeEventListener("offline", this.handleOffline)
        }
        );
        this.url = t.url,
        this.handlers = new Set,
        window.addEventListener("online", this.handleOnline),
        window.addEventListener("offline", this.handleOffline)
    }
    calculateBackoff() {
        let t = this.baseDelay * 2 ** this.attempt;
        const r = Math.random() * t * .5;
        return t = Math.min(t + r, this.maxDelay),
        Math.min(t, this.maxDelay)
    }
}
function Yk(e) {
    var t, r, n = "";
    if (typeof e == "string" || typeof e == "number")
        n += e;
    else if (typeof e == "object")
        if (Array.isArray(e)) {
            var s = e.length;
            for (t = 0; t < s; t++)
                e[t] && (r = Yk(e[t])) && (n && (n += " "),
                n += r)
        } else
            for (r in e)
                e[r] && (n && (n += " "),
                n += r);
    return n
}
function fe() {
    for (var e, t, r = 0, n = "", s = arguments.length; r < s; r++)
        (e = arguments[r]) && (t = Yk(e)) && (n && (n += " "),
        n += t);
    return n
}
var Jk, vx = ch;
Jk = vx.createRoot,
vx.hydrateRoot;
let c9 = {
    data: ""
}
  , d9 = e => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), {
    innerHTML: " ",
    id: "_goober"
})).firstChild : e || c9
  , f9 = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g
  , h9 = /\/\*[^]*?\*\/|  +/g
  , bx = /\n+/g
  , As = (e, t) => {
    let r = ""
      , n = ""
      , s = "";
    for (let i in e) {
        let a = e[i];
        i[0] == "@" ? i[1] == "i" ? r = i + " " + a + ";" : n += i[1] == "f" ? As(a, i) : i + "{" + As(a, i[1] == "k" ? "" : t) + "}" : typeof a == "object" ? n += As(a, t ? t.replace(/([^,])+/g, o => i.replace(/([^,]*:\S+\([^)]*\))|([^,])+/g, l => /&/.test(l) ? l.replace(/&/g, o) : o ? o + " " + l : l)) : i) : a != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(),
        s += As.p ? As.p(i, a) : i + ":" + a + ";")
    }
    return r + (t && s ? t + "{" + s + "}" : s) + n
}
  , Hn = {}
  , Xk = e => {
    if (typeof e == "object") {
        let t = "";
        for (let r in e)
            t += r + Xk(e[r]);
        return t
    }
    return e
}
  , m9 = (e, t, r, n, s) => {
    let i = Xk(e)
      , a = Hn[i] || (Hn[i] = (l => {
        let c = 0
          , f = 11;
        for (; c < l.length; )
            f = 101 * f + l.charCodeAt(c++) >>> 0;
        return "go" + f
    }
    )(i));
    if (!Hn[a]) {
        let l = i !== e ? e : (c => {
            let f, h, m = [{}];
            for (; f = f9.exec(c.replace(h9, "")); )
                f[4] ? m.shift() : f[3] ? (h = f[3].replace(bx, " ").trim(),
                m.unshift(m[0][h] = m[0][h] || {})) : m[0][f[1]] = f[2].replace(bx, " ").trim();
            return m[0]
        }
        )(e);
        Hn[a] = As(s ? {
            ["@keyframes " + a]: l
        } : l, r ? "" : "." + a)
    }
    let o = r && Hn.g ? Hn.g : null;
    return r && (Hn.g = Hn[a]),
    ( (l, c, f, h) => {
        h ? c.data = c.data.replace(h, l) : c.data.indexOf(l) === -1 && (c.data = f ? l + c.data : c.data + l)
    }
    )(Hn[a], t, n, o),
    a
}
  , p9 = (e, t, r) => e.reduce( (n, s, i) => {
    let a = t[i];
    if (a && a.call) {
        let o = a(r)
          , l = o && o.props && o.props.className || /^go/.test(o) && o;
        a = l ? "." + l : o && typeof o == "object" ? o.props ? "" : As(o, "") : o === !1 ? "" : o
    }
    return n + s + (a ?? "")
}
, "");
function fh(e) {
    let t = this || {}
      , r = e.call ? e(t.p) : e;
    return m9(r.unshift ? r.raw ? p9(r, [].slice.call(arguments, 1), t.p) : r.reduce( (n, s) => Object.assign(n, s && s.call ? s(t.p) : s), {}) : r, d9(t.target), t.g, t.o, t.k)
}
let eE, ry, ny;
fh.bind({
    g: 1
});
let ms = fh.bind({
    k: 1
});
function y9(e, t, r, n) {
    As.p = t,
    eE = e,
    ry = r,
    ny = n
}
function Ei(e, t) {
    let r = this || {};
    return function() {
        let n = arguments;
        function s(i, a) {
            let o = Object.assign({}, i)
              , l = o.className || s.className;
            r.p = Object.assign({
                theme: ry && ry()
            }, o),
            r.o = / *go\d+/.test(l),
            o.className = fh.apply(r, n) + (l ? " " + l : "");
            let c = e;
            return e[0] && (c = o.as || e,
            delete o.as),
            ny && c[0] && ny(o),
            eE(c, o)
        }
        return s
    }
}
var g9 = e => typeof e == "function"
  , wf = (e, t) => g9(e) ? e(t) : e
  , v9 = ( () => {
    let e = 0;
    return () => (++e).toString()
}
)()
  , tE = ( () => {
    let e;
    return () => {
        if (e === void 0 && typeof window < "u") {
            let t = matchMedia("(prefers-reduced-motion: reduce)");
            e = !t || t.matches
        }
        return e
    }
}
)()
  , b9 = 20
  , rE = (e, t) => {
    switch (t.type) {
    case 0:
        return {
            ...e,
            toasts: [t.toast, ...e.toasts].slice(0, b9)
        };
    case 1:
        return {
            ...e,
            toasts: e.toasts.map(i => i.id === t.toast.id ? {
                ...i,
                ...t.toast
            } : i)
        };
    case 2:
        let {toast: r} = t;
        return rE(e, {
            type: e.toasts.find(i => i.id === r.id) ? 1 : 0,
            toast: r
        });
    case 3:
        let {toastId: n} = t;
        return {
            ...e,
            toasts: e.toasts.map(i => i.id === n || n === void 0 ? {
                ...i,
                dismissed: !0,
                visible: !1
            } : i)
        };
    case 4:
        return t.toastId === void 0 ? {
            ...e,
            toasts: []
        } : {
            ...e,
            toasts: e.toasts.filter(i => i.id !== t.toastId)
        };
    case 5:
        return {
            ...e,
            pausedAt: t.time
        };
    case 6:
        let s = t.time - (e.pausedAt || 0);
        return {
            ...e,
            pausedAt: void 0,
            toasts: e.toasts.map(i => ({
                ...i,
                pauseDuration: i.pauseDuration + s
            }))
        }
    }
}
  , bd = []
  , Ui = {
    toasts: [],
    pausedAt: void 0
}
  , xa = e => {
    Ui = rE(Ui, e),
    bd.forEach(t => {
        t(Ui)
    }
    )
}
  , x9 = {
    blank: 4e3,
    error: 4e3,
    success: 2e3,
    loading: 1 / 0,
    custom: 4e3
}
  , w9 = (e={}) => {
    let[t,r] = g.useState(Ui)
      , n = g.useRef(Ui);
    g.useEffect( () => (n.current !== Ui && r(Ui),
    bd.push(r),
    () => {
        let i = bd.indexOf(r);
        i > -1 && bd.splice(i, 1)
    }
    ), []);
    let s = t.toasts.map(i => {
        var a, o, l;
        return {
            ...e,
            ...e[i.type],
            ...i,
            removeDelay: i.removeDelay || ((a = e[i.type]) == null ? void 0 : a.removeDelay) || (e == null ? void 0 : e.removeDelay),
            duration: i.duration || ((o = e[i.type]) == null ? void 0 : o.duration) || (e == null ? void 0 : e.duration) || x9[i.type],
            style: {
                ...e.style,
                ...(l = e[i.type]) == null ? void 0 : l.style,
                ...i.style
            }
        }
    }
    );
    return {
        ...t,
        toasts: s
    }
}
  , S9 = (e, t="blank", r) => ({
    createdAt: Date.now(),
    visible: !0,
    dismissed: !1,
    type: t,
    ariaProps: {
        role: "status",
        "aria-live": "polite"
    },
    message: e,
    pauseDuration: 0,
    ...r,
    id: (r == null ? void 0 : r.id) || v9()
})
  , ic = e => (t, r) => {
    let n = S9(t, e, r);
    return xa({
        type: 2,
        toast: n
    }),
    n.id
}
  , fr = (e, t) => ic("blank")(e, t);
fr.error = ic("error");
fr.success = ic("success");
fr.loading = ic("loading");
fr.custom = ic("custom");
fr.dismiss = e => {
    xa({
        type: 3,
        toastId: e
    })
}
;
fr.remove = e => xa({
    type: 4,
    toastId: e
});
fr.promise = (e, t, r) => {
    let n = fr.loading(t.loading, {
        ...r,
        ...r == null ? void 0 : r.loading
    });
    return typeof e == "function" && (e = e()),
    e.then(s => {
        let i = t.success ? wf(t.success, s) : void 0;
        return i ? fr.success(i, {
            id: n,
            ...r,
            ...r == null ? void 0 : r.success
        }) : fr.dismiss(n),
        s
    }
    ).catch(s => {
        let i = t.error ? wf(t.error, s) : void 0;
        i ? fr.error(i, {
            id: n,
            ...r,
            ...r == null ? void 0 : r.error
        }) : fr.dismiss(n)
    }
    ),
    e
}
;
var k9 = (e, t) => {
    xa({
        type: 1,
        toast: {
            id: e,
            height: t
        }
    })
}
  , E9 = () => {
    xa({
        type: 5,
        time: Date.now()
    })
}
  , Jl = new Map
  , _9 = 1e3
  , T9 = (e, t=_9) => {
    if (Jl.has(e))
        return;
    let r = setTimeout( () => {
        Jl.delete(e),
        xa({
            type: 4,
            toastId: e
        })
    }
    , t);
    Jl.set(e, r)
}
  , C9 = e => {
    let {toasts: t, pausedAt: r} = w9(e);
    g.useEffect( () => {
        if (r)
            return;
        let i = Date.now()
          , a = t.map(o => {
            if (o.duration === 1 / 0)
                return;
            let l = (o.duration || 0) + o.pauseDuration - (i - o.createdAt);
            if (l < 0) {
                o.visible && fr.dismiss(o.id);
                return
            }
            return setTimeout( () => fr.dismiss(o.id), l)
        }
        );
        return () => {
            a.forEach(o => o && clearTimeout(o))
        }
    }
    , [t, r]);
    let n = g.useCallback( () => {
        r && xa({
            type: 6,
            time: Date.now()
        })
    }
    , [r])
      , s = g.useCallback( (i, a) => {
        let {reverseOrder: o=!1, gutter: l=8, defaultPosition: c} = a || {}
          , f = t.filter(y => (y.position || c) === (i.position || c) && y.height)
          , h = f.findIndex(y => y.id === i.id)
          , m = f.filter( (y, k) => k < h && y.visible).length;
        return f.filter(y => y.visible).slice(...o ? [m + 1] : [0, m]).reduce( (y, k) => y + (k.height || 0) + l, 0)
    }
    , [t]);
    return g.useEffect( () => {
        t.forEach(i => {
            if (i.dismissed)
                T9(i.id, i.removeDelay);
            else {
                let a = Jl.get(i.id);
                a && (clearTimeout(a),
                Jl.delete(i.id))
            }
        }
        )
    }
    , [t]),
    {
        toasts: t,
        handlers: {
            updateHeight: k9,
            startPause: E9,
            endPause: n,
            calculateOffset: s
        }
    }
}
  , P9 = ms`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`
  , $9 = ms`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`
  , N9 = ms`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`
  , j9 = Ei("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${e => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${P9} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${$9} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${e => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${N9} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`
  , I9 = ms`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`
  , R9 = Ei("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${e => e.secondary || "#e0e0e0"};
  border-right-color: ${e => e.primary || "#616161"};
  animation: ${I9} 1s linear infinite;
`
  , O9 = ms`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`
  , M9 = ms`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`
  , A9 = Ei("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${e => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${O9} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${M9} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${e => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`
  , L9 = Ei("div")`
  position: absolute;
`
  , D9 = Ei("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`
  , F9 = ms`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`
  , z9 = Ei("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${F9} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`
  , U9 = ({toast: e}) => {
    let {icon: t, type: r, iconTheme: n} = e;
    return t !== void 0 ? typeof t == "string" ? g.createElement(z9, null, t) : t : r === "blank" ? null : g.createElement(D9, null, g.createElement(R9, {
        ...n
    }), r !== "loading" && g.createElement(L9, null, r === "error" ? g.createElement(j9, {
        ...n
    }) : g.createElement(A9, {
        ...n
    })))
}
  , V9 = e => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`
  , B9 = e => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`
  , W9 = "0%{opacity:0;} 100%{opacity:1;}"
  , q9 = "0%{opacity:1;} 100%{opacity:0;}"
  , H9 = Ei("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`
  , Z9 = Ei("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`
  , K9 = (e, t) => {
    let r = e.includes("top") ? 1 : -1
      , [n,s] = tE() ? [W9, q9] : [V9(r), B9(r)];
    return {
        animation: t ? `${ms(n)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${ms(s)} 0.4s forwards cubic-bezier(.06,.71,.55,1)`
    }
}
  , Q9 = g.memo( ({toast: e, position: t, style: r, children: n}) => {
    let s = e.height ? K9(e.position || t || "top-center", e.visible) : {
        opacity: 0
    }
      , i = g.createElement(U9, {
        toast: e
    })
      , a = g.createElement(Z9, {
        ...e.ariaProps
    }, wf(e.message, e));
    return g.createElement(H9, {
        className: e.className,
        style: {
            ...s,
            ...r,
            ...e.style
        }
    }, typeof n == "function" ? n({
        icon: i,
        message: a
    }) : g.createElement(g.Fragment, null, i, a))
}
);
y9(g.createElement);
var G9 = ({id: e, className: t, style: r, onHeightUpdate: n, children: s}) => {
    let i = g.useCallback(a => {
        if (a) {
            let o = () => {
                let l = a.getBoundingClientRect().height;
                n(e, l)
            }
            ;
            o(),
            new MutationObserver(o).observe(a, {
                subtree: !0,
                childList: !0,
                characterData: !0
            })
        }
    }
    , [e, n]);
    return g.createElement("div", {
        ref: i,
        className: t,
        style: r
    }, s)
}
  , Y9 = (e, t) => {
    let r = e.includes("top")
      , n = r ? {
        top: 0
    } : {
        bottom: 0
    }
      , s = e.includes("center") ? {
        justifyContent: "center"
    } : e.includes("right") ? {
        justifyContent: "flex-end"
    } : {};
    return {
        left: 0,
        right: 0,
        display: "flex",
        position: "absolute",
        transition: tE() ? void 0 : "all 230ms cubic-bezier(.21,1.02,.73,1)",
        transform: `translateY(${t * (r ? 1 : -1)}px)`,
        ...n,
        ...s
    }
}
  , J9 = fh`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`
  , Zc = 16
  , X9 = ({reverseOrder: e, position: t="top-center", toastOptions: r, gutter: n, children: s, containerStyle: i, containerClassName: a}) => {
    let {toasts: o, handlers: l} = C9(r);
    return g.createElement("div", {
        id: "_rht_toaster",
        style: {
            position: "fixed",
            zIndex: 9999,
            top: Zc,
            left: Zc,
            right: Zc,
            bottom: Zc,
            pointerEvents: "none",
            ...i
        },
        className: a,
        onMouseEnter: l.startPause,
        onMouseLeave: l.endPause
    }, o.map(c => {
        let f = c.position || t
          , h = l.calculateOffset(c, {
            reverseOrder: e,
            gutter: n,
            defaultPosition: t
        })
          , m = Y9(f, h);
        return g.createElement(G9, {
            id: c.id,
            key: c.id,
            onHeightUpdate: l.updateHeight,
            className: c.visible ? J9 : "",
            style: m
        }, c.type === "custom" ? wf(c.message, c) : s ? s(c) : g.createElement(Q9, {
            toast: c,
            position: f
        }))
    }
    ))
}
  , ke = fr;
/**
 * @license lucide-react v0.468.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const e8 = e => e.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase()
  , nE = (...e) => e.filter( (t, r, n) => !!t && t.trim() !== "" && n.indexOf(t) === r).join(" ").trim();
/**
 * @license lucide-react v0.468.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
var t8 = {
    xmlns: "http://www.w3.org/2000/svg",
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: 2,
    strokeLinecap: "round",
    strokeLinejoin: "round"
};
/**
 * @license lucide-react v0.468.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const r8 = g.forwardRef( ({color: e="currentColor", size: t=24, strokeWidth: r=2, absoluteStrokeWidth: n, className: s="", children: i, iconNode: a, ...o}, l) => g.createElement("svg", {
    ref: l,
    ...t8,
    width: t,
    height: t,
    stroke: e,
    strokeWidth: n ? Number(r) * 24 / Number(t) : r,
    className: nE("lucide", s),
    ...o
}, [...a.map( ([c,f]) => g.createElement(c, f)), ...Array.isArray(i) ? i : [i]]));
/**
 * @license lucide-react v0.468.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Tt = (e, t) => {
    const r = g.forwardRef( ({className: n, ...s}, i) => g.createElement(r8, {
        ref: i,
        iconNode: t,
        className: nE(`lucide-${e8(e)}`, n),
        ...s
    }));
    return r.displayName = `${e}`,
    r
}
;
/**
 * @license lucide-react v0.468.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const n8 = Tt("AlarmClock", [["circle", {
    cx: "12",
    cy: "13",
    r: "8",
    key: "3y4lt7"
}], ["path", {
    d: "M12 9v4l2 2",
    key: "1c63tq"
}], ["path", {
    d: "M5 3 2 6",
    key: "18tl5t"
}], ["path", {
    d: "m22 6-3-3",
    key: "1opdir"
}], ["path", {
    d: "M6.38 18.7 4 21",
    key: "17xu3x"
}], ["path", {
    d: "M17.64 18.67 20 21",
    key: "kv2oe2"
}]]);
/**
 * @license lucide-react v0.468.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const nv = Tt("ArrowLeft", [["path", {
    d: "m12 19-7-7 7-7",
    key: "1l729n"
}], ["path", {
    d: "M19 12H5",
    key: "x3x0zl"
}]]);
/**
 * @license lucide-react v0.468.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const sy = Tt("BadgeAlert", [["path", {
    d: "M3.85 8.62a4 4 0 0 1 4.78-4.77 4 4 0 0 1 6.74 0 4 4 0 0 1 4.78 4.78 4 4 0 0 1 0 6.74 4 4 0 0 1-4.77 4.78 4 4 0 0 1-6.75 0 4 4 0 0 1-4.78-4.77 4 4 0 0 1 0-6.76Z",
    key: "3c2336"
}], ["line", {
    x1: "12",
    x2: "12",
    y1: "8",
    y2: "12",
    key: "1pkeuh"
}], ["line", {
    x1: "12",
    x2: "12.01",
    y1: "16",
    y2: "16",
    key: "4dfq90"
}]]);
/**
 * @license lucide-react v0.468.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const iy = Tt("BadgeCheck", [["path", {
    d: "M3.85 8.62a4 4 0 0 1 4.78-4.77 4 4 0 0 1 6.74 0 4 4 0 0 1 4.78 4.78 4 4 0 0 1 0 6.74 4 4 0 0 1-4.77 4.78 4 4 0 0 1-6.75 0 4 4 0 0 1-4.78-4.77 4 4 0 0 1 0-6.76Z",
    key: "3c2336"
}], ["path", {
    d: "m9 12 2 2 4-4",
    key: "dzmm74"
}]]);
/**
 * @license lucide-react v0.468.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const ay = Tt("BadgeX", [["path", {
    d: "M3.85 8.62a4 4 0 0 1 4.78-4.77 4 4 0 0 1 6.74 0 4 4 0 0 1 4.78 4.78 4 4 0 0 1 0 6.74 4 4 0 0 1-4.77 4.78 4 4 0 0 1-6.75 0 4 4 0 0 1-4.78-4.77 4 4 0 0 1 0-6.76Z",
    key: "3c2336"
}], ["line", {
    x1: "15",
    x2: "9",
    y1: "9",
    y2: "15",
    key: "f7djnv"
}], ["line", {
    x1: "9",
    x2: "15",
    y1: "9",
    y2: "15",
    key: "1shsy8"
}]]);
/**
 * @license lucide-react v0.468.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const s8 = Tt("CircleSlash2", [["circle", {
    cx: "12",
    cy: "12",
    r: "10",
    key: "1mglay"
}], ["path", {
    d: "M22 2 2 22",
    key: "y4kqgn"
}]]);
/**
 * @license lucide-react v0.468.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const i8 = Tt("CircleUserRound", [["path", {
    d: "M18 20a6 6 0 0 0-12 0",
    key: "1qehca"
}], ["circle", {
    cx: "12",
    cy: "10",
    r: "4",
    key: "1h16sb"
}], ["circle", {
    cx: "12",
    cy: "12",
    r: "10",
    key: "1mglay"
}]]);
/**
 * @license lucide-react v0.468.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const a8 = Tt("ExternalLink", [["path", {
    d: "M15 3h6v6",
    key: "1q9fwt"
}], ["path", {
    d: "M10 14 21 3",
    key: "gplh6r"
}], ["path", {
    d: "M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6",
    key: "a6xqqp"
}]]);
/**
 * @license lucide-react v0.468.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const o8 = Tt("Hourglass", [["path", {
    d: "M5 22h14",
    key: "ehvnwv"
}], ["path", {
    d: "M5 2h14",
    key: "pdyrp9"
}], ["path", {
    d: "M17 22v-4.172a2 2 0 0 0-.586-1.414L12 12l-4.414 4.414A2 2 0 0 0 7 17.828V22",
    key: "1d314k"
}], ["path", {
    d: "M7 2v4.172a2 2 0 0 0 .586 1.414L12 12l4.414-4.414A2 2 0 0 0 17 6.172V2",
    key: "1vvvr6"
}]]);
/**
 * @license lucide-react v0.468.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const l8 = Tt("MessageCircleWarning", [["path", {
    d: "M7.9 20A9 9 0 1 0 4 16.1L2 22Z",
    key: "vv11sd"
}], ["path", {
    d: "M12 8v4",
    key: "1got3b"
}], ["path", {
    d: "M12 16h.01",
    key: "1drbdi"
}]]);
/**
 * @license lucide-react v0.468.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const u8 = Tt("PackageSearch", [["path", {
    d: "M21 10V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l2-1.14",
    key: "e7tb2h"
}], ["path", {
    d: "m7.5 4.27 9 5.15",
    key: "1c824w"
}], ["polyline", {
    points: "3.29 7 12 12 20.71 7",
    key: "ousv84"
}], ["line", {
    x1: "12",
    x2: "12",
    y1: "22",
    y2: "12",
    key: "a4e8g8"
}], ["circle", {
    cx: "18.5",
    cy: "15.5",
    r: "2.5",
    key: "b5zd12"
}], ["path", {
    d: "M20.27 17.27 22 19",
    key: "1l4muz"
}]]);
/**
 * @license lucide-react v0.468.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const c8 = Tt("RefreshCwOff", [["path", {
    d: "M21 8L18.74 5.74A9.75 9.75 0 0 0 12 3C11 3 10.03 3.16 9.13 3.47",
    key: "1krf6h"
}], ["path", {
    d: "M8 16H3v5",
    key: "1cv678"
}], ["path", {
    d: "M3 12C3 9.51 4 7.26 5.64 5.64",
    key: "ruvoct"
}], ["path", {
    d: "m3 16 2.26 2.26A9.75 9.75 0 0 0 12 21c2.49 0 4.74-1 6.36-2.64",
    key: "19q130"
}], ["path", {
    d: "M21 12c0 1-.16 1.97-.47 2.87",
    key: "4w8emr"
}], ["path", {
    d: "M21 3v5h-5",
    key: "1q7to0"
}], ["path", {
    d: "M22 22 2 2",
    key: "1r8tn9"
}]]);
/**
 * @license lucide-react v0.468.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const sE = Tt("RefreshCw", [["path", {
    d: "M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8",
    key: "v9h5vc"
}], ["path", {
    d: "M21 3v5h-5",
    key: "1q7to0"
}], ["path", {
    d: "M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16",
    key: "3uifl3"
}], ["path", {
    d: "M8 16H3v5",
    key: "1cv678"
}]]);
/**
 * @license lucide-react v0.468.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const iE = Tt("SearchCheck", [["path", {
    d: "m8 11 2 2 4-4",
    key: "1sed1v"
}], ["circle", {
    cx: "11",
    cy: "11",
    r: "8",
    key: "4ej97u"
}], ["path", {
    d: "m21 21-4.3-4.3",
    key: "1qie3q"
}]]);
/**
 * @license lucide-react v0.468.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const hh = Tt("ShieldAlert", [["path", {
    d: "M20 13c0 5-3.5 7.5-7.66 8.95a1 1 0 0 1-.67-.01C7.5 20.5 4 18 4 13V6a1 1 0 0 1 1-1c2 0 4.5-1.2 6.24-2.72a1.17 1.17 0 0 1 1.52 0C14.51 3.81 17 5 19 5a1 1 0 0 1 1 1z",
    key: "oel41y"
}], ["path", {
    d: "M12 8v4",
    key: "1got3b"
}], ["path", {
    d: "M12 16h.01",
    key: "1drbdi"
}]]);
/**
 * @license lucide-react v0.468.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const d8 = Tt("Tag", [["path", {
    d: "M12.586 2.586A2 2 0 0 0 11.172 2H4a2 2 0 0 0-2 2v7.172a2 2 0 0 0 .586 1.414l8.704 8.704a2.426 2.426 0 0 0 3.42 0l6.58-6.58a2.426 2.426 0 0 0 0-3.42z",
    key: "vktsd0"
}], ["circle", {
    cx: "7.5",
    cy: "7.5",
    r: ".5",
    fill: "currentColor",
    key: "kqv944"
}]]);
/**
 * @license lucide-react v0.468.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const sv = Tt("Trash2", [["path", {
    d: "M3 6h18",
    key: "d0wm0j"
}], ["path", {
    d: "M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6",
    key: "4alrt4"
}], ["path", {
    d: "M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2",
    key: "v07s0e"
}], ["line", {
    x1: "10",
    x2: "10",
    y1: "11",
    y2: "17",
    key: "1uufr5"
}], ["line", {
    x1: "14",
    x2: "14",
    y1: "11",
    y2: "17",
    key: "xtxkd"
}]]);
/**
 * @license lucide-react v0.468.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const f8 = Tt("UserMinus", [["path", {
    d: "M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2",
    key: "1yyitq"
}], ["circle", {
    cx: "9",
    cy: "7",
    r: "4",
    key: "nufk8"
}], ["line", {
    x1: "22",
    x2: "16",
    y1: "11",
    y2: "11",
    key: "1shjgl"
}]]);
/**
 * @license lucide-react v0.468.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const h8 = Tt("UserRoundCheck", [["path", {
    d: "M2 21a8 8 0 0 1 13.292-6",
    key: "bjp14o"
}], ["circle", {
    cx: "10",
    cy: "8",
    r: "5",
    key: "o932ke"
}], ["path", {
    d: "m16 19 2 2 4-4",
    key: "1b14m6"
}]]);
/**
 * @license lucide-react v0.468.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const m8 = Tt("UserRoundPlus", [["path", {
    d: "M2 21a8 8 0 0 1 13.292-6",
    key: "bjp14o"
}], ["circle", {
    cx: "10",
    cy: "8",
    r: "5",
    key: "o932ke"
}], ["path", {
    d: "M19 16v6",
    key: "tddt3s"
}], ["path", {
    d: "M22 19h-6",
    key: "vcuq98"
}]]);
/**
 * @license lucide-react v0.468.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const p8 = Tt("User", [["path", {
    d: "M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2",
    key: "975kel"
}], ["circle", {
    cx: "12",
    cy: "7",
    r: "4",
    key: "17ys0d"
}]]);
ya({
    incomingMessages: []
});
function y8() {
    const [e,t] = g.useState(!1);
    return null
}
function ar(e) {
    let t = "w-8 h-8";
    return e.size === "sm" && (t = "w-4 h-4"),
    e.size === "lg" && (t = "w-10 h-10"),
    e.size === "xl" && (t = "w-14 h-14"),
    d.jsxs("span", {
        children: [d.jsxs("svg", {
            "aria-hidden": "true",
            className: fe("text-gray-200 animate-spin fill-indigo-600", t, e.className),
            viewBox: "0 0 100 101",
            fill: "none",
            xmlns: "http://www.w3.org/2000/svg",
            children: [d.jsx("path", {
                d: "M100 50.5908C100 78.2051 77.6142 100.591 50 100.591C22.3858 100.591 0 78.2051 0 50.5908C0 22.9766 22.3858 0.59082 50 0.59082C77.6142 0.59082 100 22.9766 100 50.5908ZM9.08144 50.5908C9.08144 73.1895 27.4013 91.5094 50 91.5094C72.5987 91.5094 90.9186 73.1895 90.9186 50.5908C90.9186 27.9921 72.5987 9.67226 50 9.67226C27.4013 9.67226 9.08144 27.9921 9.08144 50.5908Z",
                fill: "currentColor"
            }), d.jsx("path", {
                d: "M93.9676 39.0409C96.393 38.4038 97.8624 35.9116 97.0079 33.5539C95.2932 28.8227 92.871 24.3692 89.8167 20.348C85.8452 15.1192 80.8826 10.7238 75.2124 7.41289C69.5422 4.10194 63.2754 1.94025 56.7698 1.05124C51.7666 0.367541 46.6976 0.446843 41.7345 1.27873C39.2613 1.69328 37.813 4.19778 38.4501 6.62326C39.0873 9.04874 41.5694 10.4717 44.0505 10.1071C47.8511 9.54855 51.7191 9.52689 55.5402 10.0491C60.8642 10.7766 65.9928 12.5457 70.6331 15.2552C75.2735 17.9648 79.3347 21.5619 82.5849 25.841C84.9175 28.9121 86.7997 32.2913 88.1811 35.8758C89.083 38.2158 91.5421 39.6781 93.9676 39.0409Z",
                fill: "currentFill"
            })]
        }), d.jsx("span", {
            className: "sr-only",
            children: "Loading..."
        })]
    })
}
const aE = g.createContext(null)
  , g8 = aE.Provider;
function v8() {
    return g.useContext(aE)
}
function b8() {
    const e = Je();
    jt();
    const t = v8();
    return g.useEffect( () => {
        let r = () => {}
        ;
        if (e.status === "UNAUTHORIZED" && (t == null || t.disconnect()),
        e.status === "AUTHORIZED" && t) {
            const {connect: n, registerHandler: s} = t;
            n().catch(i => console.error(`Error connecting to subscription server: ${i}`)).then( () => {
                s(i => {
                    switch (i.type) {
                    case "error":
                        console.log("Uh oh. An error occurred: ", i.error);
                        break;
                    case "product_purchased":
                        ke.success(`${i.attrs.productName} has been purchased for ${i.attrs.productPrice} blobium`);
                        break;
                    case "user_balance_changed":
                        Se.balance = i.attrs.balance,
                        Ve.emit("sync:store", {
                            balance: i.attrs.balance
                        });
                        break
                    }
                }
                ).then(i => {
                    r = i
                }
                )
            }
            )
        }
        return () => {
            r()
        }
    }
    , [e.status, t]),
    null
}
const ai = (e, t, r) => {
    const n = document.createElement(e)
      , [s,i] = Array.isArray(t) ? [void 0, t] : [t, r];
    return s && Object.assign(n, s),
    i == null || i.forEach(a => n.appendChild(a)),
    n
}
  , x8 = (e, t) => {
    var r;
    return t === "left" ? e.offsetLeft : (((r = e.offsetParent instanceof HTMLElement ? e.offsetParent : null) == null ? void 0 : r.offsetWidth) ?? 0) - e.offsetWidth - e.offsetLeft
}
  , w8 = e => e.offsetWidth > 0 && e.offsetHeight > 0
  , S8 = (e, t) => {
    customElements.get(e) !== t && customElements.define(e, t)
}
;
function k8(e, t, {reverse: r=!1}={}) {
    const n = e.length;
    for (let s = r ? n - 1 : 0; r ? s >= 0 : s < n; r ? s-- : s++)
        t(e[s], s)
}
function E8(e, t, r, n) {
    const s = t.formatToParts(e);
    r && s.unshift({
        type: "prefix",
        value: r
    }),
    n && s.push({
        type: "suffix",
        value: n
    });
    const i = []
      , a = []
      , o = []
      , l = []
      , c = {}
      , f = x => `${x}:${c[x] = (c[x] ?? -1) + 1}`;
    let h = ""
      , m = !1
      , y = !1;
    for (const x of s) {
        h += x.value;
        const w = x.type === "minusSign" || x.type === "plusSign" ? "sign" : x.type;
        w === "integer" ? (m = !0,
        a.push(...x.value.split("").map(v => ({
            type: w,
            value: parseInt(v)
        })))) : w === "group" ? a.push({
            type: w,
            value: x.value
        }) : w === "decimal" ? (y = !0,
        o.push({
            type: w,
            value: x.value,
            key: f(w)
        })) : w === "fraction" ? o.push(...x.value.split("").map(v => ({
            type: w,
            value: parseInt(v),
            key: f(w),
            pos: -1 - c[w]
        }))) : (m || y ? l : i).push({
            type: w,
            value: x.value,
            key: f(w)
        })
    }
    const k = [];
    for (let x = a.length - 1; x >= 0; x--) {
        const w = a[x];
        k.unshift(w.type === "integer" ? {
            ...w,
            key: f(w.type),
            pos: c[w.type]
        } : {
            ...w,
            key: f(w.type)
        })
    }
    return {
        pre: i,
        integer: k,
        fraction: o,
        post: l,
        valueAsString: h,
        value: typeof e == "string" ? parseFloat(e) : e
    }
}
const _8 = String.raw
  , T8 = typeof CSS < "u" && CSS.supports && CSS.supports("animation-timing-function", "linear(1,2)")
  , C8 = typeof CSS < "u" && CSS.supports && CSS.supports("line-height", "mod(1,1)")
  , xx = typeof matchMedia < "u" ? matchMedia("(prefers-reduced-motion: reduce)") : null
  , Sf = "--_number-flow-d-opacity"
  , iv = "--_number-flow-d-width"
  , kf = "--_number-flow-dx"
  , av = "--_number-flow-d"
  , P8 = ( () => {
    try {
        return CSS.registerProperty({
            name: Sf,
            syntax: "<number>",
            inherits: !1,
            initialValue: "0"
        }),
        CSS.registerProperty({
            name: kf,
            syntax: "<length>",
            inherits: !0,
            initialValue: "0px"
        }),
        CSS.registerProperty({
            name: iv,
            syntax: "<number>",
            inherits: !1,
            initialValue: "0"
        }),
        CSS.registerProperty({
            name: av,
            syntax: "<number>",
            inherits: !0,
            initialValue: "0"
        }),
        !0
    } catch {
        return !1
    }
}
)()
  , $8 = "var(--number-flow-char-height, 1em)"
  , Ns = "var(--number-flow-mask-height, 0.25em)"
  , wx = `calc(${Ns} / 2)`
  , oy = "var(--number-flow-mask-width, 0.5em)"
  , Pi = `calc(${oy} / var(--scale-x))`
  , Kc = "#000 0, transparent 71%"
  , Sx = _8`:host{display:inline-block;direction:ltr;white-space:nowrap;isolation:isolate;line-height:${$8} !important}.number,.number__inner{display:inline-block;transform-origin:left top}:host([data-will-change]) :is(.number,.number__inner,.section,.digit,.digit__num,.symbol){will-change:transform}.number{--scale-x:calc(1 + var(${iv}) / var(--width));transform:translateX(var(${kf})) scaleX(var(--scale-x));margin:0 calc(-1 * ${oy});position:relative;-webkit-mask-image:linear-gradient(to right,transparent 0,#000 ${Pi},#000 calc(100% - ${Pi}),transparent ),linear-gradient(to bottom,transparent 0,#000 ${Ns},#000 calc(100% - ${Ns}),transparent 100% ),radial-gradient(at bottom right,${Kc}),radial-gradient(at bottom left,${Kc}),radial-gradient(at top left,${Kc}),radial-gradient(at top right,${Kc});-webkit-mask-size:100% calc(100% - ${Ns} * 2),calc(100% - ${Pi} * 2) 100%,${Pi} ${Ns},${Pi} ${Ns},${Pi} ${Ns},${Pi} ${Ns};-webkit-mask-position:center,center,top left,top right,bottom right,bottom left;-webkit-mask-repeat:no-repeat}.number__inner{padding:${wx} ${oy};transform:scaleX(calc(1 / var(--scale-x))) translateX(calc(-1 * var(${kf})))}:host > :not(.number){z-index:5}.section,.symbol{display:inline-block;position:relative;isolation:isolate}.section::after{content:'\200b';display:inline-block}.section--justify-left{transform-origin:center left}.section--justify-right{transform-origin:center right}.section__exiting,.symbol__exiting{margin:0 !important;position:absolute !important;z-index:-1}.digit{display:inline-block;position:relative;--c:var(--current) + var(${av})}.digit__num,.number .section::after{padding:${wx} 0}.digit__num{display:inline-block;--offset-raw:mod(var(--length) + var(--n) - mod(var(--c),var(--length)),var(--length));--offset:calc( var(--offset-raw) - var(--length) * round(down,var(--offset-raw) / (var(--length) / 2),1) );--y:clamp(-100%,var(--offset) * 100%,100%);transform:translateY(var(--y))}.digit__num:not(.is-current){position:absolute;top:0;left:50%;transform:translateX(-50%) translateY(var(--y))}.digit:not(.is-spinning) .digit__num:not(.is-current){display:none}.symbol__value{display:inline-block;mix-blend-mode:plus-lighter;white-space:pre}.section--justify-left .symbol__exiting{left:0}.section--justify-right .symbol__exiting{right:0}.animate-presence{opacity:calc(1 + var(${Sf}))}`
  , N8 = HTMLElement
  , j8 = (e, t) => e == null ? t : t == null ? e : Math.max(e, t)
  , I8 = C8 && T8 && P8;
let Qc;
class oE extends N8 {
    constructor() {
        super(),
        this.created = !1,
        this.manual = !1;
        const {animated: t, ...r} = this.constructor.defaultProps;
        this._animated = this.computedAnimated = t,
        Object.assign(this, r)
    }
    get animated() {
        return this._animated
    }
    set animated(t) {
        var r;
        this.animated !== t && (this._animated = t,
        (r = this.shadowRoot) == null || r.getAnimations().forEach(n => n.finish()))
    }
    set data(t) {
        if (t == null)
            return;
        const {pre: r, integer: n, fraction: s, post: i, value: a} = t;
        if (this.created) {
            const o = this._data;
            if (this._data = t,
            this.computedTrend = typeof this.trend == "function" ? this.trend(o.value, a) : this.trend,
            this.startingPos = void 0,
            this.computedTrend && this.continuous) {
                const l = o.integer.concat(o.fraction).filter(m => m.type === "integer" || m.type === "fraction")
                  , c = t.integer.concat(t.fraction).filter(m => m.type === "integer" || m.type === "fraction")
                  , f = l.find(m => !c.find(y => y.pos === m.pos && y.value === m.value))
                  , h = c.find(m => !l.find(y => m.pos === y.pos && m.value === y.value));
                this.startingPos = j8(f == null ? void 0 : f.pos, h == null ? void 0 : h.pos)
            }
            this.computedAnimated = I8 && this._animated && (!this.respectMotionPreference || !(xx != null && xx.matches)) && w8(this),
            this.manual || this.willUpdate(),
            this._pre.update(r),
            this._num.update({
                integer: n,
                fraction: s
            }),
            this._post.update(i),
            this.manual || this.didUpdate()
        } else {
            if (this._data = t,
            this.attachShadow({
                mode: "open"
            }),
            typeof CSSStyleSheet < "u" && this.shadowRoot.adoptedStyleSheets)
                Qc || (Qc = new CSSStyleSheet,
                Qc.replaceSync(Sx)),
                this.shadowRoot.adoptedStyleSheets = [Qc];
            else {
                const o = document.createElement("style");
                o.textContent = Sx,
                this.shadowRoot.appendChild(o)
            }
            this._pre = new Ex(this,r,{
                justify: "right",
                part: "left"
            }),
            this.shadowRoot.appendChild(this._pre.el),
            this._num = new R8(this,n,s),
            this.shadowRoot.appendChild(this._num.el),
            this._post = new Ex(this,i,{
                justify: "left",
                part: "right"
            }),
            this.shadowRoot.appendChild(this._post.el)
        }
        this.created = !0
    }
    willUpdate() {
        this._pre.willUpdate(),
        this._num.willUpdate(),
        this._post.willUpdate()
    }
    didUpdate() {
        if (!this.computedAnimated)
            return;
        this._abortAnimationsFinish ? this._abortAnimationsFinish.abort() : this.dispatchEvent(new Event("animationsstart")),
        this._pre.didUpdate(),
        this._num.didUpdate(),
        this._post.didUpdate();
        const t = new AbortController;
        Promise.all(this.shadowRoot.getAnimations().map(r => r.finished)).then( () => {
            t.signal.aborted || (this.dispatchEvent(new Event("animationsfinish")),
            this._abortAnimationsFinish = void 0)
        }
        ),
        this._abortAnimationsFinish = t
    }
}
oE.defaultProps = {
    transformTiming: {
        duration: 900,
        easing: "linear(0,.005,.019,.039,.066,.096,.129,.165,.202,.24,.278,.316,.354,.39,.426,.461,.494,.526,.557,.586,.614,.64,.665,.689,.711,.731,.751,.769,.786,.802,.817,.831,.844,.856,.867,.877,.887,.896,.904,.912,.919,.925,.931,.937,.942,.947,.951,.955,.959,.962,.965,.968,.971,.973,.976,.978,.98,.981,.983,.984,.986,.987,.988,.989,.99,.991,.992,.992,.993,.994,.994,.995,.995,.996,.996,.9963,.9967,.9969,.9972,.9975,.9977,.9979,.9981,.9982,.9984,.9985,.9987,.9988,.9989,1)"
    },
    spinTiming: void 0,
    opacityTiming: {
        duration: 450,
        easing: "ease-out"
    },
    animated: !0,
    trend: (e, t) => Math.sign(t - e),
    continuous: !1,
    respectMotionPreference: !0,
    digits: void 0
};
class R8 {
    constructor(t, r, n, {className: s, ...i}={}) {
        this.flow = t,
        this._integer = new kx(t,r,{
            justify: "right",
            part: "integer"
        }),
        this._fraction = new kx(t,n,{
            justify: "left",
            part: "fraction"
        }),
        this._inner = ai("span", {
            className: "number__inner"
        }, [this._integer.el, this._fraction.el]),
        this.el = ai("span", {
            ...i,
            part: "number",
            className: `number ${s ?? ""}`
        }, [this._inner])
    }
    willUpdate() {
        this._prevWidth = this.el.offsetWidth,
        this._prevLeft = this.el.getBoundingClientRect().left,
        this._integer.willUpdate(),
        this._fraction.willUpdate()
    }
    update({integer: t, fraction: r}) {
        this._integer.update(t),
        this._fraction.update(r)
    }
    didUpdate() {
        const t = this.el.getBoundingClientRect();
        this._integer.didUpdate(),
        this._fraction.didUpdate();
        const r = this._prevLeft - t.left
          , n = this.el.offsetWidth
          , s = this._prevWidth - n;
        this.el.style.setProperty("--width", String(n)),
        this.el.animate({
            [kf]: [`${r}px`, "0px"],
            [iv]: [s, 0]
        }, {
            ...this.flow.transformTiming,
            composite: "accumulate"
        })
    }
}
class lE {
    constructor(t, r, {justify: n, className: s, ...i}, a) {
        this.flow = t,
        this.children = new Map,
        this.onCharRemove = l => () => {
            this.children.delete(l)
        }
        ,
        this.justify = n;
        const o = r.map(l => this.addChar(l).el);
        this.el = ai("span", {
            ...i,
            className: `section section--justify-${n} ${s ?? ""}`
        }, a ? a(o) : o)
    }
    addChar(t, {startDigitsAtZero: r=!1, ...n}={}) {
        const s = t.type === "integer" || t.type === "fraction" ? new cE(this,t.type,r ? 0 : t.value,t.pos,{
            ...n,
            onRemove: this.onCharRemove(t.key)
        }) : new O8(this,t.type,t.value,{
            ...n,
            onRemove: this.onCharRemove(t.key)
        });
        return this.children.set(t.key, s),
        s
    }
    unpop(t) {
        t.el.classList.remove("section__exiting"),
        t.el.style.top = "",
        t.el.style[this.justify] = ""
    }
    pop(t) {
        t.forEach(r => {
            r.el.style.top = `${r.el.offsetTop}px`,
            r.el.style[this.justify] = `${x8(r.el, this.justify)}px`
        }
        ),
        t.forEach(r => {
            r.el.classList.add("section__exiting"),
            r.present = !1
        }
        )
    }
    addNewAndUpdateExisting(t) {
        const r = new Map
          , n = new Map
          , s = this.justify === "left"
          , i = s ? "prepend" : "append";
        if (k8(t, a => {
            let o;
            this.children.has(a.key) ? (o = this.children.get(a.key),
            n.set(a, o),
            this.unpop(o),
            o.present = !0) : (o = this.addChar(a, {
                startDigitsAtZero: !0,
                animateIn: !0
            }),
            r.set(a, o)),
            this.el[i](o.el)
        }
        , {
            reverse: s
        }),
        this.flow.computedAnimated) {
            const a = this.el.getBoundingClientRect();
            r.forEach(o => {
                o.willUpdate(a)
            }
            )
        }
        r.forEach( (a, o) => {
            a.update(o.value)
        }
        ),
        n.forEach( (a, o) => {
            a.update(o.value)
        }
        )
    }
    willUpdate() {
        const t = this.el.getBoundingClientRect();
        this._prevOffset = t[this.justify],
        this.children.forEach(r => r.willUpdate(t))
    }
    didUpdate() {
        const t = this.el.getBoundingClientRect();
        this.children.forEach(s => s.didUpdate(t));
        const r = t[this.justify]
          , n = this._prevOffset - r;
        n && this.children.size && this.el.animate({
            transform: [`translateX(${n}px)`, "none"]
        }, {
            ...this.flow.transformTiming,
            composite: "accumulate"
        })
    }
}
class kx extends lE {
    update(t) {
        const r = new Map;
        this.children.forEach( (n, s) => {
            t.find(i => i.key === s) || r.set(s, n),
            this.unpop(n)
        }
        ),
        this.addNewAndUpdateExisting(t),
        r.forEach(n => {
            n instanceof cE && n.update(0)
        }
        ),
        this.pop(r)
    }
}
class Ex extends lE {
    update(t) {
        const r = new Map;
        this.children.forEach( (n, s) => {
            t.find(i => i.key === s) || r.set(s, n)
        }
        ),
        this.pop(r),
        this.addNewAndUpdateExisting(t)
    }
}
class ly {
    constructor(t, r, {onRemove: n, animateIn: s=!1}={}) {
        this.flow = t,
        this.el = r,
        this._present = !0,
        this._remove = () => {
            var i;
            this.el.remove(),
            (i = this._onRemove) == null || i.call(this)
        }
        ,
        this.el.classList.add("animate-presence"),
        this.flow.computedAnimated && s && this.el.animate({
            [Sf]: [-.9999, 0]
        }, {
            ...this.flow.opacityTiming,
            composite: "accumulate"
        }),
        this._onRemove = n
    }
    get present() {
        return this._present
    }
    set present(t) {
        if (this._present !== t) {
            if (this._present = t,
            !this.flow.computedAnimated) {
                t || this._remove();
                return
            }
            this.el.style.setProperty("--_number-flow-d-opacity", t ? "0" : "-.999"),
            this.el.animate({
                [Sf]: t ? [-.9999, 0] : [.999, 0]
            }, {
                ...this.flow.opacityTiming,
                composite: "accumulate"
            }),
            t ? this.flow.removeEventListener("animationsfinish", this._remove) : this.flow.addEventListener("animationsfinish", this._remove, {
                once: !0
            })
        }
    }
}
class uE extends ly {
    constructor(t, r, n, s) {
        super(t.flow, n, s),
        this.section = t,
        this.value = r,
        this.el = n
    }
}
class cE extends uE {
    constructor(t, r, n, s, i) {
        var a, o;
        const l = (((o = (a = t.flow.digits) == null ? void 0 : a[s]) == null ? void 0 : o.max) ?? 9) + 1
          , c = Array.from({
            length: l
        }).map( (h, m) => {
            const y = ai("span", {
                className: `digit__num${m === n ? " is-current" : ""}`
            }, [document.createTextNode(String(m))]);
            return y.style.setProperty("--n", String(m)),
            y
        }
        )
          , f = ai("span", {
            part: `digit ${r}-digit`,
            className: "digit"
        }, c);
        f.style.setProperty("--current", String(n)),
        f.style.setProperty("--length", String(l)),
        super(t, n, f, i),
        this.pos = s,
        this._onAnimationsFinish = () => {
            this.el.classList.remove("is-spinning")
        }
        ,
        this._numbers = c,
        this._length = l
    }
    willUpdate(t) {
        const r = this.el.getBoundingClientRect();
        this._prevValue = this.value;
        const n = r[this.section.justify] - t[this.section.justify]
          , s = r.width / 2;
        this._prevCenter = this.section.justify === "left" ? n + s : n - s
    }
    update(t) {
        var r, n;
        (r = this._numbers[this.value]) == null || r.classList.remove("is-current"),
        this.el.style.setProperty("--current", String(t)),
        (n = this._numbers[t]) == null || n.classList.add("is-current"),
        this.value = t
    }
    didUpdate(t) {
        const r = this.el.getBoundingClientRect()
          , n = r[this.section.justify] - t[this.section.justify]
          , s = r.width / 2
          , i = this.section.justify === "left" ? n + s : n - s
          , a = this._prevCenter - i;
        a && this.el.animate({
            transform: [`translateX(${a}px)`, "none"]
        }, {
            ...this.flow.transformTiming,
            composite: "accumulate"
        });
        const o = this.diff;
        o && (this.el.classList.add("is-spinning"),
        this.el.animate({
            [av]: [-o, 0]
        }, {
            ...this.flow.spinTiming ?? this.flow.transformTiming,
            composite: "accumulate"
        }),
        this.flow.addEventListener("animationsfinish", this._onAnimationsFinish, {
            once: !0
        }))
    }
    get diff() {
        let t = this.flow.computedTrend;
        const r = this.value - this._prevValue;
        return !r && this.flow.startingPos != null && this.flow.startingPos >= this.pos ? this._length * t : (t || (t = Math.sign(r)),
        t < 0 && this.value > this._prevValue ? this.value - this._length - this._prevValue : t > 0 && this.value < this._prevValue ? this._length - this._prevValue + this.value : r)
    }
}
class O8 extends uE {
    constructor(t, r, n, s) {
        const i = ai("span", {
            className: "symbol__value",
            textContent: n
        });
        super(t, n, ai("span", {
            part: `symbol ${r}`,
            className: "symbol"
        }, [i]), s),
        this.type = r,
        this._children = new Map,
        this._onChildRemove = a => () => {
            this._children.delete(a)
        }
        ,
        this._children.set(n, new ly(this.flow,i,{
            onRemove: this._onChildRemove(n)
        }))
    }
    willUpdate(t) {
        if (this.type === "decimal")
            return;
        const r = this.el.getBoundingClientRect();
        this._prevOffset = r[this.section.justify] - t[this.section.justify]
    }
    update(t) {
        if (this.value !== t) {
            const r = this._children.get(this.value);
            if (r.present = !1,
            r.el.classList.add("symbol__exiting"),
            this._children.has(t)) {
                const n = this._children.get(t);
                n.present = !0,
                n.el.classList.remove("symbol__exiting")
            } else {
                const n = ai("span", {
                    className: "symbol__value",
                    textContent: t
                });
                this.el.appendChild(n),
                this._children.set(t, new ly(this.flow,n,{
                    animateIn: !0,
                    onRemove: this._onChildRemove(t)
                }))
            }
        }
        this.value = t
    }
    didUpdate(t) {
        if (this.type === "decimal")
            return;
        const r = this.el.getBoundingClientRect()[this.section.justify] - t[this.section.justify]
          , n = this._prevOffset - r;
        n && this.el.animate({
            transform: [`translateX(${n}px)`, "none"]
        }, {
            ...this.flow.transformTiming,
            composite: "accumulate"
        })
    }
}
var F1, M8 = parseInt((F1 = g.version.match(/^(\d+)\./)) == null ? void 0 : F1[1]), ov = M8 >= 19, A8 = ["data", "digits"], lv = class extends oE {
    attributeChangedCallback(e, t, r) {
        this[e] = JSON.parse(r)
    }
}
;
lv.observedAttributes = ov ? [] : A8;
S8("number-flow-react", lv);
var dm = {}
  , _x = ov ? e => e : JSON.stringify;
function Tx(e) {
    const {transformTiming: t, spinTiming: r, opacityTiming: n, animated: s, respectMotionPreference: i, trend: a, continuous: o, ...l} = e;
    return [{
        transformTiming: t,
        spinTiming: r,
        opacityTiming: n,
        animated: s,
        respectMotionPreference: i,
        trend: a,
        continuous: o
    }, l]
}
var L8 = class extends g.Component {
    constructor(e) {
        super(e),
        this.handleRef = this.handleRef.bind(this)
    }
    updateProperties(e) {
        if (!this.el)
            return;
        this.el.manual = !this.props.isolate;
        const [t] = Tx(this.props);
        Object.entries(t).forEach( ([r,n]) => {
            this.el[r] = n ?? lv.defaultProps[r]
        }
        ),
        e != null && e.onAnimationsStart && this.el.removeEventListener("animationsstart", e.onAnimationsStart),
        this.props.onAnimationsStart && this.el.addEventListener("animationsstart", this.props.onAnimationsStart),
        e != null && e.onAnimationsFinish && this.el.removeEventListener("animationsfinish", e.onAnimationsFinish),
        this.props.onAnimationsFinish && this.el.addEventListener("animationsfinish", this.props.onAnimationsFinish)
    }
    componentDidMount() {
        this.updateProperties(),
        ov && this.el && (this.el.digits = this.props.digits,
        this.el.data = this.props.data)
    }
    getSnapshotBeforeUpdate(e) {
        var t;
        if (this.updateProperties(e),
        e.data !== this.props.data) {
            if (this.props.group)
                return this.props.group.willUpdate(),
                () => {
                    var r;
                    return (r = this.props.group) == null ? void 0 : r.didUpdate()
                }
                ;
            if (!this.props.isolate)
                return (t = this.el) == null || t.willUpdate(),
                () => {
                    var r;
                    return (r = this.el) == null ? void 0 : r.didUpdate()
                }
        }
        return null
    }
    componentDidUpdate(e, t, r) {
        r == null || r()
    }
    handleRef(e) {
        this.props.innerRef && (this.props.innerRef.current = e),
        this.el = e
    }
    render() {
        const [e,{innerRef: t, className: r, data: n, willChange: s, isolate: i, group: a, digits: o, onAnimationsStart: l, onAnimationsFinish: c, ...f}] = Tx(this.props);
        return g.createElement("number-flow-react", {
            ref: this.handleRef,
            "data-will-change": s ? "" : void 0,
            class: r,
            "aria-label": n.valueAsString,
            ...f,
            role: "img",
            dangerouslySetInnerHTML: {
                __html: ""
            },
            suppressHydrationWarning: !0,
            digits: _x(o),
            data: _x(n)
        })
    }
}
  , D8 = g.forwardRef(function({value: t, locales: r, format: n, prefix: s, suffix: i, ...a}, o) {
    g.useImperativeHandle(o, () => l.current, []);
    const l = g.useRef()
      , c = g.useContext(F8);
    c == null || c.useRegister(l);
    const f = g.useMemo( () => r ? JSON.stringify(r) : "", [r])
      , h = g.useMemo( () => n ? JSON.stringify(n) : "", [n])
      , m = g.useMemo( () => {
        var k;
        const y = dm[k = `${f}:${h}`] ?? (dm[k] = new Intl.NumberFormat(r,n));
        return E8(t, y, s, i)
    }
    , [t, f, h, s, i]);
    return g.createElement(L8, {
        ...a,
        group: c,
        data: m,
        innerRef: l
    })
})
  , uv = D8
  , F8 = g.createContext(void 0);
function tl(e) {
    return d.jsx("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 72 73",
        fill: "none",
        ...e,
        children: d.jsx("path", {
            fill: "#FFBB13",
            fillRule: "evenodd",
            d: "M20.049 6.354c-.615 3.75-1.555 6.564-2.964 7.757-1.884 1.595-5.313 2.565-9.572 3.141L20.049 6.354Zm4.692-4.08c.97 4.906 2.234 9.1 3.94 11.837 3.176 5.096 14.795 6.421 28.211 7.95 2.372.27 4.8.548 7.248.853-2.907 0-5.696-.047-8.344-.091-11.576-.195-20.465-.345-24.91 3.67-4.664 4.212-3.95 15.826-2.806 34.42.123 2.003.251 4.087.378 6.252L47.558 73l19.576-12.666 4.606-24.181-16.121-29.94L26.832.457 24.74 2.274Zm3.24 64.745c-.929-5.722-1.44-10.323-1.876-14.264-1.087-9.796-1.721-15.514-7.2-24.23-2.342-3.728-8.551-5.944-15.88-7.372L.343 23.486 6.1 60.334l21.88 6.685Z",
            clipRule: "evenodd"
        })
    })
}
function z8() {
    const e = Je();
    return d.jsxs("nav", {
        className: "flex items-center justify-between px-2 pt-2 bg-white font-bold uppercase text-3xl border-b border-gray-100",
        children: [d.jsxs("ul", {
            className: "flex tracking-tight gap-2 flex-1 mr-10",
            children: [d.jsx("li", {
                children: d.jsx(On, {
                    to: "/inventory",
                    className: ({isActive: t}) => fe("flex px-6 py-4 text-rose-900", t ? "bg-rose-200 shadow-sm" : "opacity-40 hover:opacity-75"),
                    children: "Inventory"
                })
            }), d.jsx("li", {
                children: d.jsx(On, {
                    to: "/store",
                    className: ({isActive: t}) => fe("flex px-6 py-4 text-indigo-900", t ? "bg-indigo-200 shadow-sm" : "opacity-40 hover:opacity-75"),
                    children: "Store"
                })
            }), d.jsx("li", {
                children: d.jsx(On, {
                    to: "/friends",
                    className: ({isActive: t}) => fe("flex px-6 py-4 text-emerald-900", t ? "bg-emerald-200 shadow-sm" : "opacity-40 hover:opacity-75"),
                    children: "Friends"
                })
            }), d.jsx("li", {
                children: d.jsx(On, {
                    to: "/people",
                    className: ({isActive: t}) => fe("flex px-6 py-4 text-blu-900", t ? "bg-blu-200 shadow-sm" : "opacity-40 hover:opacity-75"),
                    children: "People"
                })
            })]
        }), d.jsxs("div", {
            className: "ml-auto flex items-center mr-8 gap-2 -mt-1",
            children: [d.jsxs("div", {
                className: "flex items-center gap-3 text-3xl",
                children: [d.jsx(tl, {
                    className: "w-8"
                }), d.jsx("div", {
                    className: "flex items-center justify-center min-w-10 h-10",
                    children: e.status === "PENDING" ? d.jsx(ar, {
                        size: "sm"
                    }) : d.jsx(uv, {
                        value: e.balance,
                        continuous: !0
                    })
                })]
            }), d.jsx(On, {
                to: "/profile",
                className: ({isActive: t}) => fe("flex items-center gap-2 px-4 py-4 text-gray-900 ml-4 -mr-4", t ? "bg-gray-200 shadow-sm" : "opacity-40 hover:opacity-75"),
                children: d.jsx(i8, {
                    className: "w-6 h-6 stroke-[2.5px]"
                })
            }), e.isModerator && d.jsx(On, {
                to: `/admin/${e.isModerator ? "users" : "reports"}`,
                className: ({isActive: t}) => fe("flex items-center gap-2 px-2 py-4 text-gray-900 ml-4 -mr-4", t ? "bg-gray-200 shadow-sm" : "opacity-40 hover:opacity-75"),
                children: d.jsx(hh, {
                    className: "w-6 h-6 stroke-[2.5px]"
                })
            })]
        })]
    })
}
function U8() {
    const e = ki()
      , t = Je();
    return g.useEffect( () => {
        t.status === "UNAUTHORIZED" && e("/")
    }
    , [t.status, e]),
    t.status === "PENDING" ? d.jsx("div", {
        className: "flex items-center justify-center h-screen w-screen",
        children: d.jsx(ar, {
            size: "md"
        })
    }) : d.jsxs("div", {
        className: "flex flex-col h-screen w-screen overflow-hidden",
        children: [d.jsx(z8, {}), d.jsx("div", {
            className: "flex flex-col flex-1 shadow-xl shadow-black overflow-hidden",
            children: d.jsx(el, {})
        })]
    })
}
function V8() {
    return ki(),
    Je(),
    d.jsx("header", {
        className: "flex items-center mt-4 mb-10 px-10",
        children: d.jsx("p", {
            children: d.jsx(Kt, {
                to: "/",
                children: d.jsx("img", {
                    src: "/logo.png",
                    width: 600,
                    height: 385,
                    className: "h-20 w-auto",
                    alt: "BlobTown logo"
                })
            })
        })
    })
}
function B8() {
    return d.jsxs(d.Fragment, {
        children: [d.jsx(V8, {}), d.jsx("div", {
            className: "flex flex-col flex-1 px-10",
            children: d.jsx(el, {})
        })]
    })
}
const W8 = "modulepreload"
  , q8 = function(e) {
    return "/" + e
}
  , Cx = {}
  , H8 = function(t, r, n) {
    let s = Promise.resolve();
    if (r && r.length > 0) {
        document.getElementsByTagName("link");
        const a = document.querySelector("meta[property=csp-nonce]")
          , o = (a == null ? void 0 : a.nonce) || (a == null ? void 0 : a.getAttribute("nonce"));
        s = Promise.allSettled(r.map(l => {
            if (l = q8(l),
            l in Cx)
                return;
            Cx[l] = !0;
            const c = l.endsWith(".css")
              , f = c ? '[rel="stylesheet"]' : "";
            if (document.querySelector(`link[href="${l}"]${f}`))
                return;
            const h = document.createElement("link");
            if (h.rel = c ? "stylesheet" : W8,
            c || (h.as = "script"),
            h.crossOrigin = "",
            h.href = l,
            o && h.setAttribute("nonce", o),
            document.head.appendChild(h),
            c)
                return new Promise( (m, y) => {
                    h.addEventListener("load", m),
                    h.addEventListener("error", () => y(new Error(`Unable to preload CSS for ${l}`)))
                }
                )
        }
        ))
    }
    function i(a) {
        const o = new Event("vite:preloadError",{
            cancelable: !0
        });
        if (o.payload = a,
        window.dispatchEvent(o),
        !o.defaultPrevented)
            throw a
    }
    return s.then(a => {
        for (const o of a || [])
            o.status === "rejected" && i(o.reason);
        return t().catch(i)
    }
    )
};
function Z8() {
    const e = ki()
      , t = jt();
    return g.useEffect( () => Ve.listen(async r => {
        switch (r.type) {
        case "command:navigate":
            {
                r.attrs.path.includes("store") && await t.invalidateQueries({
                    queryKey: ["products"]
                }),
                e(r.attrs.path),
                await Zy();
                break
            }
        case "command:invalidate_cache":
            {
                await t.invalidateQueries({
                    queryKey: ["me"]
                }),
                await ge.fetchItems(),
                await ge.fetchLimits();
                break
            }
        case "sync:store":
            {
                r.attrs.balance && (Se.balance = r.attrs.balance);
                break
            }
        case "avatar_edited":
            ge.editingAvatarId = void 0,
            ge.fetchItems();
            break;
        case "avatar_equipped":
            Se.currentAvatarId = r.attrs.avatarId;
            break;
        case "blob_mutex":
            r.attrs.action === "LOCK" ? hr.lockedBlobIds.add(r.attrs.id) : hr.lockedBlobIds.delete(r.attrs.id);
            break;
        case "building_removed":
            ge.placedBuildingId = void 0;
            break;
        case "building_edited":
            ge.editingBuildingId = void 0;
            break;
        case "sync:room_users":
            await v5(r.attrs.userIds);
            break
        }
    }
    ), [e, t]),
    null
}
const K8 = "/assets/main-vr-OxFAT3Wy.css"
  , Q8 = g.lazy( () => H8( () => import("./production-D2UhK7He.js").then(e => e.Y), []).then(e => ({
    default: e.ReactQueryDevtools
})));
function G8() {
    const [e,t] = g.useState(!1)
      , r = g.useRef(!1)
      , [n,s] = g.useState(!1);
    return g.useEffect( () => {
        window.toggleDevtools = () => t(i => !i)
    }
    , []),
    g.useEffect( () => {
        if (Se.device === "headset" && !r.current) {
            r.current = !0;
            const i = document.createElement("link");
            i.href = K8,
            i.type = "text/css",
            i.rel = "stylesheet",
            i.media = "screen,print",
            document.getElementsByTagName("head")[0].appendChild(i)
        }
    }
    , []),
    d.jsxs(d.Fragment, {
        children: [d.jsx(Y8, {
            setIsReady: s
        }), n && d.jsxs(d.Fragment, {
            children: [d.jsx(Z8, {}), d.jsx(el, {})]
        }), e && d.jsx(g.Suspense, {
            fallback: null,
            children: d.jsx(Q8, {})
        })]
    })
}
function Y8(e) {
    const [t,r] = ir()
      , n = t.get("blobt");
    return g.useEffect( () => {
        (async () => {
            if (n) {
                const [s,i] = n.split(":");
                s && i && i !== "null" && await g5(s, i)
            }
            await Zf(),
            e.setIsReady(!0),
            n && (t.delete("blobt"),
            r(t))
        }
        )()
    }
    , [n, e.setIsReady]),
    null
}
function dE({fill: e, stroke: t, strokeWidth: r, shape: n, ...s}) {
    return d.jsx("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: n === "rect" ? "0 0 435 88" : "0 0 264 256",
        height: "100%",
        width: "100%",
        preserveAspectRatio: "none",
        ...s,
        children: d.jsx("path", {
            fill: e ?? "currentColor",
            stroke: t ?? "currentColor",
            strokeWidth: r ?? void 0,
            d: n === "rect" ? "M5.275 14.85 12.879 5h398.41l18.668 8.24-.819 62.828L411.401 83H30.519l-15.581-6.96-9.663-61.19Z" : "m5.013 37.989 5.512-32.817L247.08 14.64l11.917 24.172-.543 191.378-11.143 20.012H21.001l-9.714-19.937L5.013 37.988Z"
        })
    })
}
const J8 = {
    yellow: "#FFBB13",
    red: "#FE717B",
    pink: "#E293FF",
    blue: "#5CC1E6",
    purple: "#5C7FC1",
    forest: "#50B492",
    lime: "#C1F1A2",
    faded: "#f7f7f7"
};
function at({children: e, ...t}) {
    const r = t.variant === "filled"
      , n = t.variant === "stroke"
      , s = r ? J8[t.bg] : "transparent"
      , i = t.size === "lg" ? "py-3 px-6 text-lg" : "py-2 px-4";
    return d.jsxs("button", {
        ...t,
        className: fe("relative min-w-36 uppercase justify-center z-10 flex rounded-lg appearance-none bg-transparent", i, r && (t.bg === "faded" ? "text-gray-700" : "text-white"), n && "bg-gray-100 text-purp-500", t.disabled ? "cursor-not-allowed opacity-20" : "opacity-80 hover:opacity-100", t.className),
        children: [e, d.jsx(dE, {
            className: fe("absolute -z-10 inset-0 pointer-events-none"),
            strokeWidth: n ? 2 : 0,
            fill: s
        })]
    })
}
function X8(e) {
    let t = 0;
    for (let r = 0; r < e.length; r++)
        t = (t << 5) - t + e.charCodeAt(r),
        t |= 0;
    return Math.abs(t)
}
function eU(e) {
    const t = g.useRef(null);
    if (!t.current) {
        const r = e ? X8(e.toString()) : Math.floor(Math.random() * 1e8)
          , n = r % 4 * 90
          , s = (r >> 1) % 2 * 180;
        t.current = {
            rotateZ: n,
            rotateX: s
        }
    }
    return t.current
}
function rl({children: e, borderProps: t, rotationSeed: r, noRotation: n, ...s}) {
    const {rotateZ: i, rotateX: a} = eU(r);
    return d.jsxs("span", {
        ...s,
        className: fe("block z-10 relative w-full group", s.className),
        children: [e, d.jsx(dE, {
            ...t,
            className: fe("absolute -z-10 top-0 left-0 pointer-events-none", t == null ? void 0 : t.className),
            style: {
                transform: n ? void 0 : `rotateZ(${i}deg) rotateX(${a}deg)`
            },
            fill: (t == null ? void 0 : t.fill) ?? "#fff",
            strokeWidth: (t == null ? void 0 : t.strokeWidth) ?? 4
        })]
    })
}
function tU({item: e, showType: t}) {
    const r = Je()
      , [n,s] = g.useState(!1)
      , [i,a] = g.useState(!1)
      , o = Zk();
    return d.jsxs("li", {
        className: fe("group relative", i && "opacity-50 pointer-events-none"),
        children: [r.isAdmin && d.jsx("div", {
            className: "absolute top-0 right-0 z-20 bg-white pb-4 pl-4",
            children: n ? d.jsxs("div", {
                className: "flex items-center h-[3.25rem] gap-3",
                children: [d.jsx("button", {
                    type: "button",
                    onClick: async () => {
                        o.mutate({
                            id: e.blobId
                        }, {
                            onSuccess() {
                                a(!0),
                                s(!1)
                            },
                            onError() {
                                ke.error("Failed to delete item")
                            }
                        })
                    }
                    ,
                    disabled: o.isPending,
                    className: "opacity-75 hover:opacity-100 px-2 py-1 bg-red-50 text-red-700 rounded",
                    children: "Yes, delete it"
                }), d.jsx("button", {
                    type: "button",
                    onClick: () => s(!1),
                    disabled: o.isPending,
                    className: "opacity-75 hover:opacity-100 px-2 py-1",
                    children: "Cancel"
                })]
            }) : d.jsx(at, {
                variant: "filled",
                bg: "red",
                className: "hidden group-hover:flex !min-w-0",
                onClick: () => {
                    s(!0)
                }
                ,
                children: d.jsx(sv, {})
            })
        }), d.jsxs(rl, {
            borderProps: {
                shape: "square",
                strokeWidth: 10,
                className: fe(i && "!text-red-500", e.blobType === "item" && "text-[#E9FCDD] group-hover:text-[#7AE137]", e.blobType === "avatar" && "text-[#C2E4F1] group-hover:text-[#30A0C9]")
            },
            className: "p-6 flex items-center justify-center w-full aspect-square relative",
            children: [d.jsx("img", {
                src: e.thumbnailUrl ?? "",
                alt: "Inventory item thumbnail",
                className: "block w-full",
                loading: "lazy"
            }), d.jsx("p", {
                "aria-label": "Category",
                className: fe("absolute bottom-4 left-6 capitalize truncate", t ? "opacity-50 group-hover:opacity-100" : "opacity-10 group-hover:opacity-30"),
                children: e.blobType
            })]
        })]
    }, e.id)
}
function rU() {
    var l;
    const e = jt()
      , [t,r] = ir()
      , n = t.get("username") ?? void 0
      , s = t.get("type") ?? void 0
      , i = s9(n)
      , a = (l = i.data) != null && l.ok ? s ? i.data.value.filter(c => c.blobType === s) : i.data.value : [];
    function o(c) {
        c.preventDefault();
        const f = new FormData(c.target);
        for (const [h,m] of f.entries())
            typeof m == "string" && m ? t.set(h, m) : t.delete(h);
        t.delete("page"),
        r(t),
        e.invalidateQueries({
            queryKey: ["admin", "inventory"]
        })
    }
    return d.jsxs(d.Fragment, {
        children: [d.jsxs("div", {
            className: "flex flex-1 flex-col max-h-full",
            children: [d.jsx("header", {
                className: "flex items-center justify-start h-24 px-10 border-b",
                children: d.jsxs("form", {
                    className: "flex items-center gap-4",
                    onSubmit: o,
                    children: [d.jsx("input", {
                        name: "username",
                        type: "search",
                        className: "w-96 px-4 py-3 border border-gray-400 rounded text-xl",
                        placeholder: "Username",
                        defaultValue: n
                    }), d.jsx(at, {
                        variant: "filled",
                        bg: "blue",
                        size: "lg",
                        children: "Search"
                    })]
                })
            }), a.length > 0 && d.jsx("div", {
                className: "overflow-auto flex-1",
                children: d.jsx("ul", {
                    className: "grid justify-start grid-cols-2 lg:grid-cols-3 xl:grid-cols-5 gap-4 lg:gap-6 px-10 pb-10 pt-4",
                    children: a.map(c => d.jsx(tU, {
                        item: c,
                        showType: !s
                    }, c.id))
                })
            })]
        }), d.jsx(el, {})]
    })
}
class wa extends Error {
}
class nU extends wa {
    constructor(t) {
        super(`Invalid DateTime: ${t.toMessage()}`)
    }
}
class sU extends wa {
    constructor(t) {
        super(`Invalid Interval: ${t.toMessage()}`)
    }
}
class iU extends wa {
    constructor(t) {
        super(`Invalid Duration: ${t.toMessage()}`)
    }
}
class to extends wa {
}
class fE extends wa {
    constructor(t) {
        super(`Invalid unit ${t}`)
    }
}
class Xt extends wa {
}
class _s extends wa {
    constructor() {
        super("Zone is an abstract class")
    }
}
const Q = "numeric"
  , En = "short"
  , Dr = "long"
  , Ef = {
    year: Q,
    month: Q,
    day: Q
}
  , hE = {
    year: Q,
    month: En,
    day: Q
}
  , aU = {
    year: Q,
    month: En,
    day: Q,
    weekday: En
}
  , mE = {
    year: Q,
    month: Dr,
    day: Q
}
  , pE = {
    year: Q,
    month: Dr,
    day: Q,
    weekday: Dr
}
  , yE = {
    hour: Q,
    minute: Q
}
  , gE = {
    hour: Q,
    minute: Q,
    second: Q
}
  , vE = {
    hour: Q,
    minute: Q,
    second: Q,
    timeZoneName: En
}
  , bE = {
    hour: Q,
    minute: Q,
    second: Q,
    timeZoneName: Dr
}
  , xE = {
    hour: Q,
    minute: Q,
    hourCycle: "h23"
}
  , wE = {
    hour: Q,
    minute: Q,
    second: Q,
    hourCycle: "h23"
}
  , SE = {
    hour: Q,
    minute: Q,
    second: Q,
    hourCycle: "h23",
    timeZoneName: En
}
  , kE = {
    hour: Q,
    minute: Q,
    second: Q,
    hourCycle: "h23",
    timeZoneName: Dr
}
  , EE = {
    year: Q,
    month: Q,
    day: Q,
    hour: Q,
    minute: Q
}
  , _E = {
    year: Q,
    month: Q,
    day: Q,
    hour: Q,
    minute: Q,
    second: Q
}
  , TE = {
    year: Q,
    month: En,
    day: Q,
    hour: Q,
    minute: Q
}
  , CE = {
    year: Q,
    month: En,
    day: Q,
    hour: Q,
    minute: Q,
    second: Q
}
  , oU = {
    year: Q,
    month: En,
    day: Q,
    weekday: En,
    hour: Q,
    minute: Q
}
  , PE = {
    year: Q,
    month: Dr,
    day: Q,
    hour: Q,
    minute: Q,
    timeZoneName: En
}
  , $E = {
    year: Q,
    month: Dr,
    day: Q,
    hour: Q,
    minute: Q,
    second: Q,
    timeZoneName: En
}
  , NE = {
    year: Q,
    month: Dr,
    day: Q,
    weekday: Dr,
    hour: Q,
    minute: Q,
    timeZoneName: Dr
}
  , jE = {
    year: Q,
    month: Dr,
    day: Q,
    weekday: Dr,
    hour: Q,
    minute: Q,
    second: Q,
    timeZoneName: Dr
};
class ac {
    get type() {
        throw new _s
    }
    get name() {
        throw new _s
    }
    get ianaName() {
        return this.name
    }
    get isUniversal() {
        throw new _s
    }
    offsetName(t, r) {
        throw new _s
    }
    formatOffset(t, r) {
        throw new _s
    }
    offset(t) {
        throw new _s
    }
    equals(t) {
        throw new _s
    }
    get isValid() {
        throw new _s
    }
}
let fm = null;
class mh extends ac {
    static get instance() {
        return fm === null && (fm = new mh),
        fm
    }
    get type() {
        return "system"
    }
    get name() {
        return new Intl.DateTimeFormat().resolvedOptions().timeZone
    }
    get isUniversal() {
        return !1
    }
    offsetName(t, {format: r, locale: n}) {
        return zE(t, r, n)
    }
    formatOffset(t, r) {
        return Xl(this.offset(t), r)
    }
    offset(t) {
        return -new Date(t).getTimezoneOffset()
    }
    equals(t) {
        return t.type === "system"
    }
    get isValid() {
        return !0
    }
}
let xd = {};
function lU(e) {
    return xd[e] || (xd[e] = new Intl.DateTimeFormat("en-US",{
        hour12: !1,
        timeZone: e,
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit",
        second: "2-digit",
        era: "short"
    })),
    xd[e]
}
const uU = {
    year: 0,
    month: 1,
    day: 2,
    era: 3,
    hour: 4,
    minute: 5,
    second: 6
};
function cU(e, t) {
    const r = e.format(t).replace(/\u200E/g, "")
      , n = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(r)
      , [,s,i,a,o,l,c,f] = n;
    return [a, s, i, o, l, c, f]
}
function dU(e, t) {
    const r = e.formatToParts(t)
      , n = [];
    for (let s = 0; s < r.length; s++) {
        const {type: i, value: a} = r[s]
          , o = uU[i];
        i === "era" ? n[o] = a : we(o) || (n[o] = parseInt(a, 10))
    }
    return n
}
let Gc = {};
class ps extends ac {
    static create(t) {
        return Gc[t] || (Gc[t] = new ps(t)),
        Gc[t]
    }
    static resetCache() {
        Gc = {},
        xd = {}
    }
    static isValidSpecifier(t) {
        return this.isValidZone(t)
    }
    static isValidZone(t) {
        if (!t)
            return !1;
        try {
            return new Intl.DateTimeFormat("en-US",{
                timeZone: t
            }).format(),
            !0
        } catch {
            return !1
        }
    }
    constructor(t) {
        super(),
        this.zoneName = t,
        this.valid = ps.isValidZone(t)
    }
    get type() {
        return "iana"
    }
    get name() {
        return this.zoneName
    }
    get isUniversal() {
        return !1
    }
    offsetName(t, {format: r, locale: n}) {
        return zE(t, r, n, this.name)
    }
    formatOffset(t, r) {
        return Xl(this.offset(t), r)
    }
    offset(t) {
        const r = new Date(t);
        if (isNaN(r))
            return NaN;
        const n = lU(this.name);
        let[s,i,a,o,l,c,f] = n.formatToParts ? dU(n, r) : cU(n, r);
        o === "BC" && (s = -Math.abs(s) + 1);
        const m = yh({
            year: s,
            month: i,
            day: a,
            hour: l === 24 ? 0 : l,
            minute: c,
            second: f,
            millisecond: 0
        });
        let y = +r;
        const k = y % 1e3;
        return y -= k >= 0 ? k : 1e3 + k,
        (m - y) / (60 * 1e3)
    }
    equals(t) {
        return t.type === "iana" && t.name === this.name
    }
    get isValid() {
        return this.valid
    }
}
let Px = {};
function fU(e, t={}) {
    const r = JSON.stringify([e, t]);
    let n = Px[r];
    return n || (n = new Intl.ListFormat(e,t),
    Px[r] = n),
    n
}
let uy = {};
function cy(e, t={}) {
    const r = JSON.stringify([e, t]);
    let n = uy[r];
    return n || (n = new Intl.DateTimeFormat(e,t),
    uy[r] = n),
    n
}
let dy = {};
function hU(e, t={}) {
    const r = JSON.stringify([e, t]);
    let n = dy[r];
    return n || (n = new Intl.NumberFormat(e,t),
    dy[r] = n),
    n
}
let fy = {};
function mU(e, t={}) {
    const {base: r, ...n} = t
      , s = JSON.stringify([e, n]);
    let i = fy[s];
    return i || (i = new Intl.RelativeTimeFormat(e,t),
    fy[s] = i),
    i
}
let Dl = null;
function pU() {
    return Dl || (Dl = new Intl.DateTimeFormat().resolvedOptions().locale,
    Dl)
}
let $x = {};
function yU(e) {
    let t = $x[e];
    if (!t) {
        const r = new Intl.Locale(e);
        t = "getWeekInfo"in r ? r.getWeekInfo() : r.weekInfo,
        $x[e] = t
    }
    return t
}
function gU(e) {
    const t = e.indexOf("-x-");
    t !== -1 && (e = e.substring(0, t));
    const r = e.indexOf("-u-");
    if (r === -1)
        return [e];
    {
        let n, s;
        try {
            n = cy(e).resolvedOptions(),
            s = e
        } catch {
            const l = e.substring(0, r);
            n = cy(l).resolvedOptions(),
            s = l
        }
        const {numberingSystem: i, calendar: a} = n;
        return [s, i, a]
    }
}
function vU(e, t, r) {
    return (r || t) && (e.includes("-u-") || (e += "-u"),
    r && (e += `-ca-${r}`),
    t && (e += `-nu-${t}`)),
    e
}
function bU(e) {
    const t = [];
    for (let r = 1; r <= 12; r++) {
        const n = xe.utc(2009, r, 1);
        t.push(e(n))
    }
    return t
}
function xU(e) {
    const t = [];
    for (let r = 1; r <= 7; r++) {
        const n = xe.utc(2016, 11, 13 + r);
        t.push(e(n))
    }
    return t
}
function Yc(e, t, r, n) {
    const s = e.listingMode();
    return s === "error" ? null : s === "en" ? r(t) : n(t)
}
function wU(e) {
    return e.numberingSystem && e.numberingSystem !== "latn" ? !1 : e.numberingSystem === "latn" || !e.locale || e.locale.startsWith("en") || new Intl.DateTimeFormat(e.intl).resolvedOptions().numberingSystem === "latn"
}
class SU {
    constructor(t, r, n) {
        this.padTo = n.padTo || 0,
        this.floor = n.floor || !1;
        const {padTo: s, floor: i, ...a} = n;
        if (!r || Object.keys(a).length > 0) {
            const o = {
                useGrouping: !1,
                ...n
            };
            n.padTo > 0 && (o.minimumIntegerDigits = n.padTo),
            this.inf = hU(t, o)
        }
    }
    format(t) {
        if (this.inf) {
            const r = this.floor ? Math.floor(t) : t;
            return this.inf.format(r)
        } else {
            const r = this.floor ? Math.floor(t) : mv(t, 3);
            return $t(r, this.padTo)
        }
    }
}
class kU {
    constructor(t, r, n) {
        this.opts = n,
        this.originalZone = void 0;
        let s;
        if (this.opts.timeZone)
            this.dt = t;
        else if (t.zone.type === "fixed") {
            const a = -1 * (t.offset / 60)
              , o = a >= 0 ? `Etc/GMT+${a}` : `Etc/GMT${a}`;
            t.offset !== 0 && ps.create(o).valid ? (s = o,
            this.dt = t) : (s = "UTC",
            this.dt = t.offset === 0 ? t : t.setZone("UTC").plus({
                minutes: t.offset
            }),
            this.originalZone = t.zone)
        } else
            t.zone.type === "system" ? this.dt = t : t.zone.type === "iana" ? (this.dt = t,
            s = t.zone.name) : (s = "UTC",
            this.dt = t.setZone("UTC").plus({
                minutes: t.offset
            }),
            this.originalZone = t.zone);
        const i = {
            ...this.opts
        };
        i.timeZone = i.timeZone || s,
        this.dtf = cy(r, i)
    }
    format() {
        return this.originalZone ? this.formatToParts().map( ({value: t}) => t).join("") : this.dtf.format(this.dt.toJSDate())
    }
    formatToParts() {
        const t = this.dtf.formatToParts(this.dt.toJSDate());
        return this.originalZone ? t.map(r => {
            if (r.type === "timeZoneName") {
                const n = this.originalZone.offsetName(this.dt.ts, {
                    locale: this.dt.locale,
                    format: this.opts.timeZoneName
                });
                return {
                    ...r,
                    value: n
                }
            } else
                return r
        }
        ) : t
    }
    resolvedOptions() {
        return this.dtf.resolvedOptions()
    }
}
class EU {
    constructor(t, r, n) {
        this.opts = {
            style: "long",
            ...n
        },
        !r && DE() && (this.rtf = mU(t, n))
    }
    format(t, r) {
        return this.rtf ? this.rtf.format(t, r) : ZU(r, t, this.opts.numeric, this.opts.style !== "long")
    }
    formatToParts(t, r) {
        return this.rtf ? this.rtf.formatToParts(t, r) : []
    }
}
const _U = {
    firstDay: 1,
    minimalDays: 4,
    weekend: [6, 7]
};
class We {
    static fromOpts(t) {
        return We.create(t.locale, t.numberingSystem, t.outputCalendar, t.weekSettings, t.defaultToEN)
    }
    static create(t, r, n, s, i=!1) {
        const a = t || vt.defaultLocale
          , o = a || (i ? "en-US" : pU())
          , l = r || vt.defaultNumberingSystem
          , c = n || vt.defaultOutputCalendar
          , f = hy(s) || vt.defaultWeekSettings;
        return new We(o,l,c,f,a)
    }
    static resetCache() {
        Dl = null,
        uy = {},
        dy = {},
        fy = {}
    }
    static fromObject({locale: t, numberingSystem: r, outputCalendar: n, weekSettings: s}={}) {
        return We.create(t, r, n, s)
    }
    constructor(t, r, n, s, i) {
        const [a,o,l] = gU(t);
        this.locale = a,
        this.numberingSystem = r || o || null,
        this.outputCalendar = n || l || null,
        this.weekSettings = s,
        this.intl = vU(this.locale, this.numberingSystem, this.outputCalendar),
        this.weekdaysCache = {
            format: {},
            standalone: {}
        },
        this.monthsCache = {
            format: {},
            standalone: {}
        },
        this.meridiemCache = null,
        this.eraCache = {},
        this.specifiedLocale = i,
        this.fastNumbersCached = null
    }
    get fastNumbers() {
        return this.fastNumbersCached == null && (this.fastNumbersCached = wU(this)),
        this.fastNumbersCached
    }
    listingMode() {
        const t = this.isEnglish()
          , r = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");
        return t && r ? "en" : "intl"
    }
    clone(t) {
        return !t || Object.getOwnPropertyNames(t).length === 0 ? this : We.create(t.locale || this.specifiedLocale, t.numberingSystem || this.numberingSystem, t.outputCalendar || this.outputCalendar, hy(t.weekSettings) || this.weekSettings, t.defaultToEN || !1)
    }
    redefaultToEN(t={}) {
        return this.clone({
            ...t,
            defaultToEN: !0
        })
    }
    redefaultToSystem(t={}) {
        return this.clone({
            ...t,
            defaultToEN: !1
        })
    }
    months(t, r=!1) {
        return Yc(this, t, BE, () => {
            const n = r ? {
                month: t,
                day: "numeric"
            } : {
                month: t
            }
              , s = r ? "format" : "standalone";
            return this.monthsCache[s][t] || (this.monthsCache[s][t] = bU(i => this.extract(i, n, "month"))),
            this.monthsCache[s][t]
        }
        )
    }
    weekdays(t, r=!1) {
        return Yc(this, t, HE, () => {
            const n = r ? {
                weekday: t,
                year: "numeric",
                month: "long",
                day: "numeric"
            } : {
                weekday: t
            }
              , s = r ? "format" : "standalone";
            return this.weekdaysCache[s][t] || (this.weekdaysCache[s][t] = xU(i => this.extract(i, n, "weekday"))),
            this.weekdaysCache[s][t]
        }
        )
    }
    meridiems() {
        return Yc(this, void 0, () => ZE, () => {
            if (!this.meridiemCache) {
                const t = {
                    hour: "numeric",
                    hourCycle: "h12"
                };
                this.meridiemCache = [xe.utc(2016, 11, 13, 9), xe.utc(2016, 11, 13, 19)].map(r => this.extract(r, t, "dayperiod"))
            }
            return this.meridiemCache
        }
        )
    }
    eras(t) {
        return Yc(this, t, KE, () => {
            const r = {
                era: t
            };
            return this.eraCache[t] || (this.eraCache[t] = [xe.utc(-40, 1, 1), xe.utc(2017, 1, 1)].map(n => this.extract(n, r, "era"))),
            this.eraCache[t]
        }
        )
    }
    extract(t, r, n) {
        const s = this.dtFormatter(t, r)
          , i = s.formatToParts()
          , a = i.find(o => o.type.toLowerCase() === n);
        return a ? a.value : null
    }
    numberFormatter(t={}) {
        return new SU(this.intl,t.forceSimple || this.fastNumbers,t)
    }
    dtFormatter(t, r={}) {
        return new kU(t,this.intl,r)
    }
    relFormatter(t={}) {
        return new EU(this.intl,this.isEnglish(),t)
    }
    listFormatter(t={}) {
        return fU(this.intl, t)
    }
    isEnglish() {
        return this.locale === "en" || this.locale.toLowerCase() === "en-us" || new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us")
    }
    getWeekSettings() {
        return this.weekSettings ? this.weekSettings : FE() ? yU(this.locale) : _U
    }
    getStartOfWeek() {
        return this.getWeekSettings().firstDay
    }
    getMinDaysInFirstWeek() {
        return this.getWeekSettings().minimalDays
    }
    getWeekendDays() {
        return this.getWeekSettings().weekend
    }
    equals(t) {
        return this.locale === t.locale && this.numberingSystem === t.numberingSystem && this.outputCalendar === t.outputCalendar
    }
    toString() {
        return `Locale(${this.locale}, ${this.numberingSystem}, ${this.outputCalendar})`
    }
}
let hm = null;
class mr extends ac {
    static get utcInstance() {
        return hm === null && (hm = new mr(0)),
        hm
    }
    static instance(t) {
        return t === 0 ? mr.utcInstance : new mr(t)
    }
    static parseSpecifier(t) {
        if (t) {
            const r = t.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
            if (r)
                return new mr(gh(r[1], r[2]))
        }
        return null
    }
    constructor(t) {
        super(),
        this.fixed = t
    }
    get type() {
        return "fixed"
    }
    get name() {
        return this.fixed === 0 ? "UTC" : `UTC${Xl(this.fixed, "narrow")}`
    }
    get ianaName() {
        return this.fixed === 0 ? "Etc/UTC" : `Etc/GMT${Xl(-this.fixed, "narrow")}`
    }
    offsetName() {
        return this.name
    }
    formatOffset(t, r) {
        return Xl(this.fixed, r)
    }
    get isUniversal() {
        return !0
    }
    offset() {
        return this.fixed
    }
    equals(t) {
        return t.type === "fixed" && t.fixed === this.fixed
    }
    get isValid() {
        return !0
    }
}
class TU extends ac {
    constructor(t) {
        super(),
        this.zoneName = t
    }
    get type() {
        return "invalid"
    }
    get name() {
        return this.zoneName
    }
    get isUniversal() {
        return !1
    }
    offsetName() {
        return null
    }
    formatOffset() {
        return ""
    }
    offset() {
        return NaN
    }
    equals() {
        return !1
    }
    get isValid() {
        return !1
    }
}
function Ls(e, t) {
    if (we(e) || e === null)
        return t;
    if (e instanceof ac)
        return e;
    if (IU(e)) {
        const r = e.toLowerCase();
        return r === "default" ? t : r === "local" || r === "system" ? mh.instance : r === "utc" || r === "gmt" ? mr.utcInstance : mr.parseSpecifier(r) || ps.create(e)
    } else
        return oi(e) ? mr.instance(e) : typeof e == "object" && "offset"in e && typeof e.offset == "function" ? e : new TU(e)
}
const cv = {
    arab: "[-]",
    arabext: "[-]",
    bali: "[-]",
    beng: "[-]",
    deva: "[-]",
    fullwide: "[-]",
    gujr: "[-]",
    hanidec: "[|||||||||]",
    khmr: "[-]",
    knda: "[-]",
    laoo: "[-]",
    limb: "[-]",
    mlym: "[-]",
    mong: "[-]",
    mymr: "[-]",
    orya: "[-]",
    tamldec: "[-]",
    telu: "[-]",
    thai: "[-]",
    tibt: "[-]",
    latn: "\\d"
}
  , Nx = {
    arab: [1632, 1641],
    arabext: [1776, 1785],
    bali: [6992, 7001],
    beng: [2534, 2543],
    deva: [2406, 2415],
    fullwide: [65296, 65303],
    gujr: [2790, 2799],
    khmr: [6112, 6121],
    knda: [3302, 3311],
    laoo: [3792, 3801],
    limb: [6470, 6479],
    mlym: [3430, 3439],
    mong: [6160, 6169],
    mymr: [4160, 4169],
    orya: [2918, 2927],
    tamldec: [3046, 3055],
    telu: [3174, 3183],
    thai: [3664, 3673],
    tibt: [3872, 3881]
}
  , CU = cv.hanidec.replace(/[\[|\]]/g, "").split("");
function PU(e) {
    let t = parseInt(e, 10);
    if (isNaN(t)) {
        t = "";
        for (let r = 0; r < e.length; r++) {
            const n = e.charCodeAt(r);
            if (e[r].search(cv.hanidec) !== -1)
                t += CU.indexOf(e[r]);
            else
                for (const s in Nx) {
                    const [i,a] = Nx[s];
                    n >= i && n <= a && (t += n - i)
                }
        }
        return parseInt(t, 10)
    } else
        return t
}
let Fa = {};
function $U() {
    Fa = {}
}
function an({numberingSystem: e}, t="") {
    const r = e || "latn";
    return Fa[r] || (Fa[r] = {}),
    Fa[r][t] || (Fa[r][t] = new RegExp(`${cv[r]}${t}`)),
    Fa[r][t]
}
let jx = () => Date.now(), Ix = "system", Rx = null, Ox = null, Mx = null, Ax = 60, Lx, Dx = null;
class vt {
    static get now() {
        return jx
    }
    static set now(t) {
        jx = t
    }
    static set defaultZone(t) {
        Ix = t
    }
    static get defaultZone() {
        return Ls(Ix, mh.instance)
    }
    static get defaultLocale() {
        return Rx
    }
    static set defaultLocale(t) {
        Rx = t
    }
    static get defaultNumberingSystem() {
        return Ox
    }
    static set defaultNumberingSystem(t) {
        Ox = t
    }
    static get defaultOutputCalendar() {
        return Mx
    }
    static set defaultOutputCalendar(t) {
        Mx = t
    }
    static get defaultWeekSettings() {
        return Dx
    }
    static set defaultWeekSettings(t) {
        Dx = hy(t)
    }
    static get twoDigitCutoffYear() {
        return Ax
    }
    static set twoDigitCutoffYear(t) {
        Ax = t % 100
    }
    static get throwOnInvalid() {
        return Lx
    }
    static set throwOnInvalid(t) {
        Lx = t
    }
    static resetCaches() {
        We.resetCache(),
        ps.resetCache(),
        xe.resetCache(),
        $U()
    }
}
class gn {
    constructor(t, r) {
        this.reason = t,
        this.explanation = r
    }
    toMessage() {
        return this.explanation ? `${this.reason}: ${this.explanation}` : this.reason
    }
}
const IE = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334]
  , RE = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
function Yr(e, t) {
    return new gn("unit out of range",`you specified ${t} (of type ${typeof t}) as a ${e}, which is invalid`)
}
function dv(e, t, r) {
    const n = new Date(Date.UTC(e, t - 1, r));
    e < 100 && e >= 0 && n.setUTCFullYear(n.getUTCFullYear() - 1900);
    const s = n.getUTCDay();
    return s === 0 ? 7 : s
}
function OE(e, t, r) {
    return r + (oc(e) ? RE : IE)[t - 1]
}
function ME(e, t) {
    const r = oc(e) ? RE : IE
      , n = r.findIndex(i => i < t)
      , s = t - r[n];
    return {
        month: n + 1,
        day: s
    }
}
function fv(e, t) {
    return (e - t + 7) % 7 + 1
}
function _f(e, t=4, r=1) {
    const {year: n, month: s, day: i} = e
      , a = OE(n, s, i)
      , o = fv(dv(n, s, i), r);
    let l = Math.floor((a - o + 14 - t) / 7), c;
    return l < 1 ? (c = n - 1,
    l = Du(c, t, r)) : l > Du(n, t, r) ? (c = n + 1,
    l = 1) : c = n,
    {
        weekYear: c,
        weekNumber: l,
        weekday: o,
        ...vh(e)
    }
}
function Fx(e, t=4, r=1) {
    const {weekYear: n, weekNumber: s, weekday: i} = e
      , a = fv(dv(n, 1, t), r)
      , o = fo(n);
    let l = s * 7 + i - a - 7 + t, c;
    l < 1 ? (c = n - 1,
    l += fo(c)) : l > o ? (c = n + 1,
    l -= fo(n)) : c = n;
    const {month: f, day: h} = ME(c, l);
    return {
        year: c,
        month: f,
        day: h,
        ...vh(e)
    }
}
function mm(e) {
    const {year: t, month: r, day: n} = e
      , s = OE(t, r, n);
    return {
        year: t,
        ordinal: s,
        ...vh(e)
    }
}
function zx(e) {
    const {year: t, ordinal: r} = e
      , {month: n, day: s} = ME(t, r);
    return {
        year: t,
        month: n,
        day: s,
        ...vh(e)
    }
}
function Ux(e, t) {
    if (!we(e.localWeekday) || !we(e.localWeekNumber) || !we(e.localWeekYear)) {
        if (!we(e.weekday) || !we(e.weekNumber) || !we(e.weekYear))
            throw new to("Cannot mix locale-based week fields with ISO-based week fields");
        return we(e.localWeekday) || (e.weekday = e.localWeekday),
        we(e.localWeekNumber) || (e.weekNumber = e.localWeekNumber),
        we(e.localWeekYear) || (e.weekYear = e.localWeekYear),
        delete e.localWeekday,
        delete e.localWeekNumber,
        delete e.localWeekYear,
        {
            minDaysInFirstWeek: t.getMinDaysInFirstWeek(),
            startOfWeek: t.getStartOfWeek()
        }
    } else
        return {
            minDaysInFirstWeek: 4,
            startOfWeek: 1
        }
}
function NU(e, t=4, r=1) {
    const n = ph(e.weekYear)
      , s = Jr(e.weekNumber, 1, Du(e.weekYear, t, r))
      , i = Jr(e.weekday, 1, 7);
    return n ? s ? i ? !1 : Yr("weekday", e.weekday) : Yr("week", e.weekNumber) : Yr("weekYear", e.weekYear)
}
function jU(e) {
    const t = ph(e.year)
      , r = Jr(e.ordinal, 1, fo(e.year));
    return t ? r ? !1 : Yr("ordinal", e.ordinal) : Yr("year", e.year)
}
function AE(e) {
    const t = ph(e.year)
      , r = Jr(e.month, 1, 12)
      , n = Jr(e.day, 1, Tf(e.year, e.month));
    return t ? r ? n ? !1 : Yr("day", e.day) : Yr("month", e.month) : Yr("year", e.year)
}
function LE(e) {
    const {hour: t, minute: r, second: n, millisecond: s} = e
      , i = Jr(t, 0, 23) || t === 24 && r === 0 && n === 0 && s === 0
      , a = Jr(r, 0, 59)
      , o = Jr(n, 0, 59)
      , l = Jr(s, 0, 999);
    return i ? a ? o ? l ? !1 : Yr("millisecond", s) : Yr("second", n) : Yr("minute", r) : Yr("hour", t)
}
function we(e) {
    return typeof e > "u"
}
function oi(e) {
    return typeof e == "number"
}
function ph(e) {
    return typeof e == "number" && e % 1 === 0
}
function IU(e) {
    return typeof e == "string"
}
function RU(e) {
    return Object.prototype.toString.call(e) === "[object Date]"
}
function DE() {
    try {
        return typeof Intl < "u" && !!Intl.RelativeTimeFormat
    } catch {
        return !1
    }
}
function FE() {
    try {
        return typeof Intl < "u" && !!Intl.Locale && ("weekInfo"in Intl.Locale.prototype || "getWeekInfo"in Intl.Locale.prototype)
    } catch {
        return !1
    }
}
function OU(e) {
    return Array.isArray(e) ? e : [e]
}
function Vx(e, t, r) {
    if (e.length !== 0)
        return e.reduce( (n, s) => {
            const i = [t(s), s];
            return n && r(n[0], i[0]) === n[0] ? n : i
        }
        , null)[1]
}
function MU(e, t) {
    return t.reduce( (r, n) => (r[n] = e[n],
    r), {})
}
function zo(e, t) {
    return Object.prototype.hasOwnProperty.call(e, t)
}
function hy(e) {
    if (e == null)
        return null;
    if (typeof e != "object")
        throw new Xt("Week settings must be an object");
    if (!Jr(e.firstDay, 1, 7) || !Jr(e.minimalDays, 1, 7) || !Array.isArray(e.weekend) || e.weekend.some(t => !Jr(t, 1, 7)))
        throw new Xt("Invalid week settings");
    return {
        firstDay: e.firstDay,
        minimalDays: e.minimalDays,
        weekend: Array.from(e.weekend)
    }
}
function Jr(e, t, r) {
    return ph(e) && e >= t && e <= r
}
function AU(e, t) {
    return e - t * Math.floor(e / t)
}
function $t(e, t=2) {
    const r = e < 0;
    let n;
    return r ? n = "-" + ("" + -e).padStart(t, "0") : n = ("" + e).padStart(t, "0"),
    n
}
function Rs(e) {
    if (!(we(e) || e === null || e === ""))
        return parseInt(e, 10)
}
function $i(e) {
    if (!(we(e) || e === null || e === ""))
        return parseFloat(e)
}
function hv(e) {
    if (!(we(e) || e === null || e === "")) {
        const t = parseFloat("0." + e) * 1e3;
        return Math.floor(t)
    }
}
function mv(e, t, r=!1) {
    const n = 10 ** t;
    return (r ? Math.trunc : Math.round)(e * n) / n
}
function oc(e) {
    return e % 4 === 0 && (e % 100 !== 0 || e % 400 === 0)
}
function fo(e) {
    return oc(e) ? 366 : 365
}
function Tf(e, t) {
    const r = AU(t - 1, 12) + 1
      , n = e + (t - r) / 12;
    return r === 2 ? oc(n) ? 29 : 28 : [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][r - 1]
}
function yh(e) {
    let t = Date.UTC(e.year, e.month - 1, e.day, e.hour, e.minute, e.second, e.millisecond);
    return e.year < 100 && e.year >= 0 && (t = new Date(t),
    t.setUTCFullYear(e.year, e.month - 1, e.day)),
    +t
}
function Bx(e, t, r) {
    return -fv(dv(e, 1, t), r) + t - 1
}
function Du(e, t=4, r=1) {
    const n = Bx(e, t, r)
      , s = Bx(e + 1, t, r);
    return (fo(e) - n + s) / 7
}
function my(e) {
    return e > 99 ? e : e > vt.twoDigitCutoffYear ? 1900 + e : 2e3 + e
}
function zE(e, t, r, n=null) {
    const s = new Date(e)
      , i = {
        hourCycle: "h23",
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit"
    };
    n && (i.timeZone = n);
    const a = {
        timeZoneName: t,
        ...i
    }
      , o = new Intl.DateTimeFormat(r,a).formatToParts(s).find(l => l.type.toLowerCase() === "timezonename");
    return o ? o.value : null
}
function gh(e, t) {
    let r = parseInt(e, 10);
    Number.isNaN(r) && (r = 0);
    const n = parseInt(t, 10) || 0
      , s = r < 0 || Object.is(r, -0) ? -n : n;
    return r * 60 + s
}
function UE(e) {
    const t = Number(e);
    if (typeof e == "boolean" || e === "" || Number.isNaN(t))
        throw new Xt(`Invalid unit value ${e}`);
    return t
}
function Cf(e, t) {
    const r = {};
    for (const n in e)
        if (zo(e, n)) {
            const s = e[n];
            if (s == null)
                continue;
            r[t(n)] = UE(s)
        }
    return r
}
function Xl(e, t) {
    const r = Math.trunc(Math.abs(e / 60))
      , n = Math.trunc(Math.abs(e % 60))
      , s = e >= 0 ? "+" : "-";
    switch (t) {
    case "short":
        return `${s}${$t(r, 2)}:${$t(n, 2)}`;
    case "narrow":
        return `${s}${r}${n > 0 ? `:${n}` : ""}`;
    case "techie":
        return `${s}${$t(r, 2)}${$t(n, 2)}`;
    default:
        throw new RangeError(`Value format ${t} is out of range for property format`)
    }
}
function vh(e) {
    return MU(e, ["hour", "minute", "second", "millisecond"])
}
const LU = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
  , VE = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
  , DU = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
function BE(e) {
    switch (e) {
    case "narrow":
        return [...DU];
    case "short":
        return [...VE];
    case "long":
        return [...LU];
    case "numeric":
        return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
    case "2-digit":
        return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
    default:
        return null
    }
}
const WE = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"]
  , qE = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"]
  , FU = ["M", "T", "W", "T", "F", "S", "S"];
function HE(e) {
    switch (e) {
    case "narrow":
        return [...FU];
    case "short":
        return [...qE];
    case "long":
        return [...WE];
    case "numeric":
        return ["1", "2", "3", "4", "5", "6", "7"];
    default:
        return null
    }
}
const ZE = ["AM", "PM"]
  , zU = ["Before Christ", "Anno Domini"]
  , UU = ["BC", "AD"]
  , VU = ["B", "A"];
function KE(e) {
    switch (e) {
    case "narrow":
        return [...VU];
    case "short":
        return [...UU];
    case "long":
        return [...zU];
    default:
        return null
    }
}
function BU(e) {
    return ZE[e.hour < 12 ? 0 : 1]
}
function WU(e, t) {
    return HE(t)[e.weekday - 1]
}
function qU(e, t) {
    return BE(t)[e.month - 1]
}
function HU(e, t) {
    return KE(t)[e.year < 0 ? 0 : 1]
}
function ZU(e, t, r="always", n=!1) {
    const s = {
        years: ["year", "yr."],
        quarters: ["quarter", "qtr."],
        months: ["month", "mo."],
        weeks: ["week", "wk."],
        days: ["day", "day", "days"],
        hours: ["hour", "hr."],
        minutes: ["minute", "min."],
        seconds: ["second", "sec."]
    }
      , i = ["hours", "minutes", "seconds"].indexOf(e) === -1;
    if (r === "auto" && i) {
        const h = e === "days";
        switch (t) {
        case 1:
            return h ? "tomorrow" : `next ${s[e][0]}`;
        case -1:
            return h ? "yesterday" : `last ${s[e][0]}`;
        case 0:
            return h ? "today" : `this ${s[e][0]}`
        }
    }
    const a = Object.is(t, -0) || t < 0
      , o = Math.abs(t)
      , l = o === 1
      , c = s[e]
      , f = n ? l ? c[1] : c[2] || c[1] : l ? s[e][0] : e;
    return a ? `${o} ${f} ago` : `in ${o} ${f}`
}
function Wx(e, t) {
    let r = "";
    for (const n of e)
        n.literal ? r += n.val : r += t(n.val);
    return r
}
const KU = {
    D: Ef,
    DD: hE,
    DDD: mE,
    DDDD: pE,
    t: yE,
    tt: gE,
    ttt: vE,
    tttt: bE,
    T: xE,
    TT: wE,
    TTT: SE,
    TTTT: kE,
    f: EE,
    ff: TE,
    fff: PE,
    ffff: NE,
    F: _E,
    FF: CE,
    FFF: $E,
    FFFF: jE
};
class rr {
    static create(t, r={}) {
        return new rr(t,r)
    }
    static parseFormat(t) {
        let r = null
          , n = ""
          , s = !1;
        const i = [];
        for (let a = 0; a < t.length; a++) {
            const o = t.charAt(a);
            o === "'" ? (n.length > 0 && i.push({
                literal: s || /^\s+$/.test(n),
                val: n
            }),
            r = null,
            n = "",
            s = !s) : s || o === r ? n += o : (n.length > 0 && i.push({
                literal: /^\s+$/.test(n),
                val: n
            }),
            n = o,
            r = o)
        }
        return n.length > 0 && i.push({
            literal: s || /^\s+$/.test(n),
            val: n
        }),
        i
    }
    static macroTokenToFormatOpts(t) {
        return KU[t]
    }
    constructor(t, r) {
        this.opts = r,
        this.loc = t,
        this.systemLoc = null
    }
    formatWithSystemDefault(t, r) {
        return this.systemLoc === null && (this.systemLoc = this.loc.redefaultToSystem()),
        this.systemLoc.dtFormatter(t, {
            ...this.opts,
            ...r
        }).format()
    }
    dtFormatter(t, r={}) {
        return this.loc.dtFormatter(t, {
            ...this.opts,
            ...r
        })
    }
    formatDateTime(t, r) {
        return this.dtFormatter(t, r).format()
    }
    formatDateTimeParts(t, r) {
        return this.dtFormatter(t, r).formatToParts()
    }
    formatInterval(t, r) {
        return this.dtFormatter(t.start, r).dtf.formatRange(t.start.toJSDate(), t.end.toJSDate())
    }
    resolvedOptions(t, r) {
        return this.dtFormatter(t, r).resolvedOptions()
    }
    num(t, r=0) {
        if (this.opts.forceSimple)
            return $t(t, r);
        const n = {
            ...this.opts
        };
        return r > 0 && (n.padTo = r),
        this.loc.numberFormatter(n).format(t)
    }
    formatDateTimeFromString(t, r) {
        const n = this.loc.listingMode() === "en"
          , s = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory"
          , i = (y, k) => this.loc.extract(t, y, k)
          , a = y => t.isOffsetFixed && t.offset === 0 && y.allowZ ? "Z" : t.isValid ? t.zone.formatOffset(t.ts, y.format) : ""
          , o = () => n ? BU(t) : i({
            hour: "numeric",
            hourCycle: "h12"
        }, "dayperiod")
          , l = (y, k) => n ? qU(t, y) : i(k ? {
            month: y
        } : {
            month: y,
            day: "numeric"
        }, "month")
          , c = (y, k) => n ? WU(t, y) : i(k ? {
            weekday: y
        } : {
            weekday: y,
            month: "long",
            day: "numeric"
        }, "weekday")
          , f = y => {
            const k = rr.macroTokenToFormatOpts(y);
            return k ? this.formatWithSystemDefault(t, k) : y
        }
          , h = y => n ? HU(t, y) : i({
            era: y
        }, "era")
          , m = y => {
            switch (y) {
            case "S":
                return this.num(t.millisecond);
            case "u":
            case "SSS":
                return this.num(t.millisecond, 3);
            case "s":
                return this.num(t.second);
            case "ss":
                return this.num(t.second, 2);
            case "uu":
                return this.num(Math.floor(t.millisecond / 10), 2);
            case "uuu":
                return this.num(Math.floor(t.millisecond / 100));
            case "m":
                return this.num(t.minute);
            case "mm":
                return this.num(t.minute, 2);
            case "h":
                return this.num(t.hour % 12 === 0 ? 12 : t.hour % 12);
            case "hh":
                return this.num(t.hour % 12 === 0 ? 12 : t.hour % 12, 2);
            case "H":
                return this.num(t.hour);
            case "HH":
                return this.num(t.hour, 2);
            case "Z":
                return a({
                    format: "narrow",
                    allowZ: this.opts.allowZ
                });
            case "ZZ":
                return a({
                    format: "short",
                    allowZ: this.opts.allowZ
                });
            case "ZZZ":
                return a({
                    format: "techie",
                    allowZ: this.opts.allowZ
                });
            case "ZZZZ":
                return t.zone.offsetName(t.ts, {
                    format: "short",
                    locale: this.loc.locale
                });
            case "ZZZZZ":
                return t.zone.offsetName(t.ts, {
                    format: "long",
                    locale: this.loc.locale
                });
            case "z":
                return t.zoneName;
            case "a":
                return o();
            case "d":
                return s ? i({
                    day: "numeric"
                }, "day") : this.num(t.day);
            case "dd":
                return s ? i({
                    day: "2-digit"
                }, "day") : this.num(t.day, 2);
            case "c":
                return this.num(t.weekday);
            case "ccc":
                return c("short", !0);
            case "cccc":
                return c("long", !0);
            case "ccccc":
                return c("narrow", !0);
            case "E":
                return this.num(t.weekday);
            case "EEE":
                return c("short", !1);
            case "EEEE":
                return c("long", !1);
            case "EEEEE":
                return c("narrow", !1);
            case "L":
                return s ? i({
                    month: "numeric",
                    day: "numeric"
                }, "month") : this.num(t.month);
            case "LL":
                return s ? i({
                    month: "2-digit",
                    day: "numeric"
                }, "month") : this.num(t.month, 2);
            case "LLL":
                return l("short", !0);
            case "LLLL":
                return l("long", !0);
            case "LLLLL":
                return l("narrow", !0);
            case "M":
                return s ? i({
                    month: "numeric"
                }, "month") : this.num(t.month);
            case "MM":
                return s ? i({
                    month: "2-digit"
                }, "month") : this.num(t.month, 2);
            case "MMM":
                return l("short", !1);
            case "MMMM":
                return l("long", !1);
            case "MMMMM":
                return l("narrow", !1);
            case "y":
                return s ? i({
                    year: "numeric"
                }, "year") : this.num(t.year);
            case "yy":
                return s ? i({
                    year: "2-digit"
                }, "year") : this.num(t.year.toString().slice(-2), 2);
            case "yyyy":
                return s ? i({
                    year: "numeric"
                }, "year") : this.num(t.year, 4);
            case "yyyyyy":
                return s ? i({
                    year: "numeric"
                }, "year") : this.num(t.year, 6);
            case "G":
                return h("short");
            case "GG":
                return h("long");
            case "GGGGG":
                return h("narrow");
            case "kk":
                return this.num(t.weekYear.toString().slice(-2), 2);
            case "kkkk":
                return this.num(t.weekYear, 4);
            case "W":
                return this.num(t.weekNumber);
            case "WW":
                return this.num(t.weekNumber, 2);
            case "n":
                return this.num(t.localWeekNumber);
            case "nn":
                return this.num(t.localWeekNumber, 2);
            case "ii":
                return this.num(t.localWeekYear.toString().slice(-2), 2);
            case "iiii":
                return this.num(t.localWeekYear, 4);
            case "o":
                return this.num(t.ordinal);
            case "ooo":
                return this.num(t.ordinal, 3);
            case "q":
                return this.num(t.quarter);
            case "qq":
                return this.num(t.quarter, 2);
            case "X":
                return this.num(Math.floor(t.ts / 1e3));
            case "x":
                return this.num(t.ts);
            default:
                return f(y)
            }
        }
        ;
        return Wx(rr.parseFormat(r), m)
    }
    formatDurationFromString(t, r) {
        const n = l => {
            switch (l[0]) {
            case "S":
                return "millisecond";
            case "s":
                return "second";
            case "m":
                return "minute";
            case "h":
                return "hour";
            case "d":
                return "day";
            case "w":
                return "week";
            case "M":
                return "month";
            case "y":
                return "year";
            default:
                return null
            }
        }
          , s = l => c => {
            const f = n(c);
            return f ? this.num(l.get(f), c.length) : c
        }
          , i = rr.parseFormat(r)
          , a = i.reduce( (l, {literal: c, val: f}) => c ? l : l.concat(f), [])
          , o = t.shiftTo(...a.map(n).filter(l => l));
        return Wx(i, s(o))
    }
}
const QE = /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;
function nl(...e) {
    const t = e.reduce( (r, n) => r + n.source, "");
    return RegExp(`^${t}$`)
}
function sl(...e) {
    return t => e.reduce( ([r,n,s], i) => {
        const [a,o,l] = i(t, s);
        return [{
            ...r,
            ...a
        }, o || n, l]
    }
    , [{}, null, 1]).slice(0, 2)
}
function il(e, ...t) {
    if (e == null)
        return [null, null];
    for (const [r,n] of t) {
        const s = r.exec(e);
        if (s)
            return n(s)
    }
    return [null, null]
}
function GE(...e) {
    return (t, r) => {
        const n = {};
        let s;
        for (s = 0; s < e.length; s++)
            n[e[s]] = Rs(t[r + s]);
        return [n, null, r + s]
    }
}
const YE = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/
  , QU = `(?:${YE.source}?(?:\\[(${QE.source})\\])?)?`
  , pv = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/
  , JE = RegExp(`${pv.source}${QU}`)
  , yv = RegExp(`(?:T${JE.source})?`)
  , GU = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/
  , YU = /(\d{4})-?W(\d\d)(?:-?(\d))?/
  , JU = /(\d{4})-?(\d{3})/
  , XU = GE("weekYear", "weekNumber", "weekDay")
  , eV = GE("year", "ordinal")
  , tV = /(\d{4})-(\d\d)-(\d\d)/
  , XE = RegExp(`${pv.source} ?(?:${YE.source}|(${QE.source}))?`)
  , rV = RegExp(`(?: ${XE.source})?`);
function ho(e, t, r) {
    const n = e[t];
    return we(n) ? r : Rs(n)
}
function nV(e, t) {
    return [{
        year: ho(e, t),
        month: ho(e, t + 1, 1),
        day: ho(e, t + 2, 1)
    }, null, t + 3]
}
function al(e, t) {
    return [{
        hours: ho(e, t, 0),
        minutes: ho(e, t + 1, 0),
        seconds: ho(e, t + 2, 0),
        milliseconds: hv(e[t + 3])
    }, null, t + 4]
}
function lc(e, t) {
    const r = !e[t] && !e[t + 1]
      , n = gh(e[t + 1], e[t + 2])
      , s = r ? null : mr.instance(n);
    return [{}, s, t + 3]
}
function uc(e, t) {
    const r = e[t] ? ps.create(e[t]) : null;
    return [{}, r, t + 1]
}
const sV = RegExp(`^T?${pv.source}$`)
  , iV = /^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;
function aV(e) {
    const [t,r,n,s,i,a,o,l,c] = e
      , f = t[0] === "-"
      , h = l && l[0] === "-"
      , m = (y, k=!1) => y !== void 0 && (k || y && f) ? -y : y;
    return [{
        years: m($i(r)),
        months: m($i(n)),
        weeks: m($i(s)),
        days: m($i(i)),
        hours: m($i(a)),
        minutes: m($i(o)),
        seconds: m($i(l), l === "-0"),
        milliseconds: m(hv(c), h)
    }]
}
const oV = {
    GMT: 0,
    EDT: -4 * 60,
    EST: -5 * 60,
    CDT: -5 * 60,
    CST: -6 * 60,
    MDT: -6 * 60,
    MST: -7 * 60,
    PDT: -7 * 60,
    PST: -8 * 60
};
function gv(e, t, r, n, s, i, a) {
    const o = {
        year: t.length === 2 ? my(Rs(t)) : Rs(t),
        month: VE.indexOf(r) + 1,
        day: Rs(n),
        hour: Rs(s),
        minute: Rs(i)
    };
    return a && (o.second = Rs(a)),
    e && (o.weekday = e.length > 3 ? WE.indexOf(e) + 1 : qE.indexOf(e) + 1),
    o
}
const lV = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;
function uV(e) {
    const [,t,r,n,s,i,a,o,l,c,f,h] = e
      , m = gv(t, s, n, r, i, a, o);
    let y;
    return l ? y = oV[l] : c ? y = 0 : y = gh(f, h),
    [m, new mr(y)]
}
function cV(e) {
    return e.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim()
}
const dV = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/
  , fV = /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/
  , hV = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;
function qx(e) {
    const [,t,r,n,s,i,a,o] = e;
    return [gv(t, s, n, r, i, a, o), mr.utcInstance]
}
function mV(e) {
    const [,t,r,n,s,i,a,o] = e;
    return [gv(t, o, r, n, s, i, a), mr.utcInstance]
}
const pV = nl(GU, yv)
  , yV = nl(YU, yv)
  , gV = nl(JU, yv)
  , vV = nl(JE)
  , e_ = sl(nV, al, lc, uc)
  , bV = sl(XU, al, lc, uc)
  , xV = sl(eV, al, lc, uc)
  , wV = sl(al, lc, uc);
function SV(e) {
    return il(e, [pV, e_], [yV, bV], [gV, xV], [vV, wV])
}
function kV(e) {
    return il(cV(e), [lV, uV])
}
function EV(e) {
    return il(e, [dV, qx], [fV, qx], [hV, mV])
}
function _V(e) {
    return il(e, [iV, aV])
}
const TV = sl(al);
function CV(e) {
    return il(e, [sV, TV])
}
const PV = nl(tV, rV)
  , $V = nl(XE)
  , NV = sl(al, lc, uc);
function jV(e) {
    return il(e, [PV, e_], [$V, NV])
}
const Hx = "Invalid Duration"
  , t_ = {
    weeks: {
        days: 7,
        hours: 7 * 24,
        minutes: 7 * 24 * 60,
        seconds: 7 * 24 * 60 * 60,
        milliseconds: 7 * 24 * 60 * 60 * 1e3
    },
    days: {
        hours: 24,
        minutes: 24 * 60,
        seconds: 24 * 60 * 60,
        milliseconds: 24 * 60 * 60 * 1e3
    },
    hours: {
        minutes: 60,
        seconds: 60 * 60,
        milliseconds: 60 * 60 * 1e3
    },
    minutes: {
        seconds: 60,
        milliseconds: 60 * 1e3
    },
    seconds: {
        milliseconds: 1e3
    }
}
  , IV = {
    years: {
        quarters: 4,
        months: 12,
        weeks: 52,
        days: 365,
        hours: 365 * 24,
        minutes: 365 * 24 * 60,
        seconds: 365 * 24 * 60 * 60,
        milliseconds: 365 * 24 * 60 * 60 * 1e3
    },
    quarters: {
        months: 3,
        weeks: 13,
        days: 91,
        hours: 91 * 24,
        minutes: 91 * 24 * 60,
        seconds: 91 * 24 * 60 * 60,
        milliseconds: 91 * 24 * 60 * 60 * 1e3
    },
    months: {
        weeks: 4,
        days: 30,
        hours: 30 * 24,
        minutes: 30 * 24 * 60,
        seconds: 30 * 24 * 60 * 60,
        milliseconds: 30 * 24 * 60 * 60 * 1e3
    },
    ...t_
}
  , Vr = 146097 / 400
  , ja = 146097 / 4800
  , RV = {
    years: {
        quarters: 4,
        months: 12,
        weeks: Vr / 7,
        days: Vr,
        hours: Vr * 24,
        minutes: Vr * 24 * 60,
        seconds: Vr * 24 * 60 * 60,
        milliseconds: Vr * 24 * 60 * 60 * 1e3
    },
    quarters: {
        months: 3,
        weeks: Vr / 28,
        days: Vr / 4,
        hours: Vr * 24 / 4,
        minutes: Vr * 24 * 60 / 4,
        seconds: Vr * 24 * 60 * 60 / 4,
        milliseconds: Vr * 24 * 60 * 60 * 1e3 / 4
    },
    months: {
        weeks: ja / 7,
        days: ja,
        hours: ja * 24,
        minutes: ja * 24 * 60,
        seconds: ja * 24 * 60 * 60,
        milliseconds: ja * 24 * 60 * 60 * 1e3
    },
    ...t_
}
  , Vi = ["years", "quarters", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds"]
  , OV = Vi.slice(0).reverse();
function Ts(e, t, r=!1) {
    const n = {
        values: r ? t.values : {
            ...e.values,
            ...t.values || {}
        },
        loc: e.loc.clone(t.loc),
        conversionAccuracy: t.conversionAccuracy || e.conversionAccuracy,
        matrix: t.matrix || e.matrix
    };
    return new Me(n)
}
function r_(e, t) {
    let r = t.milliseconds ?? 0;
    for (const n of OV.slice(1))
        t[n] && (r += t[n] * e[n].milliseconds);
    return r
}
function Zx(e, t) {
    const r = r_(e, t) < 0 ? -1 : 1;
    Vi.reduceRight( (n, s) => {
        if (we(t[s]))
            return n;
        if (n) {
            const i = t[n] * r
              , a = e[s][n]
              , o = Math.floor(i / a);
            t[s] += o * r,
            t[n] -= o * a * r
        }
        return s
    }
    , null),
    Vi.reduce( (n, s) => {
        if (we(t[s]))
            return n;
        if (n) {
            const i = t[n] % 1;
            t[n] -= i,
            t[s] += i * e[n][s]
        }
        return s
    }
    , null)
}
function MV(e) {
    const t = {};
    for (const [r,n] of Object.entries(e))
        n !== 0 && (t[r] = n);
    return t
}
class Me {
    constructor(t) {
        const r = t.conversionAccuracy === "longterm" || !1;
        let n = r ? RV : IV;
        t.matrix && (n = t.matrix),
        this.values = t.values,
        this.loc = t.loc || We.create(),
        this.conversionAccuracy = r ? "longterm" : "casual",
        this.invalid = t.invalid || null,
        this.matrix = n,
        this.isLuxonDuration = !0
    }
    static fromMillis(t, r) {
        return Me.fromObject({
            milliseconds: t
        }, r)
    }
    static fromObject(t, r={}) {
        if (t == null || typeof t != "object")
            throw new Xt(`Duration.fromObject: argument expected to be an object, got ${t === null ? "null" : typeof t}`);
        return new Me({
            values: Cf(t, Me.normalizeUnit),
            loc: We.fromObject(r),
            conversionAccuracy: r.conversionAccuracy,
            matrix: r.matrix
        })
    }
    static fromDurationLike(t) {
        if (oi(t))
            return Me.fromMillis(t);
        if (Me.isDuration(t))
            return t;
        if (typeof t == "object")
            return Me.fromObject(t);
        throw new Xt(`Unknown duration argument ${t} of type ${typeof t}`)
    }
    static fromISO(t, r) {
        const [n] = _V(t);
        return n ? Me.fromObject(n, r) : Me.invalid("unparsable", `the input "${t}" can't be parsed as ISO 8601`)
    }
    static fromISOTime(t, r) {
        const [n] = CV(t);
        return n ? Me.fromObject(n, r) : Me.invalid("unparsable", `the input "${t}" can't be parsed as ISO 8601`)
    }
    static invalid(t, r=null) {
        if (!t)
            throw new Xt("need to specify a reason the Duration is invalid");
        const n = t instanceof gn ? t : new gn(t,r);
        if (vt.throwOnInvalid)
            throw new iU(n);
        return new Me({
            invalid: n
        })
    }
    static normalizeUnit(t) {
        const r = {
            year: "years",
            years: "years",
            quarter: "quarters",
            quarters: "quarters",
            month: "months",
            months: "months",
            week: "weeks",
            weeks: "weeks",
            day: "days",
            days: "days",
            hour: "hours",
            hours: "hours",
            minute: "minutes",
            minutes: "minutes",
            second: "seconds",
            seconds: "seconds",
            millisecond: "milliseconds",
            milliseconds: "milliseconds"
        }[t && t.toLowerCase()];
        if (!r)
            throw new fE(t);
        return r
    }
    static isDuration(t) {
        return t && t.isLuxonDuration || !1
    }
    get locale() {
        return this.isValid ? this.loc.locale : null
    }
    get numberingSystem() {
        return this.isValid ? this.loc.numberingSystem : null
    }
    toFormat(t, r={}) {
        const n = {
            ...r,
            floor: r.round !== !1 && r.floor !== !1
        };
        return this.isValid ? rr.create(this.loc, n).formatDurationFromString(this, t) : Hx
    }
    toHuman(t={}) {
        if (!this.isValid)
            return Hx;
        const r = Vi.map(n => {
            const s = this.values[n];
            return we(s) ? null : this.loc.numberFormatter({
                style: "unit",
                unitDisplay: "long",
                ...t,
                unit: n.slice(0, -1)
            }).format(s)
        }
        ).filter(n => n);
        return this.loc.listFormatter({
            type: "conjunction",
            style: t.listStyle || "narrow",
            ...t
        }).format(r)
    }
    toObject() {
        return this.isValid ? {
            ...this.values
        } : {}
    }
    toISO() {
        if (!this.isValid)
            return null;
        let t = "P";
        return this.years !== 0 && (t += this.years + "Y"),
        (this.months !== 0 || this.quarters !== 0) && (t += this.months + this.quarters * 3 + "M"),
        this.weeks !== 0 && (t += this.weeks + "W"),
        this.days !== 0 && (t += this.days + "D"),
        (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0) && (t += "T"),
        this.hours !== 0 && (t += this.hours + "H"),
        this.minutes !== 0 && (t += this.minutes + "M"),
        (this.seconds !== 0 || this.milliseconds !== 0) && (t += mv(this.seconds + this.milliseconds / 1e3, 3) + "S"),
        t === "P" && (t += "T0S"),
        t
    }
    toISOTime(t={}) {
        if (!this.isValid)
            return null;
        const r = this.toMillis();
        return r < 0 || r >= 864e5 ? null : (t = {
            suppressMilliseconds: !1,
            suppressSeconds: !1,
            includePrefix: !1,
            format: "extended",
            ...t,
            includeOffset: !1
        },
        xe.fromMillis(r, {
            zone: "UTC"
        }).toISOTime(t))
    }
    toJSON() {
        return this.toISO()
    }
    toString() {
        return this.toISO()
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
        return this.isValid ? `Duration { values: ${JSON.stringify(this.values)} }` : `Duration { Invalid, reason: ${this.invalidReason} }`
    }
    toMillis() {
        return this.isValid ? r_(this.matrix, this.values) : NaN
    }
    valueOf() {
        return this.toMillis()
    }
    plus(t) {
        if (!this.isValid)
            return this;
        const r = Me.fromDurationLike(t)
          , n = {};
        for (const s of Vi)
            (zo(r.values, s) || zo(this.values, s)) && (n[s] = r.get(s) + this.get(s));
        return Ts(this, {
            values: n
        }, !0)
    }
    minus(t) {
        if (!this.isValid)
            return this;
        const r = Me.fromDurationLike(t);
        return this.plus(r.negate())
    }
    mapUnits(t) {
        if (!this.isValid)
            return this;
        const r = {};
        for (const n of Object.keys(this.values))
            r[n] = UE(t(this.values[n], n));
        return Ts(this, {
            values: r
        }, !0)
    }
    get(t) {
        return this[Me.normalizeUnit(t)]
    }
    set(t) {
        if (!this.isValid)
            return this;
        const r = {
            ...this.values,
            ...Cf(t, Me.normalizeUnit)
        };
        return Ts(this, {
            values: r
        })
    }
    reconfigure({locale: t, numberingSystem: r, conversionAccuracy: n, matrix: s}={}) {
        const a = {
            loc: this.loc.clone({
                locale: t,
                numberingSystem: r
            }),
            matrix: s,
            conversionAccuracy: n
        };
        return Ts(this, a)
    }
    as(t) {
        return this.isValid ? this.shiftTo(t).get(t) : NaN
    }
    normalize() {
        if (!this.isValid)
            return this;
        const t = this.toObject();
        return Zx(this.matrix, t),
        Ts(this, {
            values: t
        }, !0)
    }
    rescale() {
        if (!this.isValid)
            return this;
        const t = MV(this.normalize().shiftToAll().toObject());
        return Ts(this, {
            values: t
        }, !0)
    }
    shiftTo(...t) {
        if (!this.isValid)
            return this;
        if (t.length === 0)
            return this;
        t = t.map(a => Me.normalizeUnit(a));
        const r = {}
          , n = {}
          , s = this.toObject();
        let i;
        for (const a of Vi)
            if (t.indexOf(a) >= 0) {
                i = a;
                let o = 0;
                for (const c in n)
                    o += this.matrix[c][a] * n[c],
                    n[c] = 0;
                oi(s[a]) && (o += s[a]);
                const l = Math.trunc(o);
                r[a] = l,
                n[a] = (o * 1e3 - l * 1e3) / 1e3
            } else
                oi(s[a]) && (n[a] = s[a]);
        for (const a in n)
            n[a] !== 0 && (r[i] += a === i ? n[a] : n[a] / this.matrix[i][a]);
        return Zx(this.matrix, r),
        Ts(this, {
            values: r
        }, !0)
    }
    shiftToAll() {
        return this.isValid ? this.shiftTo("years", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds") : this
    }
    negate() {
        if (!this.isValid)
            return this;
        const t = {};
        for (const r of Object.keys(this.values))
            t[r] = this.values[r] === 0 ? 0 : -this.values[r];
        return Ts(this, {
            values: t
        }, !0)
    }
    get years() {
        return this.isValid ? this.values.years || 0 : NaN
    }
    get quarters() {
        return this.isValid ? this.values.quarters || 0 : NaN
    }
    get months() {
        return this.isValid ? this.values.months || 0 : NaN
    }
    get weeks() {
        return this.isValid ? this.values.weeks || 0 : NaN
    }
    get days() {
        return this.isValid ? this.values.days || 0 : NaN
    }
    get hours() {
        return this.isValid ? this.values.hours || 0 : NaN
    }
    get minutes() {
        return this.isValid ? this.values.minutes || 0 : NaN
    }
    get seconds() {
        return this.isValid ? this.values.seconds || 0 : NaN
    }
    get milliseconds() {
        return this.isValid ? this.values.milliseconds || 0 : NaN
    }
    get isValid() {
        return this.invalid === null
    }
    get invalidReason() {
        return this.invalid ? this.invalid.reason : null
    }
    get invalidExplanation() {
        return this.invalid ? this.invalid.explanation : null
    }
    equals(t) {
        if (!this.isValid || !t.isValid || !this.loc.equals(t.loc))
            return !1;
        function r(n, s) {
            return n === void 0 || n === 0 ? s === void 0 || s === 0 : n === s
        }
        for (const n of Vi)
            if (!r(this.values[n], t.values[n]))
                return !1;
        return !0
    }
}
const Ia = "Invalid Interval";
function AV(e, t) {
    return !e || !e.isValid ? gt.invalid("missing or invalid start") : !t || !t.isValid ? gt.invalid("missing or invalid end") : t < e ? gt.invalid("end before start", `The end of an interval must be after its start, but you had start=${e.toISO()} and end=${t.toISO()}`) : null
}
class gt {
    constructor(t) {
        this.s = t.start,
        this.e = t.end,
        this.invalid = t.invalid || null,
        this.isLuxonInterval = !0
    }
    static invalid(t, r=null) {
        if (!t)
            throw new Xt("need to specify a reason the Interval is invalid");
        const n = t instanceof gn ? t : new gn(t,r);
        if (vt.throwOnInvalid)
            throw new sU(n);
        return new gt({
            invalid: n
        })
    }
    static fromDateTimes(t, r) {
        const n = _l(t)
          , s = _l(r)
          , i = AV(n, s);
        return i ?? new gt({
            start: n,
            end: s
        })
    }
    static after(t, r) {
        const n = Me.fromDurationLike(r)
          , s = _l(t);
        return gt.fromDateTimes(s, s.plus(n))
    }
    static before(t, r) {
        const n = Me.fromDurationLike(r)
          , s = _l(t);
        return gt.fromDateTimes(s.minus(n), s)
    }
    static fromISO(t, r) {
        const [n,s] = (t || "").split("/", 2);
        if (n && s) {
            let i, a;
            try {
                i = xe.fromISO(n, r),
                a = i.isValid
            } catch {
                a = !1
            }
            let o, l;
            try {
                o = xe.fromISO(s, r),
                l = o.isValid
            } catch {
                l = !1
            }
            if (a && l)
                return gt.fromDateTimes(i, o);
            if (a) {
                const c = Me.fromISO(s, r);
                if (c.isValid)
                    return gt.after(i, c)
            } else if (l) {
                const c = Me.fromISO(n, r);
                if (c.isValid)
                    return gt.before(o, c)
            }
        }
        return gt.invalid("unparsable", `the input "${t}" can't be parsed as ISO 8601`)
    }
    static isInterval(t) {
        return t && t.isLuxonInterval || !1
    }
    get start() {
        return this.isValid ? this.s : null
    }
    get end() {
        return this.isValid ? this.e : null
    }
    get isValid() {
        return this.invalidReason === null
    }
    get invalidReason() {
        return this.invalid ? this.invalid.reason : null
    }
    get invalidExplanation() {
        return this.invalid ? this.invalid.explanation : null
    }
    length(t="milliseconds") {
        return this.isValid ? this.toDuration(t).get(t) : NaN
    }
    count(t="milliseconds", r) {
        if (!this.isValid)
            return NaN;
        const n = this.start.startOf(t, r);
        let s;
        return r != null && r.useLocaleWeeks ? s = this.end.reconfigure({
            locale: n.locale
        }) : s = this.end,
        s = s.startOf(t, r),
        Math.floor(s.diff(n, t).get(t)) + (s.valueOf() !== this.end.valueOf())
    }
    hasSame(t) {
        return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, t) : !1
    }
    isEmpty() {
        return this.s.valueOf() === this.e.valueOf()
    }
    isAfter(t) {
        return this.isValid ? this.s > t : !1
    }
    isBefore(t) {
        return this.isValid ? this.e <= t : !1
    }
    contains(t) {
        return this.isValid ? this.s <= t && this.e > t : !1
    }
    set({start: t, end: r}={}) {
        return this.isValid ? gt.fromDateTimes(t || this.s, r || this.e) : this
    }
    splitAt(...t) {
        if (!this.isValid)
            return [];
        const r = t.map(_l).filter(a => this.contains(a)).sort( (a, o) => a.toMillis() - o.toMillis())
          , n = [];
        let {s} = this
          , i = 0;
        for (; s < this.e; ) {
            const a = r[i] || this.e
              , o = +a > +this.e ? this.e : a;
            n.push(gt.fromDateTimes(s, o)),
            s = o,
            i += 1
        }
        return n
    }
    splitBy(t) {
        const r = Me.fromDurationLike(t);
        if (!this.isValid || !r.isValid || r.as("milliseconds") === 0)
            return [];
        let {s: n} = this, s = 1, i;
        const a = [];
        for (; n < this.e; ) {
            const o = this.start.plus(r.mapUnits(l => l * s));
            i = +o > +this.e ? this.e : o,
            a.push(gt.fromDateTimes(n, i)),
            n = i,
            s += 1
        }
        return a
    }
    divideEqually(t) {
        return this.isValid ? this.splitBy(this.length() / t).slice(0, t) : []
    }
    overlaps(t) {
        return this.e > t.s && this.s < t.e
    }
    abutsStart(t) {
        return this.isValid ? +this.e == +t.s : !1
    }
    abutsEnd(t) {
        return this.isValid ? +t.e == +this.s : !1
    }
    engulfs(t) {
        return this.isValid ? this.s <= t.s && this.e >= t.e : !1
    }
    equals(t) {
        return !this.isValid || !t.isValid ? !1 : this.s.equals(t.s) && this.e.equals(t.e)
    }
    intersection(t) {
        if (!this.isValid)
            return this;
        const r = this.s > t.s ? this.s : t.s
          , n = this.e < t.e ? this.e : t.e;
        return r >= n ? null : gt.fromDateTimes(r, n)
    }
    union(t) {
        if (!this.isValid)
            return this;
        const r = this.s < t.s ? this.s : t.s
          , n = this.e > t.e ? this.e : t.e;
        return gt.fromDateTimes(r, n)
    }
    static merge(t) {
        const [r,n] = t.sort( (s, i) => s.s - i.s).reduce( ([s,i], a) => i ? i.overlaps(a) || i.abutsStart(a) ? [s, i.union(a)] : [s.concat([i]), a] : [s, a], [[], null]);
        return n && r.push(n),
        r
    }
    static xor(t) {
        let r = null
          , n = 0;
        const s = []
          , i = t.map(l => [{
            time: l.s,
            type: "s"
        }, {
            time: l.e,
            type: "e"
        }])
          , a = Array.prototype.concat(...i)
          , o = a.sort( (l, c) => l.time - c.time);
        for (const l of o)
            n += l.type === "s" ? 1 : -1,
            n === 1 ? r = l.time : (r && +r != +l.time && s.push(gt.fromDateTimes(r, l.time)),
            r = null);
        return gt.merge(s)
    }
    difference(...t) {
        return gt.xor([this].concat(t)).map(r => this.intersection(r)).filter(r => r && !r.isEmpty())
    }
    toString() {
        return this.isValid ? `[${this.s.toISO()}  ${this.e.toISO()})` : Ia
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
        return this.isValid ? `Interval { start: ${this.s.toISO()}, end: ${this.e.toISO()} }` : `Interval { Invalid, reason: ${this.invalidReason} }`
    }
    toLocaleString(t=Ef, r={}) {
        return this.isValid ? rr.create(this.s.loc.clone(r), t).formatInterval(this) : Ia
    }
    toISO(t) {
        return this.isValid ? `${this.s.toISO(t)}/${this.e.toISO(t)}` : Ia
    }
    toISODate() {
        return this.isValid ? `${this.s.toISODate()}/${this.e.toISODate()}` : Ia
    }
    toISOTime(t) {
        return this.isValid ? `${this.s.toISOTime(t)}/${this.e.toISOTime(t)}` : Ia
    }
    toFormat(t, {separator: r="  "}={}) {
        return this.isValid ? `${this.s.toFormat(t)}${r}${this.e.toFormat(t)}` : Ia
    }
    toDuration(t, r) {
        return this.isValid ? this.e.diff(this.s, t, r) : Me.invalid(this.invalidReason)
    }
    mapEndpoints(t) {
        return gt.fromDateTimes(t(this.s), t(this.e))
    }
}
class Jc {
    static hasDST(t=vt.defaultZone) {
        const r = xe.now().setZone(t).set({
            month: 12
        });
        return !t.isUniversal && r.offset !== r.set({
            month: 6
        }).offset
    }
    static isValidIANAZone(t) {
        return ps.isValidZone(t)
    }
    static normalizeZone(t) {
        return Ls(t, vt.defaultZone)
    }
    static getStartOfWeek({locale: t=null, locObj: r=null}={}) {
        return (r || We.create(t)).getStartOfWeek()
    }
    static getMinimumDaysInFirstWeek({locale: t=null, locObj: r=null}={}) {
        return (r || We.create(t)).getMinDaysInFirstWeek()
    }
    static getWeekendWeekdays({locale: t=null, locObj: r=null}={}) {
        return (r || We.create(t)).getWeekendDays().slice()
    }
    static months(t="long", {locale: r=null, numberingSystem: n=null, locObj: s=null, outputCalendar: i="gregory"}={}) {
        return (s || We.create(r, n, i)).months(t)
    }
    static monthsFormat(t="long", {locale: r=null, numberingSystem: n=null, locObj: s=null, outputCalendar: i="gregory"}={}) {
        return (s || We.create(r, n, i)).months(t, !0)
    }
    static weekdays(t="long", {locale: r=null, numberingSystem: n=null, locObj: s=null}={}) {
        return (s || We.create(r, n, null)).weekdays(t)
    }
    static weekdaysFormat(t="long", {locale: r=null, numberingSystem: n=null, locObj: s=null}={}) {
        return (s || We.create(r, n, null)).weekdays(t, !0)
    }
    static meridiems({locale: t=null}={}) {
        return We.create(t).meridiems()
    }
    static eras(t="short", {locale: r=null}={}) {
        return We.create(r, null, "gregory").eras(t)
    }
    static features() {
        return {
            relative: DE(),
            localeWeek: FE()
        }
    }
}
function Kx(e, t) {
    const r = s => s.toUTC(0, {
        keepLocalTime: !0
    }).startOf("day").valueOf()
      , n = r(t) - r(e);
    return Math.floor(Me.fromMillis(n).as("days"))
}
function LV(e, t, r) {
    const n = [["years", (l, c) => c.year - l.year], ["quarters", (l, c) => c.quarter - l.quarter + (c.year - l.year) * 4], ["months", (l, c) => c.month - l.month + (c.year - l.year) * 12], ["weeks", (l, c) => {
        const f = Kx(l, c);
        return (f - f % 7) / 7
    }
    ], ["days", Kx]]
      , s = {}
      , i = e;
    let a, o;
    for (const [l,c] of n)
        r.indexOf(l) >= 0 && (a = l,
        s[l] = c(e, t),
        o = i.plus(s),
        o > t ? (s[l]--,
        e = i.plus(s),
        e > t && (o = e,
        s[l]--,
        e = i.plus(s))) : e = o);
    return [e, s, o, a]
}
function DV(e, t, r, n) {
    let[s,i,a,o] = LV(e, t, r);
    const l = t - s
      , c = r.filter(h => ["hours", "minutes", "seconds", "milliseconds"].indexOf(h) >= 0);
    c.length === 0 && (a < t && (a = s.plus({
        [o]: 1
    })),
    a !== s && (i[o] = (i[o] || 0) + l / (a - s)));
    const f = Me.fromObject(i, n);
    return c.length > 0 ? Me.fromMillis(l, n).shiftTo(...c).plus(f) : f
}
const FV = "missing Intl.DateTimeFormat.formatToParts support";
function Ue(e, t=r => r) {
    return {
        regex: e,
        deser: ([r]) => t(PU(r))
    }
}
const zV = ""
  , n_ = `[ ${zV}]`
  , s_ = new RegExp(n_,"g");
function UV(e) {
    return e.replace(/\./g, "\\.?").replace(s_, n_)
}
function Qx(e) {
    return e.replace(/\./g, "").replace(s_, " ").toLowerCase()
}
function on(e, t) {
    return e === null ? null : {
        regex: RegExp(e.map(UV).join("|")),
        deser: ([r]) => e.findIndex(n => Qx(r) === Qx(n)) + t
    }
}
function Gx(e, t) {
    return {
        regex: e,
        deser: ([,r,n]) => gh(r, n),
        groups: t
    }
}
function Xc(e) {
    return {
        regex: e,
        deser: ([t]) => t
    }
}
function VV(e) {
    return e.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&")
}
function BV(e, t) {
    const r = an(t)
      , n = an(t, "{2}")
      , s = an(t, "{3}")
      , i = an(t, "{4}")
      , a = an(t, "{6}")
      , o = an(t, "{1,2}")
      , l = an(t, "{1,3}")
      , c = an(t, "{1,6}")
      , f = an(t, "{1,9}")
      , h = an(t, "{2,4}")
      , m = an(t, "{4,6}")
      , y = w => ({
        regex: RegExp(VV(w.val)),
        deser: ([v]) => v,
        literal: !0
    })
      , x = (w => {
        if (e.literal)
            return y(w);
        switch (w.val) {
        case "G":
            return on(t.eras("short"), 0);
        case "GG":
            return on(t.eras("long"), 0);
        case "y":
            return Ue(c);
        case "yy":
            return Ue(h, my);
        case "yyyy":
            return Ue(i);
        case "yyyyy":
            return Ue(m);
        case "yyyyyy":
            return Ue(a);
        case "M":
            return Ue(o);
        case "MM":
            return Ue(n);
        case "MMM":
            return on(t.months("short", !0), 1);
        case "MMMM":
            return on(t.months("long", !0), 1);
        case "L":
            return Ue(o);
        case "LL":
            return Ue(n);
        case "LLL":
            return on(t.months("short", !1), 1);
        case "LLLL":
            return on(t.months("long", !1), 1);
        case "d":
            return Ue(o);
        case "dd":
            return Ue(n);
        case "o":
            return Ue(l);
        case "ooo":
            return Ue(s);
        case "HH":
            return Ue(n);
        case "H":
            return Ue(o);
        case "hh":
            return Ue(n);
        case "h":
            return Ue(o);
        case "mm":
            return Ue(n);
        case "m":
            return Ue(o);
        case "q":
            return Ue(o);
        case "qq":
            return Ue(n);
        case "s":
            return Ue(o);
        case "ss":
            return Ue(n);
        case "S":
            return Ue(l);
        case "SSS":
            return Ue(s);
        case "u":
            return Xc(f);
        case "uu":
            return Xc(o);
        case "uuu":
            return Ue(r);
        case "a":
            return on(t.meridiems(), 0);
        case "kkkk":
            return Ue(i);
        case "kk":
            return Ue(h, my);
        case "W":
            return Ue(o);
        case "WW":
            return Ue(n);
        case "E":
        case "c":
            return Ue(r);
        case "EEE":
            return on(t.weekdays("short", !1), 1);
        case "EEEE":
            return on(t.weekdays("long", !1), 1);
        case "ccc":
            return on(t.weekdays("short", !0), 1);
        case "cccc":
            return on(t.weekdays("long", !0), 1);
        case "Z":
        case "ZZ":
            return Gx(new RegExp(`([+-]${o.source})(?::(${n.source}))?`), 2);
        case "ZZZ":
            return Gx(new RegExp(`([+-]${o.source})(${n.source})?`), 2);
        case "z":
            return Xc(/[a-z_+-/]{1,256}?/i);
        case " ":
            return Xc(/[^\S\n\r]/);
        default:
            return y(w)
        }
    }
    )(e) || {
        invalidReason: FV
    };
    return x.token = e,
    x
}
const WV = {
    year: {
        "2-digit": "yy",
        numeric: "yyyyy"
    },
    month: {
        numeric: "M",
        "2-digit": "MM",
        short: "MMM",
        long: "MMMM"
    },
    day: {
        numeric: "d",
        "2-digit": "dd"
    },
    weekday: {
        short: "EEE",
        long: "EEEE"
    },
    dayperiod: "a",
    dayPeriod: "a",
    hour12: {
        numeric: "h",
        "2-digit": "hh"
    },
    hour24: {
        numeric: "H",
        "2-digit": "HH"
    },
    minute: {
        numeric: "m",
        "2-digit": "mm"
    },
    second: {
        numeric: "s",
        "2-digit": "ss"
    },
    timeZoneName: {
        long: "ZZZZZ",
        short: "ZZZ"
    }
};
function qV(e, t, r) {
    const {type: n, value: s} = e;
    if (n === "literal") {
        const l = /^\s+$/.test(s);
        return {
            literal: !l,
            val: l ? " " : s
        }
    }
    const i = t[n];
    let a = n;
    n === "hour" && (t.hour12 != null ? a = t.hour12 ? "hour12" : "hour24" : t.hourCycle != null ? t.hourCycle === "h11" || t.hourCycle === "h12" ? a = "hour12" : a = "hour24" : a = r.hour12 ? "hour12" : "hour24");
    let o = WV[a];
    if (typeof o == "object" && (o = o[i]),
    o)
        return {
            literal: !1,
            val: o
        }
}
function HV(e) {
    return [`^${e.map(r => r.regex).reduce( (r, n) => `${r}(${n.source})`, "")}$`, e]
}
function ZV(e, t, r) {
    const n = e.match(t);
    if (n) {
        const s = {};
        let i = 1;
        for (const a in r)
            if (zo(r, a)) {
                const o = r[a]
                  , l = o.groups ? o.groups + 1 : 1;
                !o.literal && o.token && (s[o.token.val[0]] = o.deser(n.slice(i, i + l))),
                i += l
            }
        return [n, s]
    } else
        return [n, {}]
}
function KV(e) {
    const t = i => {
        switch (i) {
        case "S":
            return "millisecond";
        case "s":
            return "second";
        case "m":
            return "minute";
        case "h":
        case "H":
            return "hour";
        case "d":
            return "day";
        case "o":
            return "ordinal";
        case "L":
        case "M":
            return "month";
        case "y":
            return "year";
        case "E":
        case "c":
            return "weekday";
        case "W":
            return "weekNumber";
        case "k":
            return "weekYear";
        case "q":
            return "quarter";
        default:
            return null
        }
    }
    ;
    let r = null, n;
    return we(e.z) || (r = ps.create(e.z)),
    we(e.Z) || (r || (r = new mr(e.Z)),
    n = e.Z),
    we(e.q) || (e.M = (e.q - 1) * 3 + 1),
    we(e.h) || (e.h < 12 && e.a === 1 ? e.h += 12 : e.h === 12 && e.a === 0 && (e.h = 0)),
    e.G === 0 && e.y && (e.y = -e.y),
    we(e.u) || (e.S = hv(e.u)),
    [Object.keys(e).reduce( (i, a) => {
        const o = t(a);
        return o && (i[o] = e[a]),
        i
    }
    , {}), r, n]
}
let pm = null;
function QV() {
    return pm || (pm = xe.fromMillis(1555555555555)),
    pm
}
function GV(e, t) {
    if (e.literal)
        return e;
    const r = rr.macroTokenToFormatOpts(e.val)
      , n = l_(r, t);
    return n == null || n.includes(void 0) ? e : n
}
function i_(e, t) {
    return Array.prototype.concat(...e.map(r => GV(r, t)))
}
class a_ {
    constructor(t, r) {
        if (this.locale = t,
        this.format = r,
        this.tokens = i_(rr.parseFormat(r), t),
        this.units = this.tokens.map(n => BV(n, t)),
        this.disqualifyingUnit = this.units.find(n => n.invalidReason),
        !this.disqualifyingUnit) {
            const [n,s] = HV(this.units);
            this.regex = RegExp(n, "i"),
            this.handlers = s
        }
    }
    explainFromTokens(t) {
        if (this.isValid) {
            const [r,n] = ZV(t, this.regex, this.handlers)
              , [s,i,a] = n ? KV(n) : [null, null, void 0];
            if (zo(n, "a") && zo(n, "H"))
                throw new to("Can't include meridiem when specifying 24-hour format");
            return {
                input: t,
                tokens: this.tokens,
                regex: this.regex,
                rawMatches: r,
                matches: n,
                result: s,
                zone: i,
                specificOffset: a
            }
        } else
            return {
                input: t,
                tokens: this.tokens,
                invalidReason: this.invalidReason
            }
    }
    get isValid() {
        return !this.disqualifyingUnit
    }
    get invalidReason() {
        return this.disqualifyingUnit ? this.disqualifyingUnit.invalidReason : null
    }
}
function o_(e, t, r) {
    return new a_(e,r).explainFromTokens(t)
}
function YV(e, t, r) {
    const {result: n, zone: s, specificOffset: i, invalidReason: a} = o_(e, t, r);
    return [n, s, i, a]
}
function l_(e, t) {
    if (!e)
        return null;
    const n = rr.create(t, e).dtFormatter(QV())
      , s = n.formatToParts()
      , i = n.resolvedOptions();
    return s.map(a => qV(a, e, i))
}
const ym = "Invalid DateTime"
  , JV = 864e13;
function Fl(e) {
    return new gn("unsupported zone",`the zone "${e.name}" is not supported`)
}
function gm(e) {
    return e.weekData === null && (e.weekData = _f(e.c)),
    e.weekData
}
function vm(e) {
    return e.localWeekData === null && (e.localWeekData = _f(e.c, e.loc.getMinDaysInFirstWeek(), e.loc.getStartOfWeek())),
    e.localWeekData
}
function Ni(e, t) {
    const r = {
        ts: e.ts,
        zone: e.zone,
        c: e.c,
        o: e.o,
        loc: e.loc,
        invalid: e.invalid
    };
    return new xe({
        ...r,
        ...t,
        old: r
    })
}
function u_(e, t, r) {
    let n = e - t * 60 * 1e3;
    const s = r.offset(n);
    if (t === s)
        return [n, t];
    n -= (s - t) * 60 * 1e3;
    const i = r.offset(n);
    return s === i ? [n, s] : [e - Math.min(s, i) * 60 * 1e3, Math.max(s, i)]
}
function ed(e, t) {
    e += t * 60 * 1e3;
    const r = new Date(e);
    return {
        year: r.getUTCFullYear(),
        month: r.getUTCMonth() + 1,
        day: r.getUTCDate(),
        hour: r.getUTCHours(),
        minute: r.getUTCMinutes(),
        second: r.getUTCSeconds(),
        millisecond: r.getUTCMilliseconds()
    }
}
function wd(e, t, r) {
    return u_(yh(e), t, r)
}
function Yx(e, t) {
    const r = e.o
      , n = e.c.year + Math.trunc(t.years)
      , s = e.c.month + Math.trunc(t.months) + Math.trunc(t.quarters) * 3
      , i = {
        ...e.c,
        year: n,
        month: s,
        day: Math.min(e.c.day, Tf(n, s)) + Math.trunc(t.days) + Math.trunc(t.weeks) * 7
    }
      , a = Me.fromObject({
        years: t.years - Math.trunc(t.years),
        quarters: t.quarters - Math.trunc(t.quarters),
        months: t.months - Math.trunc(t.months),
        weeks: t.weeks - Math.trunc(t.weeks),
        days: t.days - Math.trunc(t.days),
        hours: t.hours,
        minutes: t.minutes,
        seconds: t.seconds,
        milliseconds: t.milliseconds
    }).as("milliseconds")
      , o = yh(i);
    let[l,c] = u_(o, r, e.zone);
    return a !== 0 && (l += a,
    c = e.zone.offset(l)),
    {
        ts: l,
        o: c
    }
}
function Ra(e, t, r, n, s, i) {
    const {setZone: a, zone: o} = r;
    if (e && Object.keys(e).length !== 0 || t) {
        const l = t || o
          , c = xe.fromObject(e, {
            ...r,
            zone: l,
            specificOffset: i
        });
        return a ? c : c.setZone(o)
    } else
        return xe.invalid(new gn("unparsable",`the input "${s}" can't be parsed as ${n}`))
}
function td(e, t, r=!0) {
    return e.isValid ? rr.create(We.create("en-US"), {
        allowZ: r,
        forceSimple: !0
    }).formatDateTimeFromString(e, t) : null
}
function bm(e, t) {
    const r = e.c.year > 9999 || e.c.year < 0;
    let n = "";
    return r && e.c.year >= 0 && (n += "+"),
    n += $t(e.c.year, r ? 6 : 4),
    t ? (n += "-",
    n += $t(e.c.month),
    n += "-",
    n += $t(e.c.day)) : (n += $t(e.c.month),
    n += $t(e.c.day)),
    n
}
function Jx(e, t, r, n, s, i) {
    let a = $t(e.c.hour);
    return t ? (a += ":",
    a += $t(e.c.minute),
    (e.c.millisecond !== 0 || e.c.second !== 0 || !r) && (a += ":")) : a += $t(e.c.minute),
    (e.c.millisecond !== 0 || e.c.second !== 0 || !r) && (a += $t(e.c.second),
    (e.c.millisecond !== 0 || !n) && (a += ".",
    a += $t(e.c.millisecond, 3))),
    s && (e.isOffsetFixed && e.offset === 0 && !i ? a += "Z" : e.o < 0 ? (a += "-",
    a += $t(Math.trunc(-e.o / 60)),
    a += ":",
    a += $t(Math.trunc(-e.o % 60))) : (a += "+",
    a += $t(Math.trunc(e.o / 60)),
    a += ":",
    a += $t(Math.trunc(e.o % 60)))),
    i && (a += "[" + e.zone.ianaName + "]"),
    a
}
const c_ = {
    month: 1,
    day: 1,
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0
}
  , XV = {
    weekNumber: 1,
    weekday: 1,
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0
}
  , eB = {
    ordinal: 1,
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0
}
  , d_ = ["year", "month", "day", "hour", "minute", "second", "millisecond"]
  , tB = ["weekYear", "weekNumber", "weekday", "hour", "minute", "second", "millisecond"]
  , rB = ["year", "ordinal", "hour", "minute", "second", "millisecond"];
function nB(e) {
    const t = {
        year: "year",
        years: "year",
        month: "month",
        months: "month",
        day: "day",
        days: "day",
        hour: "hour",
        hours: "hour",
        minute: "minute",
        minutes: "minute",
        quarter: "quarter",
        quarters: "quarter",
        second: "second",
        seconds: "second",
        millisecond: "millisecond",
        milliseconds: "millisecond",
        weekday: "weekday",
        weekdays: "weekday",
        weeknumber: "weekNumber",
        weeksnumber: "weekNumber",
        weeknumbers: "weekNumber",
        weekyear: "weekYear",
        weekyears: "weekYear",
        ordinal: "ordinal"
    }[e.toLowerCase()];
    if (!t)
        throw new fE(e);
    return t
}
function Xx(e) {
    switch (e.toLowerCase()) {
    case "localweekday":
    case "localweekdays":
        return "localWeekday";
    case "localweeknumber":
    case "localweeknumbers":
        return "localWeekNumber";
    case "localweekyear":
    case "localweekyears":
        return "localWeekYear";
    default:
        return nB(e)
    }
}
function sB(e) {
    return kd[e] || (Sd === void 0 && (Sd = vt.now()),
    kd[e] = e.offset(Sd)),
    kd[e]
}
function e1(e, t) {
    const r = Ls(t.zone, vt.defaultZone);
    if (!r.isValid)
        return xe.invalid(Fl(r));
    const n = We.fromObject(t);
    let s, i;
    if (we(e.year))
        s = vt.now();
    else {
        for (const l of d_)
            we(e[l]) && (e[l] = c_[l]);
        const a = AE(e) || LE(e);
        if (a)
            return xe.invalid(a);
        const o = sB(r);
        [s,i] = wd(e, o, r)
    }
    return new xe({
        ts: s,
        zone: r,
        loc: n,
        o: i
    })
}
function t1(e, t, r) {
    const n = we(r.round) ? !0 : r.round
      , s = (a, o) => (a = mv(a, n || r.calendary ? 0 : 2, !0),
    t.loc.clone(r).relFormatter(r).format(a, o))
      , i = a => r.calendary ? t.hasSame(e, a) ? 0 : t.startOf(a).diff(e.startOf(a), a).get(a) : t.diff(e, a).get(a);
    if (r.unit)
        return s(i(r.unit), r.unit);
    for (const a of r.units) {
        const o = i(a);
        if (Math.abs(o) >= 1)
            return s(o, a)
    }
    return s(e > t ? -0 : 0, r.units[r.units.length - 1])
}
function r1(e) {
    let t = {}, r;
    return e.length > 0 && typeof e[e.length - 1] == "object" ? (t = e[e.length - 1],
    r = Array.from(e).slice(0, e.length - 1)) : r = Array.from(e),
    [t, r]
}
let Sd, kd = {};
class xe {
    constructor(t) {
        const r = t.zone || vt.defaultZone;
        let n = t.invalid || (Number.isNaN(t.ts) ? new gn("invalid input") : null) || (r.isValid ? null : Fl(r));
        this.ts = we(t.ts) ? vt.now() : t.ts;
        let s = null
          , i = null;
        if (!n)
            if (t.old && t.old.ts === this.ts && t.old.zone.equals(r))
                [s,i] = [t.old.c, t.old.o];
            else {
                const o = oi(t.o) && !t.old ? t.o : r.offset(this.ts);
                s = ed(this.ts, o),
                n = Number.isNaN(s.year) ? new gn("invalid input") : null,
                s = n ? null : s,
                i = n ? null : o
            }
        this._zone = r,
        this.loc = t.loc || We.create(),
        this.invalid = n,
        this.weekData = null,
        this.localWeekData = null,
        this.c = s,
        this.o = i,
        this.isLuxonDateTime = !0
    }
    static now() {
        return new xe({})
    }
    static local() {
        const [t,r] = r1(arguments)
          , [n,s,i,a,o,l,c] = r;
        return e1({
            year: n,
            month: s,
            day: i,
            hour: a,
            minute: o,
            second: l,
            millisecond: c
        }, t)
    }
    static utc() {
        const [t,r] = r1(arguments)
          , [n,s,i,a,o,l,c] = r;
        return t.zone = mr.utcInstance,
        e1({
            year: n,
            month: s,
            day: i,
            hour: a,
            minute: o,
            second: l,
            millisecond: c
        }, t)
    }
    static fromJSDate(t, r={}) {
        const n = RU(t) ? t.valueOf() : NaN;
        if (Number.isNaN(n))
            return xe.invalid("invalid input");
        const s = Ls(r.zone, vt.defaultZone);
        return s.isValid ? new xe({
            ts: n,
            zone: s,
            loc: We.fromObject(r)
        }) : xe.invalid(Fl(s))
    }
    static fromMillis(t, r={}) {
        if (oi(t))
            return t < -864e13 || t > JV ? xe.invalid("Timestamp out of range") : new xe({
                ts: t,
                zone: Ls(r.zone, vt.defaultZone),
                loc: We.fromObject(r)
            });
        throw new Xt(`fromMillis requires a numerical input, but received a ${typeof t} with value ${t}`)
    }
    static fromSeconds(t, r={}) {
        if (oi(t))
            return new xe({
                ts: t * 1e3,
                zone: Ls(r.zone, vt.defaultZone),
                loc: We.fromObject(r)
            });
        throw new Xt("fromSeconds requires a numerical input")
    }
    static fromObject(t, r={}) {
        t = t || {};
        const n = Ls(r.zone, vt.defaultZone);
        if (!n.isValid)
            return xe.invalid(Fl(n));
        const s = We.fromObject(r)
          , i = Cf(t, Xx)
          , {minDaysInFirstWeek: a, startOfWeek: o} = Ux(i, s)
          , l = vt.now()
          , c = we(r.specificOffset) ? n.offset(l) : r.specificOffset
          , f = !we(i.ordinal)
          , h = !we(i.year)
          , m = !we(i.month) || !we(i.day)
          , y = h || m
          , k = i.weekYear || i.weekNumber;
        if ((y || f) && k)
            throw new to("Can't mix weekYear/weekNumber units with year/month/day or ordinals");
        if (m && f)
            throw new to("Can't mix ordinal dates with month/day");
        const x = k || i.weekday && !y;
        let w, v, p = ed(l, c);
        x ? (w = tB,
        v = XV,
        p = _f(p, a, o)) : f ? (w = rB,
        v = eB,
        p = mm(p)) : (w = d_,
        v = c_);
        let S = !1;
        for (const M of w) {
            const D = i[M];
            we(D) ? S ? i[M] = v[M] : i[M] = p[M] : S = !0
        }
        const P = x ? NU(i, a, o) : f ? jU(i) : AE(i)
          , j = P || LE(i);
        if (j)
            return xe.invalid(j);
        const L = x ? Fx(i, a, o) : f ? zx(i) : i
          , [E,b] = wd(L, c, n)
          , O = new xe({
            ts: E,
            zone: n,
            o: b,
            loc: s
        });
        return i.weekday && y && t.weekday !== O.weekday ? xe.invalid("mismatched weekday", `you can't specify both a weekday of ${i.weekday} and a date of ${O.toISO()}`) : O.isValid ? O : xe.invalid(O.invalid)
    }
    static fromISO(t, r={}) {
        const [n,s] = SV(t);
        return Ra(n, s, r, "ISO 8601", t)
    }
    static fromRFC2822(t, r={}) {
        const [n,s] = kV(t);
        return Ra(n, s, r, "RFC 2822", t)
    }
    static fromHTTP(t, r={}) {
        const [n,s] = EV(t);
        return Ra(n, s, r, "HTTP", r)
    }
    static fromFormat(t, r, n={}) {
        if (we(t) || we(r))
            throw new Xt("fromFormat requires an input string and a format");
        const {locale: s=null, numberingSystem: i=null} = n
          , a = We.fromOpts({
            locale: s,
            numberingSystem: i,
            defaultToEN: !0
        })
          , [o,l,c,f] = YV(a, t, r);
        return f ? xe.invalid(f) : Ra(o, l, n, `format ${r}`, t, c)
    }
    static fromString(t, r, n={}) {
        return xe.fromFormat(t, r, n)
    }
    static fromSQL(t, r={}) {
        const [n,s] = jV(t);
        return Ra(n, s, r, "SQL", t)
    }
    static invalid(t, r=null) {
        if (!t)
            throw new Xt("need to specify a reason the DateTime is invalid");
        const n = t instanceof gn ? t : new gn(t,r);
        if (vt.throwOnInvalid)
            throw new nU(n);
        return new xe({
            invalid: n
        })
    }
    static isDateTime(t) {
        return t && t.isLuxonDateTime || !1
    }
    static parseFormatForOpts(t, r={}) {
        const n = l_(t, We.fromObject(r));
        return n ? n.map(s => s ? s.val : null).join("") : null
    }
    static expandFormat(t, r={}) {
        return i_(rr.parseFormat(t), We.fromObject(r)).map(s => s.val).join("")
    }
    static resetCache() {
        Sd = void 0,
        kd = {}
    }
    get(t) {
        return this[t]
    }
    get isValid() {
        return this.invalid === null
    }
    get invalidReason() {
        return this.invalid ? this.invalid.reason : null
    }
    get invalidExplanation() {
        return this.invalid ? this.invalid.explanation : null
    }
    get locale() {
        return this.isValid ? this.loc.locale : null
    }
    get numberingSystem() {
        return this.isValid ? this.loc.numberingSystem : null
    }
    get outputCalendar() {
        return this.isValid ? this.loc.outputCalendar : null
    }
    get zone() {
        return this._zone
    }
    get zoneName() {
        return this.isValid ? this.zone.name : null
    }
    get year() {
        return this.isValid ? this.c.year : NaN
    }
    get quarter() {
        return this.isValid ? Math.ceil(this.c.month / 3) : NaN
    }
    get month() {
        return this.isValid ? this.c.month : NaN
    }
    get day() {
        return this.isValid ? this.c.day : NaN
    }
    get hour() {
        return this.isValid ? this.c.hour : NaN
    }
    get minute() {
        return this.isValid ? this.c.minute : NaN
    }
    get second() {
        return this.isValid ? this.c.second : NaN
    }
    get millisecond() {
        return this.isValid ? this.c.millisecond : NaN
    }
    get weekYear() {
        return this.isValid ? gm(this).weekYear : NaN
    }
    get weekNumber() {
        return this.isValid ? gm(this).weekNumber : NaN
    }
    get weekday() {
        return this.isValid ? gm(this).weekday : NaN
    }
    get isWeekend() {
        return this.isValid && this.loc.getWeekendDays().includes(this.weekday)
    }
    get localWeekday() {
        return this.isValid ? vm(this).weekday : NaN
    }
    get localWeekNumber() {
        return this.isValid ? vm(this).weekNumber : NaN
    }
    get localWeekYear() {
        return this.isValid ? vm(this).weekYear : NaN
    }
    get ordinal() {
        return this.isValid ? mm(this.c).ordinal : NaN
    }
    get monthShort() {
        return this.isValid ? Jc.months("short", {
            locObj: this.loc
        })[this.month - 1] : null
    }
    get monthLong() {
        return this.isValid ? Jc.months("long", {
            locObj: this.loc
        })[this.month - 1] : null
    }
    get weekdayShort() {
        return this.isValid ? Jc.weekdays("short", {
            locObj: this.loc
        })[this.weekday - 1] : null
    }
    get weekdayLong() {
        return this.isValid ? Jc.weekdays("long", {
            locObj: this.loc
        })[this.weekday - 1] : null
    }
    get offset() {
        return this.isValid ? +this.o : NaN
    }
    get offsetNameShort() {
        return this.isValid ? this.zone.offsetName(this.ts, {
            format: "short",
            locale: this.locale
        }) : null
    }
    get offsetNameLong() {
        return this.isValid ? this.zone.offsetName(this.ts, {
            format: "long",
            locale: this.locale
        }) : null
    }
    get isOffsetFixed() {
        return this.isValid ? this.zone.isUniversal : null
    }
    get isInDST() {
        return this.isOffsetFixed ? !1 : this.offset > this.set({
            month: 1,
            day: 1
        }).offset || this.offset > this.set({
            month: 5
        }).offset
    }
    getPossibleOffsets() {
        if (!this.isValid || this.isOffsetFixed)
            return [this];
        const t = 864e5
          , r = 6e4
          , n = yh(this.c)
          , s = this.zone.offset(n - t)
          , i = this.zone.offset(n + t)
          , a = this.zone.offset(n - s * r)
          , o = this.zone.offset(n - i * r);
        if (a === o)
            return [this];
        const l = n - a * r
          , c = n - o * r
          , f = ed(l, a)
          , h = ed(c, o);
        return f.hour === h.hour && f.minute === h.minute && f.second === h.second && f.millisecond === h.millisecond ? [Ni(this, {
            ts: l
        }), Ni(this, {
            ts: c
        })] : [this]
    }
    get isInLeapYear() {
        return oc(this.year)
    }
    get daysInMonth() {
        return Tf(this.year, this.month)
    }
    get daysInYear() {
        return this.isValid ? fo(this.year) : NaN
    }
    get weeksInWeekYear() {
        return this.isValid ? Du(this.weekYear) : NaN
    }
    get weeksInLocalWeekYear() {
        return this.isValid ? Du(this.localWeekYear, this.loc.getMinDaysInFirstWeek(), this.loc.getStartOfWeek()) : NaN
    }
    resolvedLocaleOptions(t={}) {
        const {locale: r, numberingSystem: n, calendar: s} = rr.create(this.loc.clone(t), t).resolvedOptions(this);
        return {
            locale: r,
            numberingSystem: n,
            outputCalendar: s
        }
    }
    toUTC(t=0, r={}) {
        return this.setZone(mr.instance(t), r)
    }
    toLocal() {
        return this.setZone(vt.defaultZone)
    }
    setZone(t, {keepLocalTime: r=!1, keepCalendarTime: n=!1}={}) {
        if (t = Ls(t, vt.defaultZone),
        t.equals(this.zone))
            return this;
        if (t.isValid) {
            let s = this.ts;
            if (r || n) {
                const i = t.offset(this.ts)
                  , a = this.toObject();
                [s] = wd(a, i, t)
            }
            return Ni(this, {
                ts: s,
                zone: t
            })
        } else
            return xe.invalid(Fl(t))
    }
    reconfigure({locale: t, numberingSystem: r, outputCalendar: n}={}) {
        const s = this.loc.clone({
            locale: t,
            numberingSystem: r,
            outputCalendar: n
        });
        return Ni(this, {
            loc: s
        })
    }
    setLocale(t) {
        return this.reconfigure({
            locale: t
        })
    }
    set(t) {
        if (!this.isValid)
            return this;
        const r = Cf(t, Xx)
          , {minDaysInFirstWeek: n, startOfWeek: s} = Ux(r, this.loc)
          , i = !we(r.weekYear) || !we(r.weekNumber) || !we(r.weekday)
          , a = !we(r.ordinal)
          , o = !we(r.year)
          , l = !we(r.month) || !we(r.day)
          , c = o || l
          , f = r.weekYear || r.weekNumber;
        if ((c || a) && f)
            throw new to("Can't mix weekYear/weekNumber units with year/month/day or ordinals");
        if (l && a)
            throw new to("Can't mix ordinal dates with month/day");
        let h;
        i ? h = Fx({
            ..._f(this.c, n, s),
            ...r
        }, n, s) : we(r.ordinal) ? (h = {
            ...this.toObject(),
            ...r
        },
        we(r.day) && (h.day = Math.min(Tf(h.year, h.month), h.day))) : h = zx({
            ...mm(this.c),
            ...r
        });
        const [m,y] = wd(h, this.o, this.zone);
        return Ni(this, {
            ts: m,
            o: y
        })
    }
    plus(t) {
        if (!this.isValid)
            return this;
        const r = Me.fromDurationLike(t);
        return Ni(this, Yx(this, r))
    }
    minus(t) {
        if (!this.isValid)
            return this;
        const r = Me.fromDurationLike(t).negate();
        return Ni(this, Yx(this, r))
    }
    startOf(t, {useLocaleWeeks: r=!1}={}) {
        if (!this.isValid)
            return this;
        const n = {}
          , s = Me.normalizeUnit(t);
        switch (s) {
        case "years":
            n.month = 1;
        case "quarters":
        case "months":
            n.day = 1;
        case "weeks":
        case "days":
            n.hour = 0;
        case "hours":
            n.minute = 0;
        case "minutes":
            n.second = 0;
        case "seconds":
            n.millisecond = 0;
            break
        }
        if (s === "weeks")
            if (r) {
                const i = this.loc.getStartOfWeek()
                  , {weekday: a} = this;
                a < i && (n.weekNumber = this.weekNumber - 1),
                n.weekday = i
            } else
                n.weekday = 1;
        if (s === "quarters") {
            const i = Math.ceil(this.month / 3);
            n.month = (i - 1) * 3 + 1
        }
        return this.set(n)
    }
    endOf(t, r) {
        return this.isValid ? this.plus({
            [t]: 1
        }).startOf(t, r).minus(1) : this
    }
    toFormat(t, r={}) {
        return this.isValid ? rr.create(this.loc.redefaultToEN(r)).formatDateTimeFromString(this, t) : ym
    }
    toLocaleString(t=Ef, r={}) {
        return this.isValid ? rr.create(this.loc.clone(r), t).formatDateTime(this) : ym
    }
    toLocaleParts(t={}) {
        return this.isValid ? rr.create(this.loc.clone(t), t).formatDateTimeParts(this) : []
    }
    toISO({format: t="extended", suppressSeconds: r=!1, suppressMilliseconds: n=!1, includeOffset: s=!0, extendedZone: i=!1}={}) {
        if (!this.isValid)
            return null;
        const a = t === "extended";
        let o = bm(this, a);
        return o += "T",
        o += Jx(this, a, r, n, s, i),
        o
    }
    toISODate({format: t="extended"}={}) {
        return this.isValid ? bm(this, t === "extended") : null
    }
    toISOWeekDate() {
        return td(this, "kkkk-'W'WW-c")
    }
    toISOTime({suppressMilliseconds: t=!1, suppressSeconds: r=!1, includeOffset: n=!0, includePrefix: s=!1, extendedZone: i=!1, format: a="extended"}={}) {
        return this.isValid ? (s ? "T" : "") + Jx(this, a === "extended", r, t, n, i) : null
    }
    toRFC2822() {
        return td(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", !1)
    }
    toHTTP() {
        return td(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'")
    }
    toSQLDate() {
        return this.isValid ? bm(this, !0) : null
    }
    toSQLTime({includeOffset: t=!0, includeZone: r=!1, includeOffsetSpace: n=!0}={}) {
        let s = "HH:mm:ss.SSS";
        return (r || t) && (n && (s += " "),
        r ? s += "z" : t && (s += "ZZ")),
        td(this, s, !0)
    }
    toSQL(t={}) {
        return this.isValid ? `${this.toSQLDate()} ${this.toSQLTime(t)}` : null
    }
    toString() {
        return this.isValid ? this.toISO() : ym
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
        return this.isValid ? `DateTime { ts: ${this.toISO()}, zone: ${this.zone.name}, locale: ${this.locale} }` : `DateTime { Invalid, reason: ${this.invalidReason} }`
    }
    valueOf() {
        return this.toMillis()
    }
    toMillis() {
        return this.isValid ? this.ts : NaN
    }
    toSeconds() {
        return this.isValid ? this.ts / 1e3 : NaN
    }
    toUnixInteger() {
        return this.isValid ? Math.floor(this.ts / 1e3) : NaN
    }
    toJSON() {
        return this.toISO()
    }
    toBSON() {
        return this.toJSDate()
    }
    toObject(t={}) {
        if (!this.isValid)
            return {};
        const r = {
            ...this.c
        };
        return t.includeConfig && (r.outputCalendar = this.outputCalendar,
        r.numberingSystem = this.loc.numberingSystem,
        r.locale = this.loc.locale),
        r
    }
    toJSDate() {
        return new Date(this.isValid ? this.ts : NaN)
    }
    diff(t, r="milliseconds", n={}) {
        if (!this.isValid || !t.isValid)
            return Me.invalid("created by diffing an invalid DateTime");
        const s = {
            locale: this.locale,
            numberingSystem: this.numberingSystem,
            ...n
        }
          , i = OU(r).map(Me.normalizeUnit)
          , a = t.valueOf() > this.valueOf()
          , o = a ? this : t
          , l = a ? t : this
          , c = DV(o, l, i, s);
        return a ? c.negate() : c
    }
    diffNow(t="milliseconds", r={}) {
        return this.diff(xe.now(), t, r)
    }
    until(t) {
        return this.isValid ? gt.fromDateTimes(this, t) : this
    }
    hasSame(t, r, n) {
        if (!this.isValid)
            return !1;
        const s = t.valueOf()
          , i = this.setZone(t.zone, {
            keepLocalTime: !0
        });
        return i.startOf(r, n) <= s && s <= i.endOf(r, n)
    }
    equals(t) {
        return this.isValid && t.isValid && this.valueOf() === t.valueOf() && this.zone.equals(t.zone) && this.loc.equals(t.loc)
    }
    toRelative(t={}) {
        if (!this.isValid)
            return null;
        const r = t.base || xe.fromObject({}, {
            zone: this.zone
        })
          , n = t.padding ? this < r ? -t.padding : t.padding : 0;
        let s = ["years", "months", "days", "hours", "minutes", "seconds"]
          , i = t.unit;
        return Array.isArray(t.unit) && (s = t.unit,
        i = void 0),
        t1(r, this.plus(n), {
            ...t,
            numeric: "always",
            units: s,
            unit: i
        })
    }
    toRelativeCalendar(t={}) {
        return this.isValid ? t1(t.base || xe.fromObject({}, {
            zone: this.zone
        }), this, {
            ...t,
            numeric: "auto",
            units: ["years", "months", "days"],
            calendary: !0
        }) : null
    }
    static min(...t) {
        if (!t.every(xe.isDateTime))
            throw new Xt("min requires all arguments be DateTimes");
        return Vx(t, r => r.valueOf(), Math.min)
    }
    static max(...t) {
        if (!t.every(xe.isDateTime))
            throw new Xt("max requires all arguments be DateTimes");
        return Vx(t, r => r.valueOf(), Math.max)
    }
    static fromFormatExplain(t, r, n={}) {
        const {locale: s=null, numberingSystem: i=null} = n
          , a = We.fromOpts({
            locale: s,
            numberingSystem: i,
            defaultToEN: !0
        });
        return o_(a, t, r)
    }
    static fromStringExplain(t, r, n={}) {
        return xe.fromFormatExplain(t, r, n)
    }
    static buildFormatParser(t, r={}) {
        const {locale: n=null, numberingSystem: s=null} = r
          , i = We.fromOpts({
            locale: n,
            numberingSystem: s,
            defaultToEN: !0
        });
        return new a_(i,t)
    }
    static fromFormatParser(t, r, n={}) {
        if (we(t) || we(r))
            throw new Xt("fromFormatParser requires an input string and a format parser");
        const {locale: s=null, numberingSystem: i=null} = n
          , a = We.fromOpts({
            locale: s,
            numberingSystem: i,
            defaultToEN: !0
        });
        if (!a.equals(r.locale))
            throw new Xt(`fromFormatParser called with a locale of ${a}, but the format parser was created for ${r.locale}`);
        const {result: o, zone: l, specificOffset: c, invalidReason: f} = r.explainFromTokens(t);
        return f ? xe.invalid(f) : Ra(o, l, n, `format ${r.format}`, t, c)
    }
    static get DATE_SHORT() {
        return Ef
    }
    static get DATE_MED() {
        return hE
    }
    static get DATE_MED_WITH_WEEKDAY() {
        return aU
    }
    static get DATE_FULL() {
        return mE
    }
    static get DATE_HUGE() {
        return pE
    }
    static get TIME_SIMPLE() {
        return yE
    }
    static get TIME_WITH_SECONDS() {
        return gE
    }
    static get TIME_WITH_SHORT_OFFSET() {
        return vE
    }
    static get TIME_WITH_LONG_OFFSET() {
        return bE
    }
    static get TIME_24_SIMPLE() {
        return xE
    }
    static get TIME_24_WITH_SECONDS() {
        return wE
    }
    static get TIME_24_WITH_SHORT_OFFSET() {
        return SE
    }
    static get TIME_24_WITH_LONG_OFFSET() {
        return kE
    }
    static get DATETIME_SHORT() {
        return EE
    }
    static get DATETIME_SHORT_WITH_SECONDS() {
        return _E
    }
    static get DATETIME_MED() {
        return TE
    }
    static get DATETIME_MED_WITH_SECONDS() {
        return CE
    }
    static get DATETIME_MED_WITH_WEEKDAY() {
        return oU
    }
    static get DATETIME_FULL() {
        return PE
    }
    static get DATETIME_FULL_WITH_SECONDS() {
        return $E
    }
    static get DATETIME_HUGE() {
        return NE
    }
    static get DATETIME_HUGE_WITH_SECONDS() {
        return jE
    }
}
function _l(e) {
    if (xe.isDateTime(e))
        return e;
    if (e && e.valueOf && oi(e.valueOf()))
        return xe.fromJSDate(e);
    if (e && typeof e == "object")
        return xe.fromObject(e);
    throw new Xt(`Unknown datetime argument: ${e}, of type ${typeof e}`)
}
function bh(e) {
    const n = xe.fromISO(e).diffNow(["years", "months", "days", "hours", "minutes", "seconds"]).negate();
    return n.years >= 1 ? `${n.years} year${n.years > 1 ? "s" : ""} ago` : n.months >= 1 ? `${n.months} month${n.months > 1 ? "s" : ""} ago` : n.days >= 1 ? `${n.days} day${n.days > 1 ? "s" : ""} ago` : n.hours >= 1 ? `${n.hours} hour${n.hours > 1 ? "s" : ""} ago` : n.minutes >= 1 ? `${n.minutes} minute${n.minutes > 1 ? "s" : ""} ago` : `${n.seconds} second${n.seconds > 1 ? "s" : ""} ago`
}
function f_({item: e}) {
    const t = Je()
      , r = gi()
      , [n,s] = g.useState(!1)
      , i = Hk();
    return d.jsxs("li", {
        className: fe("relative group", n && "pointer-events-none"),
        children: [d.jsxs(rl, {
            borderProps: {
                shape: "square",
                strokeWidth: 10,
                className: fe(e.blobType === "item" && "text-[#E9FCDD] group-hover:text-[#7AE137]", e.blobType === "avatar" && "text-[#C2E4F1] group-hover:text-[#30A0C9]")
            },
            className: "p-6 flex items-center justify-center w-full aspect-square relative",
            children: [d.jsx("img", {
                src: e.thumbnailUrl ?? "",
                alt: "Inventory item thumbnail",
                className: "block w-full",
                loading: "lazy"
            }), n && d.jsx("p", {
                className: "p-1 text-2xl text-blu-600 uppercase font-bold -rotate-12 bg-white rounded-2xl absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2",
                children: "Recovered"
            })]
        }), d.jsx("p", {
            className: "text-center mt-1",
            children: bh(e.lastUsedAt)
        }), d.jsx("div", {
            className: fe("opacity-0 group-hover:opacity-100 z-10 bg-white p-2 rounded-2xl", "absolute top-full left-1/2 -translate-x-1/2 -translate-y-1/2"),
            children: !n && d.jsxs(at, {
                variant: "filled",
                bg: "blue",
                onClick: async () => {
                    var o, l;
                    if (await Ve.emit("blob_recovered", {
                        id: e.id
                    }),
                    t.isModerator && e.latestOwnerId !== ((o = t.currentUser) == null ? void 0 : o.id)) {
                        i.mutate({
                            blobId: e.id
                        }, {
                            onError(c) {
                                ke.error(c.message || "Failed to recover item.")
                            },
                            onSuccess: () => {
                                s(!0)
                            }
                        });
                        return
                    }
                    const a = await ge.createInventoryItem(e.id);
                    if (!a.ok) {
                        ke.error(((l = a.error) == null ? void 0 : l.message) || "Failed to recover item.");
                        return
                    }
                    s(!0)
                }
                ,
                disabled: n || i.isPending || r.isCreatingItem,
                children: [d.jsx(iE, {
                    className: "w-6 h-6 mr-2"
                }), "Recover"]
            })
        })]
    }, e.id)
}
function iB() {
    var a;
    const e = jt()
      , [t,r] = ir()
      , n = t.get("username") ?? ""
      , s = i9(n);
    function i(o) {
        o.preventDefault();
        const l = new FormData(o.target);
        for (const [c,f] of l.entries())
            typeof f == "string" && f ? t.set(c, f) : t.delete(c);
        r(t),
        e.invalidateQueries({
            queryKey: ["admin", "lost-found"]
        })
    }
    return d.jsx(d.Fragment, {
        children: d.jsxs("section", {
            className: "flex flex-col flex-1 w-full h-full",
            children: [d.jsx("header", {
                className: "flex items-center justify-start h-24 px-10 border-b",
                children: d.jsxs("form", {
                    className: "flex items-center gap-4",
                    onSubmit: i,
                    children: [d.jsx("input", {
                        name: "username",
                        type: "search",
                        className: "w-96 px-4 py-3 border border-gray-400 rounded text-xl",
                        placeholder: "Username",
                        defaultValue: n
                    }), d.jsx(at, {
                        variant: "filled",
                        bg: "blue",
                        size: "lg",
                        children: "Search"
                    })]
                })
            }), s.isFetching && d.jsx("div", {
                className: "px-10 py-4",
                children: "Loading..."
            }), ((a = s.data) == null ? void 0 : a.ok) && s.data.value.length > 0 && d.jsxs("div", {
                className: "overflow-auto flex-1",
                children: [d.jsx("div", {
                    className: "px-10 w-full my-6",
                    children: d.jsxs("div", {
                        className: "rounded-xl bg-gray-50 p-4 w-full space-y-4",
                        children: [d.jsx("h2", {
                            className: "font-sans font-bold text-3xl uppercase",
                            children: "Caution!!!"
                        }), d.jsx("p", {
                            className: "text-slate-600 max-w-2xl",
                            children: "These blobs aren't necessarily lost, they are just not in an inventory and not listed as products. Moving a blob back into someons inventory can result in a duplicate if they are still in the current room their blob is in and modify it then move it back to their inventory."
                        })]
                    })
                }), d.jsx("ul", {
                    className: "grid justify-start grid-cols-2 lg:grid-cols-3 xl:grid-cols-5 gap-4 lg:gap-6 px-10 pb-10 pt-4",
                    children: s.data.value.sort( (o, l) => new Date(l.lastUsedAt).getTime() - new Date(o.lastUsedAt).getTime()).map(o => d.jsx(f_, {
                        item: o
                    }, o.id))
                })]
            })]
        })
    })
}
function vv(e) {
    return d.jsx("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 155 154",
        fill: "none",
        ...e,
        children: d.jsx("path", {
            fill: "currentColor",
            d: "M0 18 13 6.5 41.5 18l29 30L122 .5h10.5l12 15v25l-44 41L155 135l-22.5 18-19-4.5-43-45.5L18 153.5H4.5L0 135l4.5-18.5 37-42L0 31.5V18Z"
        })
    })
}
function aB(e, t) {
    const n = zk()[e];
    return oC(n, `params.${e}`),
    n
}
function oB() {
    var h, m, y, k, x;
    const e = aB("id")
      , t = Je()
      , r = n9(e)
      , n = r9(e)
      , s = (h = n.data) != null && h.ok ? n.data.value.id : void 0
      , i = a9({
        blobId: s
    }, {
        enabled: !!s
    })
      , a = Y7()
      , o = Q7()
      , [l,c] = g.useState([])
      , f = new Set(l);
    return d.jsxs("section", {
        className: "flex flex-col fixed top-5 right-5 bottom-5 w-96 max-w-full rounded shadow-2xl border border-gray-100 z-20 bg-white",
        children: [d.jsx("header", {
            className: "flex p-4",
            children: d.jsx(Kt, {
                to: "/admin/reports",
                className: "ml-auto",
                children: d.jsx(vv, {
                    className: "w-5 h-5"
                })
            })
        }), d.jsxs("div", {
            className: "flex-1 overflow-auto p-4",
            children: [((m = r.data) == null ? void 0 : m.ok) && d.jsxs("div", {
                children: [d.jsxs("p", {
                    className: "mb-4",
                    children: [d.jsx("span", {
                        className: "text-sm opacity-50",
                        children: "Report Type"
                    }), ": ", d.jsx("br", {}), d.jsx("span", {
                        className: "capitalize",
                        children: r.data.value.type
                    })]
                }), d.jsxs("p", {
                    className: "mb-4",
                    children: [d.jsx("span", {
                        className: "text-sm opacity-50",
                        children: "Report Reason"
                    }), ": ", d.jsx("br", {}), r.data.value.reportNotes ? d.jsx("p", {
                        children: r.data.value.reportNotes
                    }) : d.jsx("p", {
                        children: "N/A"
                    })]
                })]
            }), ((y = n.data) == null ? void 0 : y.ok) && d.jsx("div", {
                children: n.data.value.thumbnailUrl && d.jsx("img", {
                    src: n.data.value.thumbnailUrl,
                    alt: "Blob thumbnail",
                    className: "w-full min-h-56 block border border-gray-100 shadow rounded-lg"
                })
            }), ((k = i.data) == null ? void 0 : k.ok) && i.data.value.items.length > 0 && d.jsxs("section", {
                className: "my-12",
                children: [d.jsx("p", {
                    className: "text-lg mb-4",
                    children: "Related Products"
                }), d.jsx("ul", {
                    children: i.data.value.items.map(w => {
                        const v = f.has(w.id);
                        return d.jsxs("li", {
                            className: "px-2 py-1 border border-gray-100 rounded",
                            children: [d.jsxs("div", {
                                className: "flex items-center justify-between",
                                children: [d.jsxs("p", {
                                    children: [d.jsx("span", {
                                        className: "text-sm opacity-50",
                                        children: "Name"
                                    }), ": ", d.jsx("br", {}), " ", w.name]
                                }), d.jsx("div", {
                                    className: "ml-auto",
                                    children: !v && d.jsx("button", {
                                        type: "button",
                                        onClick: async () => {
                                            try {
                                                await o.mutateAsync({
                                                    id: w.id
                                                }),
                                                ke.success(`${w.name} deleted`),
                                                c(p => [...p, w.id])
                                            } catch (p) {
                                                console.error("Error deleting product:", p)
                                            }
                                        }
                                        ,
                                        className: fe("flex items-center justify-center h-10 w-10 ml-2 p-2 rounded", "opacity-20 hover:opacity-100", "text-red-500 bg-red-50"),
                                        children: d.jsx(sv, {
                                            className: "w-4 h-4 stroke-[3px]"
                                        })
                                    })
                                })]
                            }), d.jsxs("div", {
                                className: "flex items-center justify-between",
                                children: [d.jsxs("p", {
                                    children: [d.jsx("span", {
                                        className: "text-sm opacity-50",
                                        children: "Sold by:"
                                    }), ": ", d.jsx("br", {}), " ", w.seller.displayName]
                                }), d.jsxs("div", {
                                    className: "flex items-center",
                                    children: [d.jsx(Kt, {
                                        to: `/admin/users?username=${w.seller.displayName}`,
                                        className: fe("flex items-center justify-center h-10 w-10 ml-2 p-2 rounded", "opacity-20 hover:opacity-100", "text-red-500 bg-red-50"),
                                        children: d.jsx(hh, {
                                            className: "w-4 h-4 stroke-[3px]"
                                        })
                                    }), t.isAdmin && t.device === "browser" && d.jsx("a", {
                                        href: `https://dashboard.ggwp.com/player/2eba8284-23d2-4b55-a0f6-ebff5a4a7d87?incidentSource=all&source=chat&page=1&limit=20&playerId=${w.seller.id}&from=W3sicm91dGUiOiIvcGxheWVycyIsInRpdGxlIjoiUExBWUVSX0xJU1RfUEFHRV9USVRMRSIsImxldmVsIjoxLCJmdWxsUGF0aCI6Ii9wbGF5ZXJzLzJlYmE4Mjg0LTIzZDItNGI1NS1hMGY2LWViZmY1YTRhN2Q4Nz9wYWdlPTEmaW5jaWRlbnRfdHlwZT1hbGwmZGF0ZV9yYW5nZT0xJmxpbWl0PTIwIn1d&created_at=0&severity=medium%3Bhigh&confidence=medium%3Bhigh&limit=20`,
                                        title: "GGWP Dashboard",
                                        target: "_blank",
                                        className: fe("flex items-center justify-center h-10 w-10 ml-2 p-2 rounded", "opacity-20 hover:opacity-100", "text-red-500 bg-red-50"),
                                        rel: "noreferrer",
                                        children: d.jsx(a8, {
                                            className: "w-4 h-4 stroke-[3px]"
                                        })
                                    })]
                                })]
                            })]
                        }, w.id)
                    }
                    )
                })]
            })]
        }), ((x = r.data) == null ? void 0 : x.ok) && r.data.value.status === "pending" && d.jsx("footer", {
            className: "border-t border-gray-100",
            children: d.jsx("fieldset", {
                disabled: a.isPending,
                className: "flex p-4 items-center gap-4",
                children: ["valid", "invalid"].map(w => d.jsx("button", {
                    type: "button",
                    onClick: () => a.mutate({
                        id: e,
                        status: w
                    }),
                    className: fe("flex-1 px-4 py-2 rounded capitalize opacity-80 hover:opacity-100", w === "valid" ? "bg-red-800 text-white" : "bg-gray-50 text-gray-500"),
                    children: w === "valid" ? "Punish" : "Ignore"
                }, w))
            })
        })]
    })
}
const lB = g.createContext(null);
g.createContext(null);
g.createContext(null);
g.createContext(null);
g.createContext(null);
g.createContext({});
const _i = typeof document < "u" ? ve.useLayoutEffect : () => {}
;
function Qr(e) {
    const t = g.useRef(null);
    return _i( () => {
        t.current = e
    }
    , [e]),
    g.useCallback( (...r) => {
        const n = t.current;
        return n == null ? void 0 : n(...r)
    }
    , [])
}
function uB(e) {
    let[t,r] = g.useState(e)
      , n = g.useRef(null)
      , s = Qr( () => {
        if (!n.current)
            return;
        let a = n.current.next();
        if (a.done) {
            n.current = null;
            return
        }
        t === a.value ? s() : r(a.value)
    }
    );
    _i( () => {
        n.current && s()
    }
    );
    let i = Qr(a => {
        n.current = a(t),
        s()
    }
    );
    return [t, i]
}
const bv = {
    prefix: String(Math.round(Math.random() * 1e10)),
    current: 0
}
  , h_ = ve.createContext(bv)
  , cB = ve.createContext(!1);
let dB = !!(typeof window < "u" && window.document && window.document.createElement)
  , xm = new WeakMap;
function fB(e=!1) {
    let t = g.useContext(h_)
      , r = g.useRef(null);
    if (r.current === null && !e) {
        var n, s;
        let i = (s = ve.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) === null || s === void 0 || (n = s.ReactCurrentOwner) === null || n === void 0 ? void 0 : n.current;
        if (i) {
            let a = xm.get(i);
            a == null ? xm.set(i, {
                id: t.current,
                state: i.memoizedState
            }) : i.memoizedState !== a.state && (t.current = a.id,
            xm.delete(i))
        }
        r.current = ++t.current
    }
    return r.current
}
function hB(e) {
    let t = g.useContext(h_);
    t === bv && !dB && console.warn("When server rendering, you must wrap your application in an <SSRProvider> to ensure consistent ids are generated between the client and server.");
    let r = fB(!!e)
      , n = `react-aria${t.prefix}`;
    return e || `${n}-${r}`
}
function mB(e) {
    let t = ve.useId()
      , [r] = g.useState(bB())
      , n = r ? "react-aria" : `react-aria${bv.prefix}`;
    return e || `${n}-${t}`
}
const pB = typeof ve.useId == "function" ? mB : hB;
function yB() {
    return !1
}
function gB() {
    return !0
}
function vB(e) {
    return () => {}
}
function bB() {
    return typeof ve.useSyncExternalStore == "function" ? ve.useSyncExternalStore(vB, yB, gB) : g.useContext(cB)
}
let xB = !!(typeof window < "u" && window.document && window.document.createElement), mo = new Map, zl;
typeof FinalizationRegistry < "u" && (zl = new FinalizationRegistry(e => {
    mo.delete(e)
}
));
function Pf(e) {
    let[t,r] = g.useState(e)
      , n = g.useRef(null)
      , s = pB(t)
      , i = g.useRef(null);
    if (zl && zl.register(i, s),
    xB) {
        const a = mo.get(s);
        a && !a.includes(n) ? a.push(n) : mo.set(s, [n])
    }
    return _i( () => {
        let a = s;
        return () => {
            zl && zl.unregister(i),
            mo.delete(a)
        }
    }
    , [s]),
    g.useEffect( () => {
        let a = n.current;
        return a && r(a),
        () => {
            a && (n.current = null)
        }
    }
    ),
    s
}
function wB(e, t) {
    if (e === t)
        return e;
    let r = mo.get(e);
    if (r)
        return r.forEach(s => s.current = t),
        t;
    let n = mo.get(t);
    return n ? (n.forEach(s => s.current = e),
    e) : t
}
function n1(e=[]) {
    let t = Pf()
      , [r,n] = uB(t)
      , s = g.useCallback( () => {
        n(function*() {
            yield t,
            yield document.getElementById(t) ? t : void 0
        })
    }
    , [t, n]);
    return _i(s, [t, s, ...e]),
    r
}
function m_(...e) {
    return (...t) => {
        for (let r of e)
            typeof r == "function" && r(...t)
    }
}
const pr = e => {
    var t;
    return (t = e == null ? void 0 : e.ownerDocument) !== null && t !== void 0 ? t : document
}
  , vn = e => e && "window"in e && e.window === e ? e : pr(e).defaultView || window;
function SB(e) {
    return e !== null && typeof e == "object" && "nodeType"in e && typeof e.nodeType == "number"
}
function kB(e) {
    return SB(e) && e.nodeType === Node.DOCUMENT_FRAGMENT_NODE && "host"in e
}
let EB = !1;
function xv() {
    return EB
}
function pt(e, t) {
    if (!xv())
        return t && e ? e.contains(t) : !1;
    if (!e || !t)
        return !1;
    let r = t;
    for (; r !== null; ) {
        if (r === e)
            return !0;
        r.tagName === "SLOT" && r.assignedSlot ? r = r.assignedSlot.parentNode : kB(r) ? r = r.host : r = r.parentNode
    }
    return !1
}
const Fu = (e=document) => {
    var t;
    if (!xv())
        return e.activeElement;
    let r = e.activeElement;
    for (; r && "shadowRoot"in r && (!((t = r.shadowRoot) === null || t === void 0) && t.activeElement); )
        r = r.shadowRoot.activeElement;
    return r
}
;
function et(e) {
    return xv() && e.target.shadowRoot && e.composedPath ? e.composedPath()[0] : e.target
}
function jr(...e) {
    let t = {
        ...e[0]
    };
    for (let r = 1; r < e.length; r++) {
        let n = e[r];
        for (let s in n) {
            let i = t[s]
              , a = n[s];
            typeof i == "function" && typeof a == "function" && s[0] === "o" && s[1] === "n" && s.charCodeAt(2) >= 65 && s.charCodeAt(2) <= 90 ? t[s] = m_(i, a) : (s === "className" || s === "UNSAFE_className") && typeof i == "string" && typeof a == "string" ? t[s] = fe(i, a) : s === "id" && i && a ? t.id = wB(i, a) : t[s] = a !== void 0 ? a : i
        }
    }
    return t
}
function p_(...e) {
    return e.length === 1 && e[0] ? e[0] : t => {
        for (let r of e)
            typeof r == "function" ? r(t) : r != null && (r.current = t)
    }
}
const _B = new Set(["id"])
  , TB = new Set(["aria-label", "aria-labelledby", "aria-describedby", "aria-details"])
  , CB = new Set(["href", "hrefLang", "target", "rel", "download", "ping", "referrerPolicy"])
  , PB = /^(data-.*)$/;
function wv(e, t={}) {
    let {labelable: r, isLink: n, propNames: s} = t
      , i = {};
    for (const a in e)
        Object.prototype.hasOwnProperty.call(e, a) && (_B.has(a) || r && TB.has(a) || n && CB.has(a) || s != null && s.has(a) || PB.test(a)) && (i[a] = e[a]);
    return i
}
function Uo(e) {
    if ($B())
        e.focus({
            preventScroll: !0
        });
    else {
        let t = NB(e);
        e.focus(),
        jB(t)
    }
}
let rd = null;
function $B() {
    if (rd == null) {
        rd = !1;
        try {
            document.createElement("div").focus({
                get preventScroll() {
                    return rd = !0,
                    !0
                }
            })
        } catch {}
    }
    return rd
}
function NB(e) {
    let t = e.parentNode
      , r = []
      , n = document.scrollingElement || document.documentElement;
    for (; t instanceof HTMLElement && t !== n; )
        (t.offsetHeight < t.scrollHeight || t.offsetWidth < t.scrollWidth) && r.push({
            element: t,
            scrollTop: t.scrollTop,
            scrollLeft: t.scrollLeft
        }),
        t = t.parentNode;
    return n instanceof HTMLElement && r.push({
        element: n,
        scrollTop: n.scrollTop,
        scrollLeft: n.scrollLeft
    }),
    r
}
function jB(e) {
    for (let {element: t, scrollTop: r, scrollLeft: n} of e)
        t.scrollTop = r,
        t.scrollLeft = n
}
function xh(e) {
    var t;
    return typeof window > "u" || window.navigator == null ? !1 : ((t = window.navigator.userAgentData) === null || t === void 0 ? void 0 : t.brands.some(r => e.test(r.brand))) || e.test(window.navigator.userAgent)
}
function Sv(e) {
    var t;
    return typeof window < "u" && window.navigator != null ? e.test(((t = window.navigator.userAgentData) === null || t === void 0 ? void 0 : t.platform) || window.navigator.platform) : !1
}
function Ti(e) {
    let t = null;
    return () => (t == null && (t = e()),
    t)
}
const zu = Ti(function() {
    return Sv(/^Mac/i)
})
  , IB = Ti(function() {
    return Sv(/^iPhone/i)
})
  , y_ = Ti(function() {
    return Sv(/^iPad/i) || zu() && navigator.maxTouchPoints > 1
})
  , g_ = Ti(function() {
    return IB() || y_()
})
  , RB = Ti(function() {
    return xh(/AppleWebKit/i) && !OB()
})
  , OB = Ti(function() {
    return xh(/Chrome/i)
})
  , v_ = Ti(function() {
    return xh(/Android/i)
})
  , MB = Ti(function() {
    return xh(/Firefox/i)
});
function Uu(e, t, r=!0) {
    var n, s;
    let {metaKey: i, ctrlKey: a, altKey: o, shiftKey: l} = t;
    MB() && (!((s = window.event) === null || s === void 0 || (n = s.type) === null || n === void 0) && n.startsWith("key")) && e.target === "_blank" && (zu() ? i = !0 : a = !0);
    let c = RB() && zu() && !y_() ? new KeyboardEvent("keydown",{
        keyIdentifier: "Enter",
        metaKey: i,
        ctrlKey: a,
        altKey: o,
        shiftKey: l
    }) : new MouseEvent("click",{
        metaKey: i,
        ctrlKey: a,
        altKey: o,
        shiftKey: l,
        bubbles: !0,
        cancelable: !0
    });
    Uu.isOpening = r,
    Uo(e),
    e.dispatchEvent(c),
    Uu.isOpening = !1
}
Uu.isOpening = !1;
let za = new Map
  , py = new Set;
function s1() {
    if (typeof window > "u")
        return;
    function e(n) {
        return "propertyName"in n
    }
    let t = n => {
        if (!e(n) || !n.target)
            return;
        let s = za.get(n.target);
        s || (s = new Set,
        za.set(n.target, s),
        n.target.addEventListener("transitioncancel", r, {
            once: !0
        })),
        s.add(n.propertyName)
    }
      , r = n => {
        if (!e(n) || !n.target)
            return;
        let s = za.get(n.target);
        if (s && (s.delete(n.propertyName),
        s.size === 0 && (n.target.removeEventListener("transitioncancel", r),
        za.delete(n.target)),
        za.size === 0)) {
            for (let i of py)
                i();
            py.clear()
        }
    }
    ;
    document.body.addEventListener("transitionrun", t),
    document.body.addEventListener("transitionend", r)
}
typeof document < "u" && (document.readyState !== "loading" ? s1() : document.addEventListener("DOMContentLoaded", s1));
function b_(e) {
    requestAnimationFrame( () => {
        za.size === 0 ? e() : py.add(e)
    }
    )
}
function kv() {
    let e = g.useRef(new Map)
      , t = g.useCallback( (s, i, a, o) => {
        let l = o != null && o.once ? (...c) => {
            e.current.delete(a),
            a(...c)
        }
        : a;
        e.current.set(a, {
            type: i,
            eventTarget: s,
            fn: l,
            options: o
        }),
        s.addEventListener(i, l, o)
    }
    , [])
      , r = g.useCallback( (s, i, a, o) => {
        var l;
        let c = ((l = e.current.get(a)) === null || l === void 0 ? void 0 : l.fn) || a;
        s.removeEventListener(i, c, o),
        e.current.delete(a)
    }
    , [])
      , n = g.useCallback( () => {
        e.current.forEach( (s, i) => {
            r(s.eventTarget, s.type, i, s.options)
        }
        )
    }
    , [r]);
    return g.useEffect( () => n, [n]),
    {
        addGlobalListener: t,
        removeGlobalListener: r,
        removeAllGlobalListeners: n
    }
}
function AB(e, t) {
    let {id: r, "aria-label": n, "aria-labelledby": s} = e;
    return r = Pf(r),
    s && n ? s = [...new Set([r, ...s.trim().split(/\s+/)])].join(" ") : s && (s = s.trim().split(/\s+/).join(" ")),
    !n && !s && t && (n = t),
    {
        id: r,
        "aria-label": n,
        "aria-labelledby": s
    }
}
function x_(e) {
    const t = g.useRef(null);
    return g.useMemo( () => ({
        get current() {
            return t.current
        },
        set current(r) {
            t.current = r,
            typeof e == "function" ? e(r) : e && (e.current = r)
        }
    }), [e])
}
function w_(e, t) {
    _i( () => {
        if (e && e.ref && t)
            return e.ref.current = t.current,
            () => {
                e.ref && (e.ref.current = null)
            }
    }
    )
}
function yy(e) {
    return e.mozInputSource === 0 && e.isTrusted ? !0 : v_() && e.pointerType ? e.type === "click" && e.buttons === 1 : e.detail === 0 && !e.pointerType
}
function LB(e) {
    return !v_() && e.width === 0 && e.height === 0 || e.width === 1 && e.height === 1 && e.pressure === 0 && e.detail === 0 && e.pointerType === "mouse"
}
function DB(e, t, r) {
    let n = g.useRef(t)
      , s = Qr( () => {
        r && r(n.current)
    }
    );
    g.useEffect( () => {
        var i;
        let a = e == null || (i = e.current) === null || i === void 0 ? void 0 : i.form;
        return a == null || a.addEventListener("reset", s),
        () => {
            a == null || a.removeEventListener("reset", s)
        }
    }
    , [e, s])
}
const S_ = ["input:not([disabled]):not([type=hidden])", "select:not([disabled])", "textarea:not([disabled])", "button:not([disabled])", "a[href]", "area[href]", "summary", "iframe", "object", "embed", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable^="false"])']
  , FB = S_.join(":not([hidden]),") + ",[tabindex]:not([disabled]):not([hidden])";
S_.push('[tabindex]:not([tabindex="-1"]):not([disabled])');
function zB(e) {
    return e.matches(FB)
}
function k_(e, t, r) {
    let[n,s] = g.useState(e || t)
      , i = g.useRef(e !== void 0)
      , a = e !== void 0;
    g.useEffect( () => {
        let c = i.current;
        c !== a && console.warn(`WARN: A component changed from ${c ? "controlled" : "uncontrolled"} to ${a ? "controlled" : "uncontrolled"}.`),
        i.current = a
    }
    , [a]);
    let o = a ? e : n
      , l = g.useCallback( (c, ...f) => {
        let h = (m, ...y) => {
            r && (Object.is(o, m) || r(m, ...y)),
            a || (o = m)
        }
        ;
        typeof c == "function" ? (console.warn("We can not support a function callback. See Github Issues for details https://github.com/adobe/react-spectrum/issues/2320"),
        s( (y, ...k) => {
            let x = c(a ? o : y, ...k);
            return h(x, ...f),
            a ? y : x
        }
        )) : (a || s(c),
        h(c, ...f))
    }
    , [a, o, r]);
    return [o, l]
}
const UB = Symbol("default");
function VB({values: e, children: t}) {
    for (let[r,n] of e)
        t = ve.createElement(r.Provider, {
            value: n
        }, t);
    return t
}
function E_(e) {
    let {className: t, style: r, children: n, defaultClassName: s, defaultChildren: i, defaultStyle: a, values: o} = e;
    return g.useMemo( () => {
        let l, c, f;
        return typeof t == "function" ? l = t({
            ...o,
            defaultClassName: s
        }) : l = t,
        typeof r == "function" ? c = r({
            ...o,
            defaultStyle: a || {}
        }) : c = r,
        typeof n == "function" ? f = n({
            ...o,
            defaultChildren: i
        }) : n == null ? f = i : f = n,
        {
            className: l ?? s,
            style: c || a ? {
                ...a,
                ...c
            } : void 0,
            children: f ?? i,
            "data-rac": ""
        }
    }
    , [t, r, n, s, i, a, o])
}
function Ev(e, t) {
    let r = g.useContext(e);
    if (t === null)
        return null;
    if (r && typeof r == "object" && "slots"in r && r.slots) {
        let n = t || UB;
        if (!r.slots[n]) {
            let s = new Intl.ListFormat().format(Object.keys(r.slots).map(a => `"${a}"`))
              , i = t ? `Invalid slot "${t}".` : "A slot prop is required.";
            throw new Error(`${i} Valid slot names are ${s}.`)
        }
        return r.slots[n]
    }
    return r
}
function _v(e, t, r) {
    let n = Ev(r, e.slot) || {}
      , {ref: s, ...i} = n
      , a = x_(g.useMemo( () => p_(t, s), [t, s]))
      , o = jr(i, e);
    return "style"in i && i.style && "style"in e && e.style && (typeof i.style == "function" || typeof e.style == "function" ? o.style = l => {
        let c = typeof i.style == "function" ? i.style(l) : i.style
          , f = {
            ...l.defaultStyle,
            ...c
        }
          , h = typeof e.style == "function" ? e.style({
            ...l,
            defaultStyle: f
        }) : e.style;
        return {
            ...f,
            ...h
        }
    }
    : o.style = {
        ...i.style,
        ...e.style
    }),
    [o, a]
}
function BB(e=!0) {
    let[t,r] = g.useState(e)
      , n = g.useRef(!1)
      , s = g.useCallback(i => {
        n.current = !0,
        r(!!i)
    }
    , []);
    return _i( () => {
        n.current || r(!1)
    }
    , []),
    [s, t]
}
function i1(e) {
    const t = /^(data-.*)$/;
    let r = {};
    for (const n in e)
        t.test(n) || (r[n] = e[n]);
    return r
}
if (typeof HTMLTemplateElement < "u") {
    const e = Object.getOwnPropertyDescriptor(Node.prototype, "firstChild").get;
    Object.defineProperty(HTMLTemplateElement.prototype, "firstChild", {
        configurable: !0,
        enumerable: !0,
        get: function() {
            return this.dataset.reactAriaHidden ? this.content.firstChild : e.call(this)
        }
    })
}
const WB = g.createContext(!1);
function qB(e) {
    let t = (r, n) => g.useContext(WB) ? null : e(r, n);
    return t.displayName = e.displayName || e.name,
    g.forwardRef(t)
}
let ro = "default"
  , gy = ""
  , Ed = new WeakMap;
function a1(e) {
    if (g_()) {
        if (ro === "default") {
            const t = pr(e);
            gy = t.documentElement.style.webkitUserSelect,
            t.documentElement.style.webkitUserSelect = "none"
        }
        ro = "disabled"
    } else if (e instanceof HTMLElement || e instanceof SVGElement) {
        let t = "userSelect"in e.style ? "userSelect" : "webkitUserSelect";
        Ed.set(e, e.style[t]),
        e.style[t] = "none"
    }
}
function wm(e) {
    if (g_()) {
        if (ro !== "disabled")
            return;
        ro = "restoring",
        setTimeout( () => {
            b_( () => {
                if (ro === "restoring") {
                    const t = pr(e);
                    t.documentElement.style.webkitUserSelect === "none" && (t.documentElement.style.webkitUserSelect = gy || ""),
                    gy = "",
                    ro = "default"
                }
            }
            )
        }
        , 300)
    } else if ((e instanceof HTMLElement || e instanceof SVGElement) && e && Ed.has(e)) {
        let t = Ed.get(e)
          , r = "userSelect"in e.style ? "userSelect" : "webkitUserSelect";
        e.style[r] === "none" && (e.style[r] = t),
        e.getAttribute("style") === "" && e.removeAttribute("style"),
        Ed.delete(e)
    }
}
const __ = ve.createContext({
    register: () => {}
});
__.displayName = "PressResponderContext";
class T_ {
    isDefaultPrevented() {
        return this.nativeEvent.defaultPrevented
    }
    preventDefault() {
        this.defaultPrevented = !0,
        this.nativeEvent.preventDefault()
    }
    stopPropagation() {
        this.nativeEvent.stopPropagation(),
        this.isPropagationStopped = () => !0
    }
    isPropagationStopped() {
        return !1
    }
    persist() {}
    constructor(t, r) {
        this.nativeEvent = r,
        this.target = r.target,
        this.currentTarget = r.currentTarget,
        this.relatedTarget = r.relatedTarget,
        this.bubbles = r.bubbles,
        this.cancelable = r.cancelable,
        this.defaultPrevented = r.defaultPrevented,
        this.eventPhase = r.eventPhase,
        this.isTrusted = r.isTrusted,
        this.timeStamp = r.timeStamp,
        this.type = t
    }
}
function C_(e) {
    let t = g.useRef({
        isFocused: !1,
        observer: null
    });
    _i( () => {
        const n = t.current;
        return () => {
            n.observer && (n.observer.disconnect(),
            n.observer = null)
        }
    }
    , []);
    let r = Qr(n => {
        e == null || e(n)
    }
    );
    return g.useCallback(n => {
        if (n.target instanceof HTMLButtonElement || n.target instanceof HTMLInputElement || n.target instanceof HTMLTextAreaElement || n.target instanceof HTMLSelectElement) {
            t.current.isFocused = !0;
            let s = n.target
              , i = a => {
                t.current.isFocused = !1,
                s.disabled && r(new T_("blur",a)),
                t.current.observer && (t.current.observer.disconnect(),
                t.current.observer = null)
            }
            ;
            s.addEventListener("focusout", i, {
                once: !0
            }),
            t.current.observer = new MutationObserver( () => {
                if (t.current.isFocused && s.disabled) {
                    var a;
                    (a = t.current.observer) === null || a === void 0 || a.disconnect();
                    let o = s === document.activeElement ? null : document.activeElement;
                    s.dispatchEvent(new FocusEvent("blur",{
                        relatedTarget: o
                    })),
                    s.dispatchEvent(new FocusEvent("focusout",{
                        bubbles: !0,
                        relatedTarget: o
                    }))
                }
            }
            ),
            t.current.observer.observe(s, {
                attributes: !0,
                attributeFilter: ["disabled"]
            })
        }
    }
    , [r])
}
let $f = !1;
function o1(e) {
    for (; e && !zB(e); )
        e = e.parentElement;
    let t = vn(e)
      , r = t.document.activeElement;
    if (!r || r === e)
        return;
    $f = !0;
    let n = !1
      , s = f => {
        (f.target === r || n) && f.stopImmediatePropagation()
    }
      , i = f => {
        (f.target === r || n) && (f.stopImmediatePropagation(),
        !e && !n && (n = !0,
        Uo(r),
        l()))
    }
      , a = f => {
        (f.target === e || n) && f.stopImmediatePropagation()
    }
      , o = f => {
        (f.target === e || n) && (f.stopImmediatePropagation(),
        n || (n = !0,
        Uo(r),
        l()))
    }
    ;
    t.addEventListener("blur", s, !0),
    t.addEventListener("focusout", i, !0),
    t.addEventListener("focusin", o, !0),
    t.addEventListener("focus", a, !0);
    let l = () => {
        cancelAnimationFrame(c),
        t.removeEventListener("blur", s, !0),
        t.removeEventListener("focusout", i, !0),
        t.removeEventListener("focusin", o, !0),
        t.removeEventListener("focus", a, !0),
        $f = !1,
        n = !1
    }
      , c = requestAnimationFrame(l);
    return l
}
function HB(e, t) {
    return t.get ? t.get.call(e) : t.value
}
function P_(e, t, r) {
    if (!t.has(e))
        throw new TypeError("attempted to " + r + " private field on non-instance");
    return t.get(e)
}
function ZB(e, t) {
    var r = P_(e, t, "get");
    return HB(e, r)
}
function KB(e, t) {
    if (t.has(e))
        throw new TypeError("Cannot initialize the same private elements twice on an object")
}
function QB(e, t, r) {
    KB(e, t),
    t.set(e, r)
}
function GB(e, t, r) {
    if (t.set)
        t.set.call(e, r);
    else {
        if (!t.writable)
            throw new TypeError("attempted to set read only private field");
        t.value = r
    }
}
function l1(e, t, r) {
    var n = P_(e, t, "set");
    return GB(e, n, r),
    r
}
function YB(e) {
    let t = g.useContext(__);
    if (t) {
        let {register: r, ...n} = t;
        e = jr(n, e),
        r()
    }
    return w_(t, e.ref),
    e
}
var nd = new WeakMap;
class sd {
    continuePropagation() {
        l1(this, nd, !1)
    }
    get shouldStopPropagation() {
        return ZB(this, nd)
    }
    constructor(t, r, n, s) {
        QB(this, nd, {
            writable: !0,
            value: void 0
        }),
        l1(this, nd, !0);
        var i;
        let a = (i = s == null ? void 0 : s.target) !== null && i !== void 0 ? i : n.currentTarget;
        const o = a == null ? void 0 : a.getBoundingClientRect();
        let l, c = 0, f, h = null;
        n.clientX != null && n.clientY != null && (f = n.clientX,
        h = n.clientY),
        o && (f != null && h != null ? (l = f - o.left,
        c = h - o.top) : (l = o.width / 2,
        c = o.height / 2)),
        this.type = t,
        this.pointerType = r,
        this.target = n.currentTarget,
        this.shiftKey = n.shiftKey,
        this.metaKey = n.metaKey,
        this.ctrlKey = n.ctrlKey,
        this.altKey = n.altKey,
        this.x = l,
        this.y = c
    }
}
const u1 = Symbol("linkClicked");
function vy(e) {
    let {onPress: t, onPressChange: r, onPressStart: n, onPressEnd: s, onPressUp: i, isDisabled: a, isPressed: o, preventFocusOnPress: l, shouldCancelOnPointerExit: c, allowTextSelectionOnPress: f, ref: h, ...m} = YB(e)
      , [y,k] = g.useState(!1)
      , x = g.useRef({
        isPressed: !1,
        ignoreEmulatedMouseEvents: !1,
        didFirePressStart: !1,
        isTriggeringEvent: !1,
        activePointerId: null,
        target: null,
        isOverTarget: !1,
        pointerType: null,
        disposables: []
    })
      , {addGlobalListener: w, removeAllGlobalListeners: v} = kv()
      , p = Qr( (b, O) => {
        let M = x.current;
        if (a || M.didFirePressStart)
            return !1;
        let D = !0;
        if (M.isTriggeringEvent = !0,
        n) {
            let z = new sd("pressstart",O,b);
            n(z),
            D = z.shouldStopPropagation
        }
        return r && r(!0),
        M.isTriggeringEvent = !1,
        M.didFirePressStart = !0,
        k(!0),
        D
    }
    )
      , S = Qr( (b, O, M=!0) => {
        let D = x.current;
        if (!D.didFirePressStart)
            return !1;
        D.didFirePressStart = !1,
        D.isTriggeringEvent = !0;
        let z = !0;
        if (s) {
            let $ = new sd("pressend",O,b);
            s($),
            z = $.shouldStopPropagation
        }
        if (r && r(!1),
        k(!1),
        t && M && !a) {
            let $ = new sd("press",O,b);
            t($),
            z && (z = $.shouldStopPropagation)
        }
        return D.isTriggeringEvent = !1,
        z
    }
    )
      , P = Qr( (b, O) => {
        let M = x.current;
        if (a)
            return !1;
        if (i) {
            M.isTriggeringEvent = !0;
            let D = new sd("pressup",O,b);
            return i(D),
            M.isTriggeringEvent = !1,
            D.shouldStopPropagation
        }
        return !0
    }
    )
      , j = Qr(b => {
        let O = x.current;
        if (O.isPressed && O.target) {
            O.didFirePressStart && O.pointerType != null && S(Oa(O.target, b), O.pointerType, !1),
            O.isPressed = !1,
            O.isOverTarget = !1,
            O.activePointerId = null,
            O.pointerType = null,
            v(),
            f || wm(O.target);
            for (let M of O.disposables)
                M();
            O.disposables = []
        }
    }
    )
      , L = Qr(b => {
        c && j(b)
    }
    )
      , E = g.useMemo( () => {
        let b = x.current
          , O = {
            onKeyDown(D) {
                if (Sm(D.nativeEvent, D.currentTarget) && pt(D.currentTarget, et(D.nativeEvent))) {
                    var z;
                    f1(et(D.nativeEvent), D.key) && D.preventDefault();
                    let $ = !0;
                    if (!b.isPressed && !D.repeat) {
                        b.target = D.currentTarget,
                        b.isPressed = !0,
                        b.pointerType = "keyboard",
                        $ = p(D, "keyboard");
                        let Y = D.currentTarget
                          , ce = Ke => {
                            Sm(Ke, Y) && !Ke.repeat && pt(Y, et(Ke)) && b.target && P(Oa(b.target, Ke), "keyboard")
                        }
                        ;
                        w(pr(D.currentTarget), "keyup", m_(ce, M), !0)
                    }
                    $ && D.stopPropagation(),
                    D.metaKey && zu() && ((z = b.metaKeyEvents) === null || z === void 0 || z.set(D.key, D.nativeEvent))
                } else
                    D.key === "Meta" && (b.metaKeyEvents = new Map)
            },
            onClick(D) {
                if (!(D && !pt(D.currentTarget, et(D.nativeEvent))) && D && D.button === 0 && !b.isTriggeringEvent && !Uu.isOpening) {
                    let z = !0;
                    if (a && D.preventDefault(),
                    !b.ignoreEmulatedMouseEvents && !b.isPressed && (b.pointerType === "virtual" || yy(D.nativeEvent))) {
                        let $ = p(D, "virtual")
                          , Y = P(D, "virtual")
                          , ce = S(D, "virtual");
                        z = $ && Y && ce
                    } else if (b.isPressed && b.pointerType !== "keyboard") {
                        let $ = b.pointerType || D.nativeEvent.pointerType || "virtual";
                        z = S(Oa(D.currentTarget, D), $, !0),
                        b.isOverTarget = !1,
                        j(D)
                    }
                    b.ignoreEmulatedMouseEvents = !1,
                    z && D.stopPropagation()
                }
            }
        }
          , M = D => {
            var z;
            if (b.isPressed && b.target && Sm(D, b.target)) {
                var $;
                f1(et(D), D.key) && D.preventDefault();
                let ce = et(D);
                S(Oa(b.target, D), "keyboard", pt(b.target, et(D))),
                v(),
                D.key !== "Enter" && Tv(b.target) && pt(b.target, ce) && !D[u1] && (D[u1] = !0,
                Uu(b.target, D, !1)),
                b.isPressed = !1,
                ($ = b.metaKeyEvents) === null || $ === void 0 || $.delete(D.key)
            } else if (D.key === "Meta" && (!((z = b.metaKeyEvents) === null || z === void 0) && z.size)) {
                var Y;
                let ce = b.metaKeyEvents;
                b.metaKeyEvents = void 0;
                for (let Ke of ce.values())
                    (Y = b.target) === null || Y === void 0 || Y.dispatchEvent(new KeyboardEvent("keyup",Ke))
            }
        }
        ;
        if (typeof PointerEvent < "u") {
            O.onPointerDown = $ => {
                if ($.button !== 0 || !pt($.currentTarget, et($.nativeEvent)))
                    return;
                if (LB($.nativeEvent)) {
                    b.pointerType = "virtual";
                    return
                }
                b.pointerType = $.pointerType;
                let Y = !0;
                if (!b.isPressed) {
                    b.isPressed = !0,
                    b.isOverTarget = !0,
                    b.activePointerId = $.pointerId,
                    b.target = $.currentTarget,
                    f || a1(b.target),
                    Y = p($, b.pointerType);
                    let ce = et($.nativeEvent);
                    "releasePointerCapture"in ce && ce.releasePointerCapture($.pointerId),
                    w(pr($.currentTarget), "pointerup", D, !1),
                    w(pr($.currentTarget), "pointercancel", z, !1)
                }
                Y && $.stopPropagation()
            }
            ,
            O.onMouseDown = $ => {
                if (pt($.currentTarget, et($.nativeEvent)) && $.button === 0) {
                    if (l) {
                        let Y = o1($.target);
                        Y && b.disposables.push(Y)
                    }
                    $.stopPropagation()
                }
            }
            ,
            O.onPointerUp = $ => {
                !pt($.currentTarget, et($.nativeEvent)) || b.pointerType === "virtual" || $.button === 0 && P($, b.pointerType || $.pointerType)
            }
            ,
            O.onPointerEnter = $ => {
                $.pointerId === b.activePointerId && b.target && !b.isOverTarget && b.pointerType != null && (b.isOverTarget = !0,
                p(Oa(b.target, $), b.pointerType))
            }
            ,
            O.onPointerLeave = $ => {
                $.pointerId === b.activePointerId && b.target && b.isOverTarget && b.pointerType != null && (b.isOverTarget = !1,
                S(Oa(b.target, $), b.pointerType, !1),
                L($))
            }
            ;
            let D = $ => {
                if ($.pointerId === b.activePointerId && b.isPressed && $.button === 0 && b.target) {
                    if (pt(b.target, et($)) && b.pointerType != null) {
                        let Y = !1
                          , ce = setTimeout( () => {
                            b.isPressed && b.target instanceof HTMLElement && (Y ? j($) : (Uo(b.target),
                            b.target.click()))
                        }
                        , 80);
                        w($.currentTarget, "click", () => Y = !0, !0),
                        b.disposables.push( () => clearTimeout(ce))
                    } else
                        j($);
                    b.isOverTarget = !1
                }
            }
              , z = $ => {
                j($)
            }
            ;
            O.onDragStart = $ => {
                pt($.currentTarget, et($.nativeEvent)) && j($)
            }
        } else {
            O.onMouseDown = $ => {
                if ($.button !== 0 || !pt($.currentTarget, et($.nativeEvent)))
                    return;
                if (b.ignoreEmulatedMouseEvents) {
                    $.stopPropagation();
                    return
                }
                if (b.isPressed = !0,
                b.isOverTarget = !0,
                b.target = $.currentTarget,
                b.pointerType = yy($.nativeEvent) ? "virtual" : "mouse",
                ch.flushSync( () => p($, b.pointerType)) && $.stopPropagation(),
                l) {
                    let ce = o1($.target);
                    ce && b.disposables.push(ce)
                }
                w(pr($.currentTarget), "mouseup", D, !1)
            }
            ,
            O.onMouseEnter = $ => {
                if (!pt($.currentTarget, et($.nativeEvent)))
                    return;
                let Y = !0;
                b.isPressed && !b.ignoreEmulatedMouseEvents && b.pointerType != null && (b.isOverTarget = !0,
                Y = p($, b.pointerType)),
                Y && $.stopPropagation()
            }
            ,
            O.onMouseLeave = $ => {
                if (!pt($.currentTarget, et($.nativeEvent)))
                    return;
                let Y = !0;
                b.isPressed && !b.ignoreEmulatedMouseEvents && b.pointerType != null && (b.isOverTarget = !1,
                Y = S($, b.pointerType, !1),
                L($)),
                Y && $.stopPropagation()
            }
            ,
            O.onMouseUp = $ => {
                pt($.currentTarget, et($.nativeEvent)) && !b.ignoreEmulatedMouseEvents && $.button === 0 && P($, b.pointerType || "mouse")
            }
            ;
            let D = $ => {
                if ($.button === 0) {
                    if (b.ignoreEmulatedMouseEvents) {
                        b.ignoreEmulatedMouseEvents = !1;
                        return
                    }
                    b.target && b.target.contains($.target) && b.pointerType != null || j($),
                    b.isOverTarget = !1
                }
            }
            ;
            O.onTouchStart = $ => {
                if (!pt($.currentTarget, et($.nativeEvent)))
                    return;
                let Y = JB($.nativeEvent);
                if (!Y)
                    return;
                b.activePointerId = Y.identifier,
                b.ignoreEmulatedMouseEvents = !0,
                b.isOverTarget = !0,
                b.isPressed = !0,
                b.target = $.currentTarget,
                b.pointerType = "touch",
                f || a1(b.target),
                p(Cs(b.target, $), b.pointerType) && $.stopPropagation(),
                w(vn($.currentTarget), "scroll", z, !0)
            }
            ,
            O.onTouchMove = $ => {
                if (!pt($.currentTarget, et($.nativeEvent)))
                    return;
                if (!b.isPressed) {
                    $.stopPropagation();
                    return
                }
                let Y = c1($.nativeEvent, b.activePointerId)
                  , ce = !0;
                Y && d1(Y, $.currentTarget) ? !b.isOverTarget && b.pointerType != null && (b.isOverTarget = !0,
                ce = p(Cs(b.target, $), b.pointerType)) : b.isOverTarget && b.pointerType != null && (b.isOverTarget = !1,
                ce = S(Cs(b.target, $), b.pointerType, !1),
                L(Cs(b.target, $))),
                ce && $.stopPropagation()
            }
            ,
            O.onTouchEnd = $ => {
                if (!pt($.currentTarget, et($.nativeEvent)))
                    return;
                if (!b.isPressed) {
                    $.stopPropagation();
                    return
                }
                let Y = c1($.nativeEvent, b.activePointerId)
                  , ce = !0;
                Y && d1(Y, $.currentTarget) && b.pointerType != null ? (P(Cs(b.target, $), b.pointerType),
                ce = S(Cs(b.target, $), b.pointerType)) : b.isOverTarget && b.pointerType != null && (ce = S(Cs(b.target, $), b.pointerType, !1)),
                ce && $.stopPropagation(),
                b.isPressed = !1,
                b.activePointerId = null,
                b.isOverTarget = !1,
                b.ignoreEmulatedMouseEvents = !0,
                b.target && !f && wm(b.target),
                v()
            }
            ,
            O.onTouchCancel = $ => {
                pt($.currentTarget, et($.nativeEvent)) && ($.stopPropagation(),
                b.isPressed && j(Cs(b.target, $)))
            }
            ;
            let z = $ => {
                b.isPressed && pt(et($), b.target) && j({
                    currentTarget: b.target,
                    shiftKey: !1,
                    ctrlKey: !1,
                    metaKey: !1,
                    altKey: !1
                })
            }
            ;
            O.onDragStart = $ => {
                pt($.currentTarget, et($.nativeEvent)) && j($)
            }
        }
        return O
    }
    , [w, a, l, v, f, j, L, S, p, P]);
    return g.useEffect( () => {
        let b = x.current;
        return () => {
            var O;
            f || wm((O = b.target) !== null && O !== void 0 ? O : void 0);
            for (let M of b.disposables)
                M();
            b.disposables = []
        }
    }
    , [f]),
    {
        isPressed: o || y,
        pressProps: jr(m, E)
    }
}
function Tv(e) {
    return e.tagName === "A" && e.hasAttribute("href")
}
function Sm(e, t) {
    const {key: r, code: n} = e
      , s = t
      , i = s.getAttribute("role");
    return (r === "Enter" || r === " " || r === "Spacebar" || n === "Space") && !(s instanceof vn(s).HTMLInputElement && !$_(s, r) || s instanceof vn(s).HTMLTextAreaElement || s.isContentEditable) && !((i === "link" || !i && Tv(s)) && r !== "Enter")
}
function JB(e) {
    const {targetTouches: t} = e;
    return t.length > 0 ? t[0] : null
}
function c1(e, t) {
    const r = e.changedTouches;
    for (let n = 0; n < r.length; n++) {
        const s = r[n];
        if (s.identifier === t)
            return s
    }
    return null
}
function Cs(e, t) {
    let r = 0
      , n = 0;
    return t.targetTouches && t.targetTouches.length === 1 && (r = t.targetTouches[0].clientX,
    n = t.targetTouches[0].clientY),
    {
        currentTarget: e,
        shiftKey: t.shiftKey,
        ctrlKey: t.ctrlKey,
        metaKey: t.metaKey,
        altKey: t.altKey,
        clientX: r,
        clientY: n
    }
}
function Oa(e, t) {
    let r = t.clientX
      , n = t.clientY;
    return {
        currentTarget: e,
        shiftKey: t.shiftKey,
        ctrlKey: t.ctrlKey,
        metaKey: t.metaKey,
        altKey: t.altKey,
        clientX: r,
        clientY: n
    }
}
function XB(e) {
    let t = 0
      , r = 0;
    return e.width !== void 0 ? t = e.width / 2 : e.radiusX !== void 0 && (t = e.radiusX),
    e.height !== void 0 ? r = e.height / 2 : e.radiusY !== void 0 && (r = e.radiusY),
    {
        top: e.clientY - r,
        right: e.clientX + t,
        bottom: e.clientY + r,
        left: e.clientX - t
    }
}
function eW(e, t) {
    return !(e.left > t.right || t.left > e.right || e.top > t.bottom || t.top > e.bottom)
}
function d1(e, t) {
    let r = t.getBoundingClientRect()
      , n = XB(e);
    return eW(r, n)
}
function tW(e) {
    return e instanceof HTMLInputElement ? !1 : e instanceof HTMLButtonElement ? e.type !== "submit" && e.type !== "reset" : !Tv(e)
}
function f1(e, t) {
    return e instanceof HTMLInputElement ? !$_(e, t) : tW(e)
}
const rW = new Set(["checkbox", "radio", "range", "color", "file", "image", "button", "submit", "reset"]);
function $_(e, t) {
    return e.type === "checkbox" || e.type === "radio" ? t === " " : rW.has(e.type)
}
let Sa = null
  , by = new Set
  , eu = new Map
  , pa = !1
  , xy = !1;
const nW = {
    Tab: !0,
    Escape: !0
};
function wh(e, t) {
    for (let r of by)
        r(e, t)
}
function sW(e) {
    return !(e.metaKey || !zu() && e.altKey || e.ctrlKey || e.key === "Control" || e.key === "Shift" || e.key === "Meta")
}
function Nf(e) {
    pa = !0,
    sW(e) && (Sa = "keyboard",
    wh("keyboard", e))
}
function Kr(e) {
    Sa = "pointer",
    (e.type === "mousedown" || e.type === "pointerdown") && (pa = !0,
    wh("pointer", e))
}
function N_(e) {
    yy(e) && (pa = !0,
    Sa = "virtual")
}
function j_(e) {
    e.target === window || e.target === document || $f || !e.isTrusted || (!pa && !xy && (Sa = "virtual",
    wh("virtual", e)),
    pa = !1,
    xy = !1)
}
function I_() {
    $f || (pa = !1,
    xy = !0)
}
function wy(e) {
    if (typeof window > "u" || eu.get(vn(e)))
        return;
    const t = vn(e)
      , r = pr(e);
    let n = t.HTMLElement.prototype.focus;
    t.HTMLElement.prototype.focus = function() {
        pa = !0,
        n.apply(this, arguments)
    }
    ,
    r.addEventListener("keydown", Nf, !0),
    r.addEventListener("keyup", Nf, !0),
    r.addEventListener("click", N_, !0),
    t.addEventListener("focus", j_, !0),
    t.addEventListener("blur", I_, !1),
    typeof PointerEvent < "u" ? (r.addEventListener("pointerdown", Kr, !0),
    r.addEventListener("pointermove", Kr, !0),
    r.addEventListener("pointerup", Kr, !0)) : (r.addEventListener("mousedown", Kr, !0),
    r.addEventListener("mousemove", Kr, !0),
    r.addEventListener("mouseup", Kr, !0)),
    t.addEventListener("beforeunload", () => {
        R_(e)
    }
    , {
        once: !0
    }),
    eu.set(t, {
        focus: n
    })
}
const R_ = (e, t) => {
    const r = vn(e)
      , n = pr(e);
    t && n.removeEventListener("DOMContentLoaded", t),
    eu.has(r) && (r.HTMLElement.prototype.focus = eu.get(r).focus,
    n.removeEventListener("keydown", Nf, !0),
    n.removeEventListener("keyup", Nf, !0),
    n.removeEventListener("click", N_, !0),
    r.removeEventListener("focus", j_, !0),
    r.removeEventListener("blur", I_, !1),
    typeof PointerEvent < "u" ? (n.removeEventListener("pointerdown", Kr, !0),
    n.removeEventListener("pointermove", Kr, !0),
    n.removeEventListener("pointerup", Kr, !0)) : (n.removeEventListener("mousedown", Kr, !0),
    n.removeEventListener("mousemove", Kr, !0),
    n.removeEventListener("mouseup", Kr, !0)),
    eu.delete(r))
}
;
function iW(e) {
    const t = pr(e);
    let r;
    return t.readyState !== "loading" ? wy(e) : (r = () => {
        wy(e)
    }
    ,
    t.addEventListener("DOMContentLoaded", r)),
    () => R_(e, r)
}
typeof document < "u" && iW();
function O_() {
    return Sa !== "pointer"
}
function aW() {
    return Sa
}
function oW(e) {
    Sa = e,
    wh(e, null)
}
const lW = new Set(["checkbox", "radio", "range", "color", "file", "image", "button", "submit", "reset"]);
function uW(e, t, r) {
    let n = pr(r == null ? void 0 : r.target);
    const s = typeof window < "u" ? vn(r == null ? void 0 : r.target).HTMLInputElement : HTMLInputElement
      , i = typeof window < "u" ? vn(r == null ? void 0 : r.target).HTMLTextAreaElement : HTMLTextAreaElement
      , a = typeof window < "u" ? vn(r == null ? void 0 : r.target).HTMLElement : HTMLElement
      , o = typeof window < "u" ? vn(r == null ? void 0 : r.target).KeyboardEvent : KeyboardEvent;
    return e = e || n.activeElement instanceof s && !lW.has(n.activeElement.type) || n.activeElement instanceof i || n.activeElement instanceof a && n.activeElement.isContentEditable,
    !(e && t === "keyboard" && r instanceof o && !nW[r.key])
}
function cW(e, t, r) {
    wy(),
    g.useEffect( () => {
        let n = (s, i) => {
            uW(!!(r != null && r.isTextInput), s, i) && e(O_())
        }
        ;
        return by.add(n),
        () => {
            by.delete(n)
        }
    }
    , t)
}
function dW(e) {
    const t = pr(e)
      , r = Fu(t);
    if (aW() === "virtual") {
        let n = r;
        b_( () => {
            Fu(t) === n && e.isConnected && Uo(e)
        }
        )
    } else
        Uo(e)
}
function M_(e) {
    let {isDisabled: t, onFocus: r, onBlur: n, onFocusChange: s} = e;
    const i = g.useCallback(l => {
        if (l.target === l.currentTarget)
            return n && n(l),
            s && s(!1),
            !0
    }
    , [n, s])
      , a = C_(i)
      , o = g.useCallback(l => {
        const c = pr(l.target)
          , f = c ? Fu(c) : Fu();
        l.target === l.currentTarget && f === et(l.nativeEvent) && (r && r(l),
        s && s(!0),
        a(l))
    }
    , [s, r, a]);
    return {
        focusProps: {
            onFocus: !t && (r || s || n) ? o : void 0,
            onBlur: !t && (n || s) ? i : void 0
        }
    }
}
function h1(e) {
    if (!e)
        return;
    let t = !0;
    return r => {
        let n = {
            ...r,
            preventDefault() {
                r.preventDefault()
            },
            isDefaultPrevented() {
                return r.isDefaultPrevented()
            },
            stopPropagation() {
                t ? console.error("stopPropagation is now the default behavior for events in React Spectrum. You can use continuePropagation() to revert this behavior.") : t = !0
            },
            continuePropagation() {
                t = !1
            },
            isPropagationStopped() {
                return t
            }
        };
        e(n),
        t && r.stopPropagation()
    }
}
function fW(e) {
    return {
        keyboardProps: e.isDisabled ? {} : {
            onKeyDown: h1(e.onKeyDown),
            onKeyUp: h1(e.onKeyUp)
        }
    }
}
let hW = ve.createContext(null);
function mW(e) {
    let t = g.useContext(hW) || {};
    w_(t, e);
    let {ref: r, ...n} = t;
    return n
}
function pW(e, t) {
    let {focusProps: r} = M_(e)
      , {keyboardProps: n} = fW(e)
      , s = jr(r, n)
      , i = mW(t)
      , a = e.isDisabled ? {} : i
      , o = g.useRef(e.autoFocus);
    g.useEffect( () => {
        o.current && t.current && dW(t.current),
        o.current = !1
    }
    , [t]);
    let l = e.excludeFromTabOrder ? -1 : 0;
    return e.isDisabled && (l = void 0),
    {
        focusableProps: jr({
            ...s,
            tabIndex: l
        }, a)
    }
}
function Cv(e) {
    let {isDisabled: t, onBlurWithin: r, onFocusWithin: n, onFocusWithinChange: s} = e
      , i = g.useRef({
        isFocusWithin: !1
    })
      , {addGlobalListener: a, removeAllGlobalListeners: o} = kv()
      , l = g.useCallback(h => {
        h.currentTarget.contains(h.target) && i.current.isFocusWithin && !h.currentTarget.contains(h.relatedTarget) && (i.current.isFocusWithin = !1,
        o(),
        r && r(h),
        s && s(!1))
    }
    , [r, s, i, o])
      , c = C_(l)
      , f = g.useCallback(h => {
        if (!h.currentTarget.contains(h.target))
            return;
        const m = pr(h.target)
          , y = Fu(m);
        if (!i.current.isFocusWithin && y === et(h.nativeEvent)) {
            n && n(h),
            s && s(!0),
            i.current.isFocusWithin = !0,
            c(h);
            let k = h.currentTarget;
            a(m, "focus", x => {
                if (i.current.isFocusWithin && !pt(k, x.target)) {
                    let w = new T_("blur",new m.defaultView.FocusEvent("blur",{
                        relatedTarget: x.target
                    }));
                    w.target = k,
                    w.currentTarget = k,
                    l(w)
                }
            }
            , {
                capture: !0
            })
        }
    }
    , [n, s, c, a, l]);
    return t ? {
        focusWithinProps: {
            onFocus: void 0,
            onBlur: void 0
        }
    } : {
        focusWithinProps: {
            onFocus: f,
            onBlur: l
        }
    }
}
let jf = !1
  , km = 0;
function Sy() {
    jf = !0,
    setTimeout( () => {
        jf = !1
    }
    , 50)
}
function m1(e) {
    e.pointerType === "touch" && Sy()
}
function yW() {
    if (!(typeof document > "u"))
        return typeof PointerEvent < "u" ? document.addEventListener("pointerup", m1) : document.addEventListener("touchend", Sy),
        km++,
        () => {
            km--,
            !(km > 0) && (typeof PointerEvent < "u" ? document.removeEventListener("pointerup", m1) : document.removeEventListener("touchend", Sy))
        }
}
function gW(e) {
    let {onHoverStart: t, onHoverChange: r, onHoverEnd: n, isDisabled: s} = e
      , [i,a] = g.useState(!1)
      , o = g.useRef({
        isHovered: !1,
        ignoreEmulatedMouseEvents: !1,
        pointerType: "",
        target: null
    }).current;
    g.useEffect(yW, []);
    let {addGlobalListener: l, removeAllGlobalListeners: c} = kv()
      , {hoverProps: f, triggerHoverEnd: h} = g.useMemo( () => {
        let m = (x, w) => {
            if (o.pointerType = w,
            s || w === "touch" || o.isHovered || !x.currentTarget.contains(x.target))
                return;
            o.isHovered = !0;
            let v = x.currentTarget;
            o.target = v,
            l(pr(x.target), "pointerover", p => {
                o.isHovered && o.target && !pt(o.target, p.target) && y(p, p.pointerType)
            }
            , {
                capture: !0
            }),
            t && t({
                type: "hoverstart",
                target: v,
                pointerType: w
            }),
            r && r(!0),
            a(!0)
        }
          , y = (x, w) => {
            let v = o.target;
            o.pointerType = "",
            o.target = null,
            !(w === "touch" || !o.isHovered || !v) && (o.isHovered = !1,
            c(),
            n && n({
                type: "hoverend",
                target: v,
                pointerType: w
            }),
            r && r(!1),
            a(!1))
        }
          , k = {};
        return typeof PointerEvent < "u" ? (k.onPointerEnter = x => {
            jf && x.pointerType === "mouse" || m(x, x.pointerType)
        }
        ,
        k.onPointerLeave = x => {
            !s && x.currentTarget.contains(x.target) && y(x, x.pointerType)
        }
        ) : (k.onTouchStart = () => {
            o.ignoreEmulatedMouseEvents = !0
        }
        ,
        k.onMouseEnter = x => {
            !o.ignoreEmulatedMouseEvents && !jf && m(x, "mouse"),
            o.ignoreEmulatedMouseEvents = !1
        }
        ,
        k.onMouseLeave = x => {
            !s && x.currentTarget.contains(x.target) && y(x, "mouse")
        }
        ),
        {
            hoverProps: k,
            triggerHoverEnd: y
        }
    }
    , [t, r, n, s, o, l, c]);
    return g.useEffect( () => {
        s && h({
            currentTarget: o.target
        }, o.pointerType)
    }
    , [s]),
    {
        hoverProps: f,
        isHovered: i
    }
}
function vW(e={}) {
    let {autoFocus: t=!1, isTextInput: r, within: n} = e
      , s = g.useRef({
        isFocused: !1,
        isFocusVisible: t || O_()
    })
      , [i,a] = g.useState(!1)
      , [o,l] = g.useState( () => s.current.isFocused && s.current.isFocusVisible)
      , c = g.useCallback( () => l(s.current.isFocused && s.current.isFocusVisible), [])
      , f = g.useCallback(y => {
        s.current.isFocused = y,
        a(y),
        c()
    }
    , [c]);
    cW(y => {
        s.current.isFocusVisible = y,
        c()
    }
    , [], {
        isTextInput: r
    });
    let {focusProps: h} = M_({
        isDisabled: n,
        onFocusChange: f
    })
      , {focusWithinProps: m} = Cv({
        isDisabled: !n,
        onFocusWithinChange: f
    });
    return {
        isFocused: i,
        isFocusVisible: o,
        focusProps: n ? m : h
    }
}
const Pv = {
    badInput: !1,
    customError: !1,
    patternMismatch: !1,
    rangeOverflow: !1,
    rangeUnderflow: !1,
    stepMismatch: !1,
    tooLong: !1,
    tooShort: !1,
    typeMismatch: !1,
    valueMissing: !1,
    valid: !0
}
  , A_ = {
    ...Pv,
    customError: !0,
    valid: !1
}
  , Ua = {
    isInvalid: !1,
    validationDetails: Pv,
    validationErrors: []
}
  , bW = g.createContext({})
  , If = "__formValidationState" + Date.now();
function $v(e) {
    if (e[If]) {
        let {realtimeValidation: t, displayValidation: r, updateValidation: n, resetValidation: s, commitValidation: i} = e[If];
        return {
            realtimeValidation: t,
            displayValidation: r,
            updateValidation: n,
            resetValidation: s,
            commitValidation: i
        }
    }
    return xW(e)
}
function xW(e) {
    let {isInvalid: t, validationState: r, name: n, value: s, builtinValidation: i, validate: a, validationBehavior: o="aria"} = e;
    r && (t || (t = r === "invalid"));
    let l = t !== void 0 ? {
        isInvalid: t,
        validationErrors: [],
        validationDetails: A_
    } : null
      , c = g.useMemo( () => {
        if (!a || s == null)
            return null;
        let M = wW(a, s);
        return p1(M)
    }
    , [a, s]);
    i != null && i.validationDetails.valid && (i = void 0);
    let f = g.useContext(bW)
      , h = g.useMemo( () => n ? Array.isArray(n) ? n.flatMap(M => ky(f[M])) : ky(f[n]) : [], [f, n])
      , [m,y] = g.useState(f)
      , [k,x] = g.useState(!1);
    f !== m && (y(f),
    x(!1));
    let w = g.useMemo( () => p1(k ? [] : h), [k, h])
      , v = g.useRef(Ua)
      , [p,S] = g.useState(Ua)
      , P = g.useRef(Ua)
      , j = () => {
        if (!L)
            return;
        E(!1);
        let M = c || i || v.current;
        Em(M, P.current) || (P.current = M,
        S(M))
    }
      , [L,E] = g.useState(!1);
    return g.useEffect(j),
    {
        realtimeValidation: l || w || c || i || Ua,
        displayValidation: o === "native" ? l || w || p : l || w || c || i || p,
        updateValidation(M) {
            o === "aria" && !Em(p, M) ? S(M) : v.current = M
        },
        resetValidation() {
            let M = Ua;
            Em(M, P.current) || (P.current = M,
            S(M)),
            o === "native" && E(!1),
            x(!0)
        },
        commitValidation() {
            o === "native" && E(!0),
            x(!0)
        }
    }
}
function ky(e) {
    return e ? Array.isArray(e) ? e : [e] : []
}
function wW(e, t) {
    if (typeof e == "function") {
        let r = e(t);
        if (r && typeof r != "boolean")
            return ky(r)
    }
    return []
}
function p1(e) {
    return e.length ? {
        isInvalid: !0,
        validationErrors: e,
        validationDetails: A_
    } : null
}
function Em(e, t) {
    return e === t ? !0 : !!e && !!t && e.isInvalid === t.isInvalid && e.validationErrors.length === t.validationErrors.length && e.validationErrors.every( (r, n) => r === t.validationErrors[n]) && Object.entries(e.validationDetails).every( ([r,n]) => t.validationDetails[r] === n)
}
function SW(...e) {
    let t = new Set
      , r = !1
      , n = {
        ...Pv
    };
    for (let a of e) {
        var s, i;
        for (let o of a.validationErrors)
            t.add(o);
        r || (r = a.isInvalid);
        for (let o in n)
            (s = n)[i = o] || (s[i] = a.validationDetails[o])
    }
    return n.valid = !r,
    {
        isInvalid: r,
        validationErrors: [...t],
        validationDetails: n
    }
}
function kW(e, t, r) {
    let {validationBehavior: n, focus: s} = e;
    _i( () => {
        if (n === "native" && (r != null && r.current) && !r.current.disabled) {
            let l = t.realtimeValidation.isInvalid ? t.realtimeValidation.validationErrors.join(" ") || "Invalid value." : "";
            r.current.setCustomValidity(l),
            r.current.hasAttribute("title") || (r.current.title = ""),
            t.realtimeValidation.isInvalid || t.updateValidation(_W(r.current))
        }
    }
    );
    let i = Qr( () => {
        t.resetValidation()
    }
    )
      , a = Qr(l => {
        var c;
        t.displayValidation.isInvalid || t.commitValidation();
        let f = r == null || (c = r.current) === null || c === void 0 ? void 0 : c.form;
        if (!l.defaultPrevented && r && f && TW(f) === r.current) {
            var h;
            s ? s() : (h = r.current) === null || h === void 0 || h.focus(),
            oW("keyboard")
        }
        l.preventDefault()
    }
    )
      , o = Qr( () => {
        t.commitValidation()
    }
    );
    g.useEffect( () => {
        let l = r == null ? void 0 : r.current;
        if (!l)
            return;
        let c = l.form;
        return l.addEventListener("invalid", a),
        l.addEventListener("change", o),
        c == null || c.addEventListener("reset", i),
        () => {
            l.removeEventListener("invalid", a),
            l.removeEventListener("change", o),
            c == null || c.removeEventListener("reset", i)
        }
    }
    , [r, a, o, i, n])
}
function EW(e) {
    let t = e.validity;
    return {
        badInput: t.badInput,
        customError: t.customError,
        patternMismatch: t.patternMismatch,
        rangeOverflow: t.rangeOverflow,
        rangeUnderflow: t.rangeUnderflow,
        stepMismatch: t.stepMismatch,
        tooLong: t.tooLong,
        tooShort: t.tooShort,
        typeMismatch: t.typeMismatch,
        valueMissing: t.valueMissing,
        valid: t.valid
    }
}
function _W(e) {
    return {
        isInvalid: !e.validity.valid,
        validationDetails: EW(e),
        validationErrors: e.validationMessage ? [e.validationMessage] : []
    }
}
function TW(e) {
    for (let t = 0; t < e.elements.length; t++) {
        let r = e.elements[t];
        if (!r.validity.valid)
            return r
    }
    return null
}
function CW(e, t, r) {
    let {isDisabled: n=!1, isReadOnly: s=!1, value: i, name: a, children: o, "aria-label": l, "aria-labelledby": c, validationState: f="valid", isInvalid: h} = e
      , m = L => {
        L.stopPropagation(),
        t.setSelected(L.target.checked)
    }
      , y = o != null
      , k = l != null || c != null;
    !y && !k && console.warn("If you do not provide children, you must specify an aria-label for accessibility");
    let {pressProps: x, isPressed: w} = vy({
        isDisabled: n
    })
      , {pressProps: v, isPressed: p} = vy({
        onPress() {
            var L;
            t.toggle(),
            (L = r.current) === null || L === void 0 || L.focus()
        },
        isDisabled: n || s
    })
      , {focusableProps: S} = pW(e, r)
      , P = jr(x, S)
      , j = wv(e, {
        labelable: !0
    });
    return DB(r, t.isSelected, t.setSelected),
    {
        labelProps: jr(v, {
            onClick: L => L.preventDefault()
        }),
        inputProps: jr(j, {
            "aria-invalid": h || f === "invalid" || void 0,
            "aria-errormessage": e["aria-errormessage"],
            "aria-controls": e["aria-controls"],
            "aria-readonly": s || void 0,
            onChange: m,
            disabled: n,
            ...i == null ? {} : {
                value: i
            },
            name: a,
            type: "checkbox",
            ...P
        }),
        isSelected: t.isSelected,
        isPressed: w || p,
        isDisabled: n,
        isReadOnly: s,
        isInvalid: h || f === "invalid"
    }
}
function L_(e, t, r) {
    let n = $v({
        ...e,
        value: t.isSelected
    })
      , {isInvalid: s, validationErrors: i, validationDetails: a} = n.displayValidation
      , {labelProps: o, inputProps: l, isSelected: c, isPressed: f, isDisabled: h, isReadOnly: m} = CW({
        ...e,
        isInvalid: s
    }, t, r);
    kW(e, n, r);
    let {isIndeterminate: y, isRequired: k, validationBehavior: x="aria"} = e;
    g.useEffect( () => {
        r.current && (r.current.indeterminate = !!y)
    }
    );
    let {pressProps: w} = vy({
        isDisabled: h || m,
        onPress() {
            let {[If]: v} = e
              , {commitValidation: p} = v || n;
            p()
        }
    });
    return {
        labelProps: jr(o, w),
        inputProps: {
            ...l,
            checked: c,
            "aria-required": k && x === "aria" || void 0,
            required: k && x === "native"
        },
        isSelected: c,
        isPressed: f,
        isDisabled: h,
        isReadOnly: m,
        isInvalid: s,
        validationErrors: i,
        validationDetails: a
    }
}
const D_ = new WeakMap;
function PW(e) {
    let {id: t, label: r, "aria-labelledby": n, "aria-label": s, labelElementType: i="label"} = e;
    t = Pf(t);
    let a = Pf()
      , o = {};
    r ? (n = n ? `${a} ${n}` : a,
    o = {
        id: a,
        htmlFor: i === "label" ? t : void 0
    }) : !n && !s && console.warn("If you do not provide a visible label, you must specify an aria-label or aria-labelledby attribute for accessibility");
    let l = AB({
        id: t,
        "aria-label": s,
        "aria-labelledby": n
    });
    return {
        labelProps: o,
        fieldProps: l
    }
}
function $W(e) {
    let {description: t, errorMessage: r, isInvalid: n, validationState: s} = e
      , {labelProps: i, fieldProps: a} = PW(e)
      , o = n1([!!t, !!r, n, s])
      , l = n1([!!t, !!r, n, s]);
    return a = jr(a, {
        "aria-describedby": [o, l, e["aria-describedby"]].filter(Boolean).join(" ") || void 0
    }),
    {
        labelProps: i,
        fieldProps: a,
        descriptionProps: {
            id: o
        },
        errorMessageProps: {
            id: l
        }
    }
}
function NW(e, t) {
    let {isDisabled: r, name: n, validationBehavior: s="aria"} = e
      , {isInvalid: i, validationErrors: a, validationDetails: o} = t.displayValidation
      , {labelProps: l, fieldProps: c, descriptionProps: f, errorMessageProps: h} = $W({
        ...e,
        labelElementType: "span",
        isInvalid: i,
        errorMessage: e.errorMessage || a
    });
    D_.set(t, {
        name: n,
        descriptionId: f.id,
        errorMessageId: h.id,
        validationBehavior: s
    });
    let m = wv(e, {
        labelable: !0
    })
      , {focusWithinProps: y} = Cv({
        onBlurWithin: e.onBlur,
        onFocusWithin: e.onFocus,
        onFocusWithinChange: e.onFocusChange
    });
    return {
        groupProps: jr(m, {
            role: "group",
            "aria-disabled": r || void 0,
            ...c,
            ...y
        }),
        labelProps: l,
        descriptionProps: f,
        errorMessageProps: h,
        isInvalid: i,
        validationErrors: a,
        validationDetails: o
    }
}
function F_(e={}) {
    let {isReadOnly: t} = e
      , [r,n] = k_(e.isSelected, e.defaultSelected || !1, e.onChange);
    function s(a) {
        t || n(a)
    }
    function i() {
        t || n(!r)
    }
    return {
        isSelected: r,
        setSelected: s,
        toggle: i
    }
}
function jW(e, t, r) {
    const n = F_({
        isReadOnly: e.isReadOnly || t.isReadOnly,
        isSelected: t.isSelected(e.value),
        onChange(w) {
            w ? t.addValue(e.value) : t.removeValue(e.value),
            e.onChange && e.onChange(w)
        }
    });
    let {name: s, descriptionId: i, errorMessageId: a, validationBehavior: o} = D_.get(t);
    var l;
    o = (l = e.validationBehavior) !== null && l !== void 0 ? l : o;
    let {realtimeValidation: c} = $v({
        ...e,
        value: n.isSelected,
        name: void 0,
        validationBehavior: "aria"
    })
      , f = g.useRef(Ua)
      , h = () => {
        t.setInvalid(e.value, c.isInvalid ? c : f.current)
    }
    ;
    g.useEffect(h);
    let m = t.realtimeValidation.isInvalid ? t.realtimeValidation : c
      , y = o === "native" ? t.displayValidation : m;
    var k;
    let x = L_({
        ...e,
        isReadOnly: e.isReadOnly || t.isReadOnly,
        isDisabled: e.isDisabled || t.isDisabled,
        name: e.name || s,
        isRequired: (k = e.isRequired) !== null && k !== void 0 ? k : t.isRequired,
        validationBehavior: o,
        [If]: {
            realtimeValidation: m,
            displayValidation: y,
            resetValidation: t.resetValidation,
            commitValidation: t.commitValidation,
            updateValidation(w) {
                f.current = w,
                h()
            }
        }
    }, n, r);
    return {
        ...x,
        inputProps: {
            ...x.inputProps,
            "aria-describedby": [e["aria-describedby"], t.isInvalid ? a : null, i].filter(Boolean).join(" ") || void 0
        }
    }
}
const y1 = {
    border: 0,
    clip: "rect(0 0 0 0)",
    clipPath: "inset(50%)",
    height: "1px",
    margin: "-1px",
    overflow: "hidden",
    padding: 0,
    position: "absolute",
    width: "1px",
    whiteSpace: "nowrap"
};
function IW(e={}) {
    let {style: t, isFocusable: r} = e
      , [n,s] = g.useState(!1)
      , {focusWithinProps: i} = Cv({
        isDisabled: !r,
        onFocusWithinChange: o => s(o)
    })
      , a = g.useMemo( () => n ? t : t ? {
        ...y1,
        ...t
    } : y1, [n]);
    return {
        visuallyHiddenProps: {
            ...i,
            style: a
        }
    }
}
function RW(e) {
    let {children: t, elementType: r="div", isFocusable: n, style: s, ...i} = e
      , {visuallyHiddenProps: a} = IW(e);
    return ve.createElement(r, jr(i, a), t)
}
const z_ = g.createContext({})
  , g1 = qB(function(t, r) {
    [t,r] = _v(t, r, z_);
    let {elementType: n="label", ...s} = t;
    return ve.createElement(n, {
        className: "react-aria-Label",
        ...s,
        ref: r
    })
})
  , OW = g.createContext({})
  , MW = g.createContext(null);
function AW(e={}) {
    let[t,r] = k_(e.value, e.defaultValue || [], e.onChange)
      , n = !!e.isRequired && t.length === 0
      , s = g.useRef(new Map)
      , i = $v({
        ...e,
        value: t
    })
      , a = i.displayValidation.isInvalid;
    var o;
    return {
        ...i,
        value: t,
        setValue(c) {
            e.isReadOnly || e.isDisabled || r(c)
        },
        isDisabled: e.isDisabled || !1,
        isReadOnly: e.isReadOnly || !1,
        isSelected(c) {
            return t.includes(c)
        },
        addValue(c) {
            e.isReadOnly || e.isDisabled || t.includes(c) || r(t.concat(c))
        },
        removeValue(c) {
            e.isReadOnly || e.isDisabled || t.includes(c) && r(t.filter(f => f !== c))
        },
        toggleValue(c) {
            e.isReadOnly || e.isDisabled || (t.includes(c) ? r(t.filter(f => f !== c)) : r(t.concat(c)))
        },
        setInvalid(c, f) {
            let h = new Map(s.current);
            f.isInvalid ? h.set(c, f) : h.delete(c),
            s.current = h,
            i.updateValidation(SW(...h.values()))
        },
        validationState: (o = e.validationState) !== null && o !== void 0 ? o : a ? "invalid" : null,
        isInvalid: a,
        isRequired: n
    }
}
const U_ = g.createContext(null)
  , LW = g.createContext(null)
  , V_ = g.createContext(null)
  , DW = g.forwardRef(function(t, r) {
    [t,r] = _v(t, r, LW);
    let {validationBehavior: n} = Ev(U_) || {};
    var s, i;
    let a = (i = (s = t.validationBehavior) !== null && s !== void 0 ? s : n) !== null && i !== void 0 ? i : "native"
      , o = AW({
        ...t,
        validationBehavior: a
    })
      , [l,c] = BB(!t["aria-label"] && !t["aria-labelledby"])
      , {groupProps: f, labelProps: h, descriptionProps: m, errorMessageProps: y, ...k} = NW({
        ...t,
        label: c,
        validationBehavior: a
    }, o)
      , x = E_({
        ...t,
        values: {
            isDisabled: o.isDisabled,
            isReadOnly: o.isReadOnly,
            isRequired: t.isRequired || !1,
            isInvalid: o.isInvalid,
            state: o
        },
        defaultClassName: "react-aria-CheckboxGroup"
    });
    return ve.createElement("div", {
        ...f,
        ...x,
        ref: r,
        slot: t.slot || void 0,
        "data-readonly": o.isReadOnly || void 0,
        "data-required": t.isRequired || void 0,
        "data-invalid": o.isInvalid || void 0,
        "data-disabled": t.isDisabled || void 0
    }, ve.createElement(VB, {
        values: [[V_, o], [z_, {
            ...h,
            ref: l,
            elementType: "span"
        }], [OW, {
            slots: {
                description: m,
                errorMessage: y
            }
        }], [MW, k]]
    }, x.children))
})
  , B_ = g.forwardRef(function(t, r) {
    let {inputRef: n=null, ...s} = t;
    [t,r] = _v(s, r, lB);
    let {validationBehavior: i} = Ev(U_) || {};
    var a, o;
    let l = (o = (a = t.validationBehavior) !== null && a !== void 0 ? a : i) !== null && o !== void 0 ? o : "native"
      , c = g.useContext(V_)
      , f = x_(p_(n, t.inputRef !== void 0 ? t.inputRef : null))
      , {labelProps: h, inputProps: m, isSelected: y, isDisabled: k, isReadOnly: x, isPressed: w, isInvalid: v} = c ? jW({
        ...i1(t),
        value: t.value,
        children: typeof t.children == "function" ? !0 : t.children
    }, c, f) : L_({
        ...i1(t),
        children: typeof t.children == "function" ? !0 : t.children,
        validationBehavior: l
    }, F_(t), f)
      , {isFocused: p, isFocusVisible: S, focusProps: P} = vW()
      , j = k || x
      , {hoverProps: L, isHovered: E} = gW({
        ...t,
        isDisabled: j
    })
      , b = E_({
        ...t,
        defaultClassName: "react-aria-Checkbox",
        values: {
            isSelected: y,
            isIndeterminate: t.isIndeterminate || !1,
            isPressed: w,
            isHovered: E,
            isFocused: p,
            isFocusVisible: S,
            isDisabled: k,
            isReadOnly: x,
            isInvalid: v,
            isRequired: t.isRequired || !1
        }
    })
      , O = wv(t);
    return delete O.id,
    ve.createElement("label", {
        ...jr(O, h, L, b),
        ref: r,
        slot: t.slot || void 0,
        "data-selected": y || void 0,
        "data-indeterminate": t.isIndeterminate || void 0,
        "data-pressed": w || void 0,
        "data-hovered": E || void 0,
        "data-focused": p || void 0,
        "data-focus-visible": S || void 0,
        "data-disabled": k || void 0,
        "data-readonly": x || void 0,
        "data-invalid": v || void 0,
        "data-required": t.isRequired || void 0
    }, ve.createElement(RW, {
        elementType: "span"
    }, ve.createElement("input", {
        ...jr(m, P),
        ref: f
    })), b.children)
});
function W_({onIntersect: e, isLoading: t, disabled: r, ...n}) {
    const s = g.useRef(null)
      , i = g.useRef(null);
    return g.useEffect( () => {
        var a;
        if (s.current) {
            if (r) {
                (a = i.current) == null || a.disconnect();
                return
            }
            return i.current = new IntersectionObserver( ([o]) => {
                o.isIntersecting && e()
            }
            ,{
                root: null,
                rootMargin: "0px",
                threshold: 0
            }),
            i.current.observe(s.current),
            () => {
                var o;
                return (o = i.current) == null ? void 0 : o.disconnect()
            }
        }
    }
    , [e, r]),
    d.jsx("div", {
        ref: s,
        ...n,
        className: fe("flex items-center justify-center h-20 pb-6", n.className),
        children: t && d.jsx(ar, {
            size: "md"
        })
    })
}
const FW = [Xi.pending, Xi.valid, Xi.invalid]
  , zW = {
    [Xi.pending]: sy,
    [Xi.valid]: iy,
    [Xi.invalid]: ay
};
function UW() {
    var s;
    const e = zk()
      , [t,r] = g.useState([Xi.pending])
      , n = o9({
        status: t
    });
    return d.jsxs(d.Fragment, {
        children: [d.jsx("section", {
            className: "flex flex-1 w-full h-full overflow-auto",
            children: d.jsx("div", {
                className: "relative flex-1 overflow-hidden",
                children: d.jsxs("div", {
                    className: "absolute top-0 right-0 bottom-0 left-0 overflow-auto",
                    children: [d.jsx("div", {
                        className: "px-10 py-5",
                        children: d.jsxs("ul", {
                            className: "p-4 space-y-2 border border-gray-200 rounded shadow",
                            children: [d.jsxs("li", {
                                children: [d.jsx(sy, {
                                    className: "text-orange-500 mr-2 inline-block"
                                }), " ", d.jsx("span", {
                                    className: "",
                                    children: "Pending"
                                }), " reports are waiting to be reviewed by moderators."]
                            }), d.jsxs("li", {
                                children: [d.jsx(iy, {
                                    className: "text-gray-500 mr-2 inline-block"
                                }), " ", d.jsx("span", {
                                    className: "",
                                    children: "Valid"
                                }), " reports were accurate in their claims and have been handled."]
                            }), d.jsxs("li", {
                                children: [d.jsx(ay, {
                                    className: "text-gray-500 mr-2 inline-block opacity-25"
                                }), " ", d.jsx("span", {
                                    className: "",
                                    children: "Invalid"
                                }), " claims are ignored."]
                            })]
                        })
                    }), d.jsxs("div", {
                        className: "flex items-center my-10 mx-10",
                        children: [d.jsxs("div", {
                            children: [d.jsx("p", {
                                children: "Status"
                            }), d.jsx(DW, {
                                value: t,
                                onChange: i => r(i.map(a => Gu.parse(a))),
                                className: "flex items-center gap-8 mt-2",
                                children: FW.map(i => {
                                    const a = zW[i];
                                    return d.jsx(B_, {
                                        value: i,
                                        className: "flex items-center",
                                        children: ({isSelected: o}) => d.jsxs("p", {
                                            className: fe("flex items-center gap-1 capitalize", !o && "opacity-25 hover:opacity-50"),
                                            children: [d.jsx(a, {}), i]
                                        })
                                    }, i)
                                }
                                )
                            })]
                        }), d.jsx("div", {
                            className: "ml-auto",
                            children: d.jsxs("button", {
                                type: "button",
                                className: "ml-auto flex items-center opacity-50 hover:opacity-100 disabled:opacity-10 transition-opacity text-lg",
                                onClick: () => n.refetch(),
                                children: [d.jsx(sE, {
                                    className: "w-5 h-5 mr-2"
                                }), "Refresh"]
                            })
                        })]
                    }), n.isRefetching && d.jsx("div", {
                        className: "flex items-center justify-center w-full my-10",
                        children: d.jsx(ar, {
                            size: "md"
                        })
                    }), d.jsxs("ul", {
                        className: "px-10 py-5",
                        children: [d.jsxs("li", {
                            className: "grid grid-cols-4 p-2",
                            children: [d.jsx("div", {
                                className: "w-24"
                            }), d.jsx("p", {
                                className: "flex items-center gap-5",
                                children: d.jsx("span", {
                                    className: "text-gray-500",
                                    children: "Status"
                                })
                            }), d.jsx("p", {
                                className: "text-gray-500",
                                children: "Type"
                            }), d.jsx("p", {
                                className: "text-gray-500",
                                children: "Total Reports"
                            })]
                        }), (s = n.data) == null ? void 0 : s.pages.map(i => i.ok ? d.jsx(g.Fragment, {
                            children: i.value.items.map(a => d.jsx("li", {
                                children: d.jsxs(Kt, {
                                    to: `/admin/reports/${a.id}`,
                                    className: fe("grid grid-cols-4 p-2 my-2 rounded-lg border border-transparent hover:border-gray-100 hover:bg-gray-50", e.id === a.id && "bg-blue-50", a.status === "invalid" && "opacity-25"),
                                    children: [d.jsx("p", {
                                        className: "text-sm w-24",
                                        children: bh(a.createdAt)
                                    }), d.jsxs("p", {
                                        className: "capitalize flex items-center gap-2",
                                        children: [{
                                            pending: d.jsx(sy, {
                                                className: "text-orange-500"
                                            }),
                                            valid: d.jsx(iy, {
                                                className: "text-gray-500"
                                            }),
                                            invalid: d.jsx(ay, {
                                                className: "text-gray-500"
                                            })
                                        }[a.status], a.status]
                                    }), d.jsx("p", {
                                        children: a.type
                                    }), d.jsx("p", {
                                        children: a.totalReports
                                    })]
                                })
                            }, a.id))
                        }, i.value.nextCursor) : null)]
                    }), d.jsx(W_, {
                        onIntersect: n.fetchNextPage,
                        isLoading: n.isFetchingNextPage,
                        disabled: !n.hasNextPage
                    })]
                })
            })
        }), d.jsx(el, {})]
    })
}
function VW({onConfirmedSubmit: e, label: t, confirmLabel: r, disabled: n, destructive: s, ...i}) {
    const [a,o] = g.useState(!1);
    return a ? d.jsxs("div", {
        className: "flex items-center h-[3.25rem] gap-3",
        children: [d.jsx("button", {
            type: "submit",
            onClick: () => {
                e == null || e( () => o(!1))
            }
            ,
            disabled: n,
            className: fe("opacity-75 hover:opacity-100 px-2 py-1 rounded", s ? "bg-red-50 text-red-700" : "bg-blu-50 text-blu-700"),
            children: r
        }), d.jsx("button", {
            type: "button",
            onClick: () => o(!1),
            disabled: n,
            className: "opacity-75 hover:opacity-100 px-2 py-1",
            children: "Cancel"
        })]
    }) : d.jsx(at, {
        variant: "filled",
        bg: s ? "red" : "blue",
        disabled: n,
        onClick: () => {
            o(!0)
        }
        ,
        children: t
    })
}
const v1 = [{
    label: "30 second timeout",
    duration: 30
}, {
    label: "15 minutes",
    duration: 60 * 15
}, {
    label: "1 hour",
    duration: 60 * 60 * 1
}, {
    label: "3 hours",
    duration: 60 * 60 * 3
}, {
    label: "1 day",
    duration: 60 * 60 * 24
}, {
    label: "3 days",
    duration: 60 * 60 * 24 * 3
}];
function BW() {
    const e = Je()
      , [t,r] = ir()
      , [n,s] = g.useState(t.get("username") ?? "")
      , [i,a] = g.useState(v1[0].duration)
      , [o,l] = g.useState("")
      , c = K7()
      , f = G7();
    return g.useEffect( () => {
        t.set("username", n),
        r(t)
    }
    , [t, r, n]),
    d.jsx(d.Fragment, {
        children: d.jsxs("section", {
            className: "flex flex-col flex-1 w-full h-full overflow-auto pb-10",
            children: [d.jsx("div", {
                className: "px-10 w-full my-6",
                children: d.jsxs("div", {
                    className: "rounded-xl bg-gray-50 p-4 w-full space-y-4",
                    children: [d.jsx("h2", {
                        className: "font-sans font-bold text-3xl uppercase",
                        children: "Caution!!!"
                    }), d.jsx("p", {
                        className: "text-slate-600 max-w-xl",
                        children: "There is a log of all bans. Please, do not ban users without a valid reason."
                    })]
                })
            }), d.jsxs("div", {
                className: "px-10",
                children: [d.jsxs("div", {
                    className: "flex items-center gap-4",
                    children: [d.jsx("input", {
                        name: "username",
                        type: "search",
                        className: "w-96 px-4 py-3 border border-gray-400 rounded text-xl",
                        placeholder: "Username",
                        value: n,
                        onInput: h => s(h.currentTarget.value)
                    }), e.isAdmin && d.jsx("div", {
                        className: "flex items-center my-6 opacity-10 hover:opacity-100",
                        children: d.jsx("button", {
                            type: "button",
                            onClick: () => f.mutateAsync({
                                username: n
                            }),
                            className: "px-4 py-2 bg-yellow-500 text-white rounded hover:bg-yellow-600",
                            children: "Go to"
                        })
                    })]
                }), d.jsxs("div", {
                    className: "my-6",
                    children: [d.jsx("label", {
                        className: "block mb-2 text-lg",
                        htmlFor: "reason",
                        children: "Reason for ban:"
                    }), d.jsx("textarea", {
                        id: "reason",
                        name: "reason",
                        className: "w-full max-w-[620px] px-4 py-3 border border-gray-400 rounded text-xl",
                        placeholder: "What did this person do?",
                        value: o,
                        onInput: h => l(h.currentTarget.value)
                    })]
                }), d.jsxs("div", {
                    className: "my-6",
                    children: [d.jsx("p", {
                        className: "block mb-2 text-lg",
                        children: "Duration:"
                    }), d.jsx("ul", {
                        children: v1.map( (h, m) => d.jsxs("li", {
                            className: "flex items-center my-3",
                            children: [d.jsx("input", {
                                type: "radio",
                                name: "duration",
                                id: h.label,
                                value: h.duration,
                                checked: h.duration === i,
                                onChange: y => a(Number(y.currentTarget.value)),
                                className: "mr-2"
                            }), d.jsx("label", {
                                htmlFor: h.label,
                                className: fe("text-lg", h.duration !== i && "opacity-50"),
                                children: h.label
                            })]
                        }, h.label))
                    })]
                }), d.jsx("p", {
                    children: d.jsx(VW, {
                        disabled: !n || !o,
                        label: "Ban user",
                        confirmLabel: "Yes, ban user",
                        onConfirmedSubmit: h => {
                            c.mutate({
                                username: n,
                                duration: i,
                                reason: o
                            }, {
                                onError(m) {
                                    ke.error(m.message || "Failed to ban user")
                                },
                                onSuccess() {
                                    ke.success(`${n} banned`),
                                    h(),
                                    s(""),
                                    l("")
                                }
                            })
                        }
                        ,
                        destructive: !0
                    })
                })]
            })]
        })
    })
}
function WW() {
    const e = Je()
      , t = ki()
      , [r] = ir();
    return g.useEffect( () => {
        e.isModerator || t({
            pathname: "/inventory"
        }, {
            replace: !0
        })
    }
    , [e.isModerator, t]),
    d.jsx(d.Fragment, {
        children: d.jsxs("section", {
            className: "flex flex-1 w-full h-full",
            children: [d.jsx("div", {
                className: "flex-1 flex flex-col w-1/4 max-w-xs bg-gray-50",
                children: d.jsx("form", {
                    className: "mt-6",
                    children: d.jsxs("div", {
                        className: "flex flex-col items-start gap-1 text-xl",
                        children: [e.isAdmin && d.jsx(On, {
                            to: {
                                pathname: "/admin/reports",
                                search: `?${r}`
                            },
                            className: ({isActive: n}) => fe("flex items-center w-full text-left pl-10 py-3", n ? "bg-white" : "opacity-50 hover:opacity-100"),
                            children: ({isActive: n}) => d.jsxs(d.Fragment, {
                                children: [n && d.jsx("span", {
                                    className: "block rounded-full bg-lime-400 w-2 h-2 mr-3"
                                }), "Reports"]
                            })
                        }), e.isAdmin && d.jsx(On, {
                            to: {
                                pathname: "/admin/inventories",
                                search: `?${r.toString()}`
                            },
                            className: ({isActive: n}) => fe("flex items-center w-full text-left pl-10 py-3", n ? "bg-white" : "opacity-50 hover:opacity-100"),
                            children: ({isActive: n}) => d.jsxs(d.Fragment, {
                                children: [n && d.jsx("span", {
                                    className: "block rounded-full bg-lime-400 w-2 h-2 mr-3"
                                }), "User Inventories"]
                            })
                        }), d.jsx(On, {
                            to: {
                                pathname: "/admin/lost-found",
                                search: `?${r}`
                            },
                            className: ({isActive: n}) => fe("flex items-center w-full text-left pl-10 py-3", n ? "bg-white" : "opacity-50 hover:opacity-100"),
                            children: ({isActive: n}) => d.jsxs(d.Fragment, {
                                children: [n && d.jsx("span", {
                                    className: "block rounded-full bg-lime-400 w-2 h-2 mr-3"
                                }), "Lost & Found"]
                            })
                        }), e.isAdmin && d.jsx(On, {
                            to: {
                                pathname: "/admin/users",
                                search: `?${r}`
                            },
                            className: ({isActive: n}) => fe("flex items-center w-full text-left pl-10 py-3", n ? "bg-white" : "opacity-50 hover:opacity-100"),
                            children: ({isActive: n}) => d.jsxs(d.Fragment, {
                                children: [n && d.jsx("span", {
                                    className: "block rounded-full bg-lime-400 w-2 h-2 mr-3"
                                }), "Manage Users"]
                            })
                        })]
                    })
                })
            }), d.jsx(el, {})]
        })
    })
}
function qW(e) {
    const t = jt()
      , r = H7()
      , [n,s] = g.useState();
    function i(a) {
        r.mutate({
            id: e.friendRequest.id,
            data: {
                accepted: a
            }
        }, {
            onSuccess: () => {
                t.invalidateQueries({
                    queryKey: ["me", "friends"]
                }),
                s(a ? "accepted" : "declined")
            }
        })
    }
    return d.jsxs("li", {
        className: "flex items-center group px-5 border-2 border-transparent h-12 hover:border-r-blu-500 hover:border-l-blu-500",
        children: [d.jsx("p", {
            children: d.jsx("span", {
                className: "text-2xl",
                children: e.friendRequest.requestingUser.displayName
            })
        }), n ? d.jsx("p", {
            className: fe("ml-auto text-lg uppercase", n && "opacity-50", n === "accepted" && "text-lime-600 -rotate-2", n === "declined" && "text-red-600 rotate-2"),
            children: n
        }) : d.jsx("p", {
            className: "ml-auto flex items-center gap-3 text-lg",
            children: r.isPending ? d.jsx("div", {
                className: "mr-6",
                children: d.jsx(ar, {
                    size: "md"
                })
            }) : d.jsxs(d.Fragment, {
                children: [d.jsx("button", {
                    type: "button",
                    className: "py-2 px-3 rounded opacity-25 group-hover:opacity-100 group-hover:bg-lime-200 group-hover:hover:bg-lime-300 disabled:opacity-25",
                    disabled: r.isPending,
                    onClick: () => i(!0),
                    children: "Accept"
                }), d.jsx("button", {
                    type: "button",
                    className: "py-2 px-3 rounded opacity-25 group-hover:opacity-100 group-hover:bg-red-200 group-hover:hover:bg-red-300 disabled:opacity-25",
                    disabled: r.isPending,
                    onClick: () => i(!1),
                    children: "Decline"
                })]
            })
        })]
    })
}
function HW() {
    var r, n;
    const e = Kk({
        received: !0
    })
      , t = (r = e.data) == null ? void 0 : r.pages[0];
    return d.jsxs(d.Fragment, {
        children: [d.jsx("header", {
            className: "flex items-center px-10 h-24",
            children: d.jsx("p", {
                children: d.jsxs(Kt, {
                    to: "/friends",
                    className: "inline-flex items-center opacity-50 hover:opacity-100 py-2 text-xl",
                    children: [d.jsx(nv, {
                        className: "w-6 h-6 mr-2"
                    }), "Back"]
                })
            })
        }), d.jsxs("div", {
            className: "overflow-auto flex-1 border-t-2 border-gray-100 p-10",
            children: [e.data && d.jsxs(d.Fragment, {
                children: [(t == null ? void 0 : t.ok) && (t == null ? void 0 : t.value.items.length) === 0 && d.jsx("div", {
                    className: "mt-28",
                    children: d.jsx("p", {
                        className: "text-2xl text-center",
                        children: "No friend requests"
                    })
                }), d.jsx("ul", {
                    className: "flex flex-col gap-3",
                    children: (n = e.data) == null ? void 0 : n.pages.map(s => s.ok ? s.value.items.map(i => d.jsx(qW, {
                        friendRequest: i
                    }, i.id)) : null)
                })]
            }), d.jsx("div", {
                className: "flex justify-center mt-10 space-x-4",
                children: e.hasNextPage && d.jsx("button", {
                    type: "button",
                    className: "px-4 py-2 bg-gray-200 text-gray-800 rounded-lg disabled:opacity-10",
                    onClick: () => e.fetchNextPage(),
                    children: "Load more"
                })
            })]
        })]
    })
}
function Rf({containerProps: e, labelProps: t, labelLeft: r, children: n, ...s}) {
    return d.jsx(B_, {
        ...s,
        children: ({isSelected: i}) => d.jsxs("div", {
            ...e,
            className: fe("group flex items-center", r && "flex-row-reverse", e == null ? void 0 : e.className),
            children: [d.jsx("span", {
                ...t,
                className: fe("mr-auto", t == null ? void 0 : t.className),
                children: n
            }), d.jsxs("svg", {
                xmlns: "http://www.w3.org/2000/svg",
                viewBox: "0 0 71 71",
                fill: "none",
                className: fe("w-6 h-6", i ? "text-blu-600" : "text-gray-300 group-hover:text-blu-300"),
                children: [d.jsx("path", {
                    fill: "currentColor",
                    d: "M64.414 3.358 3.03 0 0 12.953l3.03 49.892L8.562 71h55.852l6.323-8.155L71 12.953l-6.586-9.595Z"
                }), i && d.jsx("path", {
                    fill: "#FFF",
                    fillRule: "evenodd",
                    d: "M11.808 8.704a7 7 0 0 1 9.873.72L37.104 27.27l15.357-13.08a7 7 0 0 1 9.078 10.656L46.26 37.864l16.037 18.56a7 7 0 1 1-10.593 9.153L35.602 46.943 17.539 62.33A7 7 0 1 1 8.461 51.67L26.447 36.35 11.088 18.577a7 7 0 0 1 .72-9.873Z",
                    clipRule: "evenodd"
                })]
            })]
        })
    })
}
const pi = g.forwardRef( (e, t) => d.jsx(rl, {
    borderProps: {
        shape: "rect",
        fill: "transparent",
        strokeWidth: 8
    },
    className: "text-blu-200 hover:text-blu-300 focus-within:text-blu-500 focus-within:hover:text-blu-500",
    noRotation: !0,
    children: d.jsx("input", {
        ...e,
        ref: t,
        className: fe("appearance-none w-full py-3 pl-4 pr-3 bg-transparent focus:outline-0 text-gray-900 text-xl", e.className)
    })
}));
function ZW() {
    var c;
    const e = Je()
      , [t,r] = g.useState("")
      , n = Qk({
        refetchInterval: 1e3 * 10
    })
      , s = Kk({
        received: !0
    })
      , i = tv();
    let a = new Array;
    n.data && (a = n.data),
    t && (a = a.filter(f => f.displayName.toLowerCase().includes(t.toLowerCase()))),
    a.sort( (f, h) => f.displayName.toLowerCase().localeCompare(h.displayName.toLowerCase())).sort( (f, h) => f.currentRoomId !== null && h.currentRoomId === null ? -1 : f.currentRoomId === null && h.currentRoomId !== null || f.ggwpStatus === "muted" && h.ggwpStatus !== "muted" ? 1 : f.ggwpStatus !== "muted" && h.ggwpStatus === "muted" || f.isJoinable && !h.isJoinable ? -1 : !f.isJoinable && h.isJoinable ? 1 : 0);
    const o = (c = s.data) == null ? void 0 : c.pages[0]
      , l = o != null && o.ok ? o.value.total : 0;
    return d.jsxs(d.Fragment, {
        children: [d.jsxs("header", {
            className: "flex items-center px-10 h-24",
            children: [d.jsxs("div", {
                className: "flex items-center mr-auto",
                children: [d.jsx("form", {
                    className: "flex items-center space-x-3 w-72",
                    children: d.jsx(pi, {
                        type: "search",
                        placeholder: "Search friends",
                        onInput: f => r(f.currentTarget.value)
                    })
                }), d.jsx("div", {
                    className: "ml-12",
                    children: d.jsxs(Rf, {
                        labelProps: {
                            className: "text-nowrap pl-3"
                        },
                        labelLeft: !0,
                        isSelected: !e.isJoinable,
                        onChange: () => {
                            var f;
                            (f = e.currentUser) != null && f.id && i.mutate({
                                id: e.currentUser.id,
                                data: {
                                    isJoinable: !e.isJoinable
                                }
                            })
                        }
                        ,
                        isDisabled: i.isPending,
                        children: [d.jsx("p", {
                            children: "Private Mode"
                        }), d.jsx("p", {
                            className: "text-sm opacity-50",
                            children: e.isJoinable ? "Friends can join your room" : "Friends can NOT join your room"
                        })]
                    })
                })]
            }), d.jsxs(Kt, {
                to: "/friends/requests",
                className: "text-xl hover:bg-gray-50 rounded py-2 px-3 flex items-center relative",
                children: ["Friend Requests", l > 0 && d.jsx("span", {
                    className: "w-2 h-2 rounded-full bg-blue-400 absolute top-2 right-0",
                    children: d.jsxs("span", {
                        className: "sr-only",
                        children: [l, " requests"]
                    })
                })]
            })]
        }), d.jsxs("div", {
            className: "overflow-auto flex-1 border-t-2 border-gray-100 p-10",
            children: [n.isLoading && d.jsx("div", {
                className: "flex items-center justify-center flex-1 pt-28",
                children: d.jsx(ar, {
                    size: "lg"
                })
            }), !n.isLoading && a.length === 0 && d.jsx("div", {
                className: "mt-28",
                children: d.jsxs("p", {
                    className: "text-2xl text-center",
                    children: ["Friends are out there,", d.jsx("br", {}), " you just have to find them"]
                })
            }), a.length > 0 && d.jsx("ul", {
                className: "flex flex-col gap-1",
                children: a.map(f => d.jsx(KW, {
                    friend: f
                }, f.userId))
            })]
        })]
    })
}
function KW({friend: e}) {
    const t = Je()
      , [r,n] = g.useState(null)
      , [s,i] = g.useState(!1)
      , a = XL()
      , o = YL()
      , l = r === e.userId
      , c = e.ggwpStatus === "muted"
      , f = !!e.currentRoomId
      , h = t.isAdmin || !!e.currentRoomId && e.isJoinable && !c;
    function m() {
        n(e.userId),
        a.mutate(e, {
            onError(y) {
                ke.error(y.message || "Failed to join friend")
            },
            onSettled() {
                setTimeout( () => n(null), 5e3)
            }
        })
    }
    return d.jsxs("li", {
        className: fe("flex items-center group rounded px-5 border-2 border-transparent h-12", c ? "opacity-75" : "hover:border-r-blu-500 hover:border-l-blu-500"),
        children: [d.jsxs("p", {
            className: "flex items-center",
            children: [d.jsx("span", {
                className: fe("block rounded-full w-3 h-3 mr-4", f && h ? c ? "bg-red-500" : "bg-lime-500" : "bg-gray-200"),
                "aria-label": f ? "Online" : "Offline"
            }), d.jsx("span", {
                className: "text-2xl",
                children: e.displayName
            })]
        }), s ? d.jsxs("div", {
            className: "ml-auto flex items-center h-[3.25rem] gap-3 text-lg",
            children: [d.jsxs("button", {
                type: "button",
                onClick: async () => {
                    o.mutate({
                        id: e.friendshipId
                    }, {
                        onError(y) {
                            ke.error(y.message || "Failed to unfriend")
                        },
                        onSuccess() {
                            i(!1)
                        }
                    })
                }
                ,
                disabled: o.isPending,
                className: "opacity-75 hover:opacity-100 px-2 py-1 bg-red-50 text-red-700 rounded",
                title: `Unfriend ${e.displayName}`,
                children: ["Unfriend ", e.displayName]
            }), d.jsx("button", {
                type: "button",
                onClick: () => i(!1),
                disabled: o.isPending,
                className: "opacity-75 hover:opacity-100 px-2 py-1",
                children: "Cancel"
            })]
        }) : d.jsxs("div", {
            className: "ml-auto flex items-center",
            children: [f && h && d.jsx("p", {
                className: "flex items-center w-32 h-12",
                children: l ? d.jsx("div", {
                    className: "w-full flex  items-center justify-center",
                    children: d.jsx(o8, {
                        className: "w-5 h-5 text-orange-800 opacity-20"
                    })
                }) : c ? d.jsxs("button", {
                    type: "button",
                    className: "w-full flex  items-center justify-center appearance-none",
                    disabled: (a.isPending || l) && !t.isAdmin,
                    onClick: m,
                    children: [d.jsx(s8, {
                        className: "w-5 h-5 text-red-500 opacity-100"
                    }), d.jsx("span", {
                        className: "text-red-500 ml-2",
                        children: "Banned"
                    })]
                }) : d.jsxs("button", {
                    type: "button",
                    className: fe("relative py-2 px-3 rounded opacity-25 group-hover:opacity-100 group-hover:bg-lime-200 group-hover:hover:bg-lime-300 text-xl"),
                    disabled: a.isPending || l,
                    onClick: m,
                    children: ["Go to friend", t.isAdmin && !e.isJoinable && d.jsx("span", {
                        className: "absolute top-1 right-1 text-xl uppercase font-bold opacity-50",
                        children: "*"
                    })]
                })
            }), d.jsx("p", {
                className: "ml-5",
                children: d.jsx("button", {
                    type: "button",
                    className: "p-4 opacity-20 hover:opacity-100",
                    onClick: () => i(!0),
                    children: d.jsx(f8, {})
                })
            })]
        })]
    }, e.friendshipId)
}
function QW() {
    const e = ki()
      , t = Je();
    return g.useEffect( () => {
        t.status === "AUTHORIZED" && e("/inventory")
    }
    , [t.status]),
    null
}
function GW({item: e}) {
    Je();
    const t = gi()
      , [r,n] = g.useState(!1)
      , s = Hk();
    return d.jsxs("li", {
        className: fe("relative group", r && "pointer-events-none"),
        children: [d.jsxs(rl, {
            borderProps: {
                shape: "square",
                strokeWidth: 10,
                className: fe(e.blobType === "item" && "text-[#E9FCDD] group-hover:text-[#7AE137]", e.blobType === "avatar" && "text-[#C2E4F1] group-hover:text-[#30A0C9]")
            },
            className: "p-6 flex items-center justify-center w-full aspect-square relative",
            children: [d.jsx("img", {
                src: e.thumbnailUrl ?? "",
                alt: "Inventory item thumbnail",
                className: "block w-full",
                loading: "lazy"
            }), r && d.jsx("p", {
                className: "p-1 text-2xl text-blu-600 uppercase font-bold -rotate-12 bg-white rounded-2xl absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2",
                children: "Recovered"
            })]
        }), d.jsx("div", {
            className: fe("opacity-0 group-hover:opacity-100 z-10 bg-white p-2 rounded-2xl", "absolute top-full left-1/2 -translate-x-1/2 -translate-y-1/2"),
            children: !r && d.jsxs(at, {
                variant: "filled",
                bg: "blue",
                onClick: async () => {
                    var a;
                    await Ve.emit("blob_recovered", {
                        id: e.blobId
                    });
                    const i = await ge.createInventoryItem(e.blobId);
                    if (!i.ok) {
                        ke.error(((a = i.error) == null ? void 0 : a.message) || "Failed to recover product.");
                        return
                    }
                    n(!0)
                }
                ,
                disabled: r || s.isPending || t.isCreatingItem,
                children: [d.jsx(iE, {
                    className: "w-6 h-6 mr-2"
                }), "Recover"]
            })
        })]
    }, e.id)
}
const YW = {};
function q_() {
    var f;
    const e = jt()
      , t = Je()
      , [r,n] = g.useState(!1)
      , s = rv()
      , i = q7();
    if (!((f = s.data) != null && f.ok))
        return null;
    const {limit: a, remaining: o, upgradePrice: l} = s.data.value;
    async function c() {
        i.mutate(YW, {
            onSuccess(h, m, y) {
                Se.balance -= l ?? 0,
                n(!1),
                e.invalidateQueries({
                    queryKey: ["me"]
                })
            },
            onError(h) {
                h.code === "INSUFFICIENT_BLOBIUM" && ke.error("Not enough Blobium.")
            },
            onSettled() {
                Zy()
            }
        })
    }
    return d.jsxs("div", {
        className: "mt-auto px-10 mb-6",
        children: [d.jsx("h3", {
            className: "uppercase opacity-25",
            children: "Product Listings"
        }), d.jsxs("p", {
            className: "text-4xl",
            children: [a - o, "/", d.jsx(uv, {
                value: a,
                continuous: !0
            })]
        }), !!l && d.jsxs(d.Fragment, {
            children: [d.jsx("div", {
                className: "relative flex items-center min-h-14",
                children: r ? d.jsx("div", {
                    className: "flex items-center h-[3.25rem] gap-3 -ml-2",
                    children: i.isPending ? d.jsxs("p", {
                        className: "flex items-center justify-center ml-2",
                        children: [d.jsx(ar, {
                            size: "sm",
                            className: "text-white"
                        }), d.jsx("span", {
                            className: "ml-2",
                            children: "Buying..."
                        })]
                    }) : d.jsxs(d.Fragment, {
                        children: [d.jsx("button", {
                            type: "button",
                            onClick: c,
                            disabled: i.isPending || t.balance < l,
                            className: "opacity-75 hover:opacity-100 px-2 py-1 bg-emerald-50 text-emerald-900 rounded",
                            children: "Yes, buy listings"
                        }), d.jsx("button", {
                            type: "button",
                            onClick: () => n(!1),
                            disabled: i.isPending,
                            className: "opacity-75 hover:opacity-100 px-2 py-1",
                            children: "Cancel"
                        })]
                    })
                }) : d.jsx("p", {
                    className: "-ml-2 my-2 font-normal",
                    children: d.jsx(at, {
                        variant: "filled",
                        bg: "yellow",
                        onClick: () => n(!0),
                        disabled: i.isPending || t.balance < l,
                        children: "Buy listings"
                    })
                })
            }), d.jsxs("p", {
                className: "flex items-center",
                children: [d.jsx("span", {
                    children: "+5"
                }), d.jsxs("span", {
                    className: "inline-flex items-center ml-5",
                    children: [d.jsx(tl, {
                        className: "w-5 h-5 mr-1"
                    }), l]
                })]
            })]
        })]
    })
}
function JW() {
    var n, s, i;
    const e = Je()
      , t = jt()
      , r = Gk({
        sellerId: (n = e.currentUser) == null ? void 0 : n.id,
        salesChannel: "in_person",
        limit: 200
    });
    return g.useEffect( () => () => {
        const a = ["products"];
        t.cancelQueries({
            queryKey: a
        }),
        t.invalidateQueries({
            queryKey: a
        })
    }
    , [t]),
    d.jsx(d.Fragment, {
        children: d.jsxs("section", {
            className: "flex flex-1 w-full h-full",
            children: [d.jsxs("div", {
                className: "flex flex-col w-80",
                children: [d.jsxs("div", {
                    className: "p-6",
                    children: [d.jsx("p", {
                        children: d.jsxs(Kt, {
                            to: "/inventory",
                            className: "inline-flex items-center opacity-50 hover:opacity-100 py-2 mb-4 text-xl",
                            children: [d.jsx(nv, {
                                className: "w-6 h-6 mr-2"
                            }), "Back"]
                        })
                    }), d.jsxs("div", {
                        className: "rounded-xl bg-gray-50 p-4 w-full space-y-4",
                        children: [d.jsxs("h2", {
                            className: "font-sans font-bold text-3xl uppercase",
                            children: ["For Sale. Wait.. ", d.jsx("span", {
                                className: "italic text-orange-950",
                                children: "Was"
                            }), " For Sale."]
                        }), d.jsx("p", {
                            className: "text-slate-600",
                            children: "You took it out for sale and left? That's bad for business. Recover your displayed products here."
                        }), e.currentUser && d.jsxs("p", {
                            className: "text-slate-600",
                            children: ["Looking for your store listings?", d.jsx(Kt, {
                                to: {
                                    pathname: "/store",
                                    search: `sellerId=${e.currentUser.id}`
                                },
                                className: "text-black underline",
                                children: "Find on your My Store page."
                            })]
                        })]
                    })]
                }), d.jsx(q_, {})]
            }), r.isLoading ? d.jsx("div", {
                className: "flex items-center justify-center flex-1",
                children: d.jsx(ar, {
                    size: "lg"
                })
            }) : d.jsxs(d.Fragment, {
                children: [((s = r.data) == null ? void 0 : s.pages.length) === 0 && d.jsxs("div", {
                    className: "flex-1 m-auto text-center w-full",
                    children: [d.jsx("p", {
                        className: "text-2xl",
                        children: "Nothing left behind"
                    }), d.jsx("p", {
                        className: "text-sm opacity-50",
                        children: "So, it sold?"
                    })]
                }), d.jsx("div", {
                    className: "overflow-auto flex-1 ml-1",
                    children: d.jsx("ul", {
                        className: "grid justify-start grid-cols-2 lg:grid-cols-3 xl:grid-cols-5 gap-4 lg:gap-6 px-10 pb-10 pt-4",
                        children: (i = r.data) == null ? void 0 : i.pages.map(a => a.ok ? d.jsx(g.Fragment, {
                            children: a.value.items.map(o => d.jsx(GW, {
                                item: o
                            }, o.id))
                        }, a.value.nextCursor) : null)
                    })
                })]
            })]
        })
    })
}
function H_() {
    var l;
    const e = Je()
      , [t,r] = g.useState(!1)
      , n = gi();
    if (g.useEffect( () => {
        ge.fetchLimits()
    }
    , []),
    !((l = n.limitsQuery) != null && l.ok))
        return null;
    const {limit: s, remaining: i, upgradePrice: a} = n.limitsQuery.value;
    async function o() {
        (await ge.purchaseInventorySpace()).ok || ke.error("Failed to purchase inventory space"),
        r(!1)
    }
    return d.jsxs("div", {
        className: "mt-auto px-10 mb-6",
        children: [d.jsx("h3", {
            className: "uppercase opacity-25",
            children: "Inventory Slots"
        }), d.jsxs("p", {
            className: "text-4xl",
            children: [s - i, "/", d.jsx(uv, {
                value: s,
                continuous: !0
            })]
        }), !!a && d.jsxs(d.Fragment, {
            children: [d.jsx("div", {
                className: "relative flex items-center min-h-14",
                children: t ? d.jsx("div", {
                    className: "flex items-center h-[3.25rem] gap-3 -ml-2",
                    children: n.isPurchasingSpace ? d.jsxs("p", {
                        className: "flex items-center justify-center ml-2",
                        children: [d.jsx(ar, {
                            size: "sm",
                            className: "text-white"
                        }), d.jsx("span", {
                            className: "ml-2",
                            children: "Buying..."
                        })]
                    }) : d.jsxs(d.Fragment, {
                        children: [d.jsx("button", {
                            type: "button",
                            onClick: o,
                            disabled: n.isPurchasingSpace,
                            className: "opacity-75 hover:opacity-100 px-2 py-1 bg-emerald-50 text-emerald-900 rounded",
                            children: "Yes, buy slots"
                        }), d.jsx("button", {
                            type: "button",
                            onClick: () => r(!1),
                            disabled: n.isPurchasingSpace,
                            className: "opacity-75 hover:opacity-100 px-2 py-1",
                            children: "Cancel"
                        })]
                    })
                }) : d.jsx("p", {
                    className: "-ml-2 my-2 font-normal",
                    children: d.jsx(at, {
                        variant: "filled",
                        bg: "yellow",
                        onClick: () => r(!0),
                        disabled: n.isPurchasingSpace || e.balance < a,
                        children: "Buy slots"
                    })
                })
            }), d.jsxs("p", {
                className: "flex items-center",
                children: [d.jsx("span", {
                    children: "+10"
                }), d.jsxs("span", {
                    className: "inline-flex items-center ml-5",
                    children: [d.jsx(tl, {
                        className: "w-5 h-5 mr-1"
                    }), a]
                })]
            })]
        })]
    })
}
function XW() {
    var r;
    const e = jt()
      , t = e9();
    return g.useEffect( () => () => {
        const n = ["lost-found"];
        e.cancelQueries({
            queryKey: n
        }),
        e.removeQueries({
            queryKey: n
        })
    }
    , [e]),
    d.jsx(d.Fragment, {
        children: d.jsxs("section", {
            className: "flex flex-1 w-full h-full",
            children: [d.jsxs("div", {
                className: "flex flex-col w-80",
                children: [d.jsxs("div", {
                    className: "p-6",
                    children: [d.jsx("p", {
                        children: d.jsxs(Kt, {
                            to: "/inventory",
                            className: "inline-flex items-center opacity-50 hover:opacity-100 py-2 mb-4 text-xl",
                            children: [d.jsx(nv, {
                                className: "w-6 h-6 mr-2"
                            }), "Back"]
                        })
                    }), d.jsxs("div", {
                        className: "rounded-xl bg-gray-50 p-4 w-full space-y-4",
                        children: [d.jsxs("h2", {
                            className: "font-sans font-bold text-3xl uppercase",
                            children: ["Wandered,", d.jsx("br", {}), " not gone."]
                        }), d.jsx("p", {
                            className: "text-slate-600",
                            children: "Sometimes blobs wander off. They're not gone, just misplaced."
                        }), d.jsx("p", {
                            className: "text-slate-600",
                            children: "For 3 days following their last use, your blobs will be recoverable here. After that, they'll be gone forever."
                        })]
                    })]
                }), d.jsx(H_, {})]
            }), t.isLoading ? d.jsx("div", {
                className: "flex items-center justify-center flex-1",
                children: d.jsx(ar, {
                    size: "lg"
                })
            }) : ((r = t.data) == null ? void 0 : r.ok) && d.jsxs(d.Fragment, {
                children: [t.data.value.length === 0 && d.jsxs("div", {
                    className: "flex-1 m-auto text-center w-full",
                    children: [d.jsx("p", {
                        className: "text-2xl",
                        children: "Sorry, no lost blobs here"
                    }), d.jsx("p", {
                        className: "text-sm opacity-50",
                        children: "Wait, maybe that's a good thing?"
                    })]
                }), t.data.value.length > 0 && d.jsx("div", {
                    className: "overflow-auto flex-1 ml-1",
                    children: d.jsx("ul", {
                        className: "grid justify-start grid-cols-2 lg:grid-cols-3 xl:grid-cols-5 gap-4 lg:gap-6 px-10 pb-10 pt-4",
                        children: t.data.value.map(n => d.jsx(f_, {
                            item: n
                        }, n.id))
                    })
                })]
            })]
        })
    })
}
function eq(e) {
    const [t,r] = ir();
    g.useEffect( () => {
        const n = Ys.get(e);
        n && n !== t.toString() && r(new URLSearchParams(n))
    }
    , [e]),
    g.useEffect( () => {
        Ys.set(e, t.toString())
    }
    , [e, t])
}
function tq() {
    var s;
    const e = gi();
    if (!((s = e.limitsQuery) != null && s.ok))
        return null;
    const {remaining: t} = e.limitsQuery.value;
    let r = !1
      , n = !1;
    return e.isFetchingLimits || (r = t < 1,
    n = !r && t - 5 <= 0),
    r ? d.jsxs("p", {
        className: "mt-auto bg-red-50 text-red-600 border-t-2 border-t-red-100 p-2 text-center",
        children: ["Your inventory is ", t < 0 ? "overflowing" : "full"]
    }) : n ? d.jsx("p", {
        className: "mt-auto bg-yellow-50 text-yellow-600 border-t-2 border-t-yellow-100 p-2 text-center",
        children: "Your inventory is almost full"
    }) : null
}
var cc = e => e.type === "checkbox"
  , Bi = e => e instanceof Date
  , dr = e => e == null;
const Z_ = e => typeof e == "object";
var _t = e => !dr(e) && !Array.isArray(e) && Z_(e) && !Bi(e)
  , K_ = e => _t(e) && e.target ? cc(e.target) ? e.target.checked : e.target.value : e
  , rq = e => e.substring(0, e.search(/\.\d+(\.|$)/)) || e
  , Q_ = (e, t) => e.has(rq(t))
  , nq = e => {
    const t = e.constructor && e.constructor.prototype;
    return _t(t) && t.hasOwnProperty("isPrototypeOf")
}
  , Nv = typeof window < "u" && typeof window.HTMLElement < "u" && typeof document < "u";
function wr(e) {
    let t;
    const r = Array.isArray(e)
      , n = typeof FileList < "u" ? e instanceof FileList : !1;
    if (e instanceof Date)
        t = new Date(e);
    else if (e instanceof Set)
        t = new Set(e);
    else if (!(Nv && (e instanceof Blob || n)) && (r || _t(e)))
        if (t = r ? [] : {},
        !r && !nq(e))
            t = e;
        else
            for (const s in e)
                e.hasOwnProperty(s) && (t[s] = wr(e[s]));
    else
        return e;
    return t
}
var Sh = e => Array.isArray(e) ? e.filter(Boolean) : []
  , kt = e => e === void 0
  , q = (e, t, r) => {
    if (!t || !_t(e))
        return r;
    const n = Sh(t.split(/[,[\].]+?/)).reduce( (s, i) => dr(s) ? s : s[i], e);
    return kt(n) || n === e ? kt(e[t]) ? r : e[t] : n
}
  , qr = e => typeof e == "boolean"
  , jv = e => /^\w*$/.test(e)
  , G_ = e => Sh(e.replace(/["|']|\]/g, "").split(/\.|\[/))
  , Be = (e, t, r) => {
    let n = -1;
    const s = jv(t) ? [t] : G_(t)
      , i = s.length
      , a = i - 1;
    for (; ++n < i; ) {
        const o = s[n];
        let l = r;
        if (n !== a) {
            const c = e[o];
            l = _t(c) || Array.isArray(c) ? c : isNaN(+s[n + 1]) ? {} : []
        }
        if (o === "__proto__" || o === "constructor" || o === "prototype")
            return;
        e[o] = l,
        e = e[o]
    }
    return e
}
;
const Of = {
    BLUR: "blur",
    FOCUS_OUT: "focusout",
    CHANGE: "change"
}
  , pn = {
    onBlur: "onBlur",
    onChange: "onChange",
    onSubmit: "onSubmit",
    onTouched: "onTouched",
    all: "all"
}
  , Zn = {
    max: "max",
    min: "min",
    maxLength: "maxLength",
    minLength: "minLength",
    pattern: "pattern",
    required: "required",
    validate: "validate"
}
  , sq = ve.createContext(null)
  , Iv = () => ve.useContext(sq);
var Y_ = (e, t, r, n=!0) => {
    const s = {
        defaultValues: t._defaultValues
    };
    for (const i in e)
        Object.defineProperty(s, i, {
            get: () => {
                const a = i;
                return t._proxyFormState[a] !== pn.all && (t._proxyFormState[a] = !n || pn.all),
                r && (r[a] = !0),
                e[a]
            }
        });
    return s
}
  , _r = e => _t(e) && !Object.keys(e).length
  , J_ = (e, t, r, n) => {
    r(e);
    const {name: s, ...i} = e;
    return _r(i) || Object.keys(i).length >= Object.keys(t).length || Object.keys(i).find(a => t[a] === (!n || pn.all))
}
  , tu = e => Array.isArray(e) ? e : [e]
  , X_ = (e, t, r) => !e || !t || e === t || tu(e).some(n => n && (r ? n === t : n.startsWith(t) || t.startsWith(n)));
function Rv(e) {
    const t = ve.useRef(e);
    t.current = e,
    ve.useEffect( () => {
        const r = !e.disabled && t.current.subject && t.current.subject.subscribe({
            next: t.current.next
        });
        return () => {
            r && r.unsubscribe()
        }
    }
    , [e.disabled])
}
function iq(e) {
    const t = Iv()
      , {control: r=t.control, disabled: n, name: s, exact: i} = e || {}
      , [a,o] = ve.useState(r._formState)
      , l = ve.useRef(!0)
      , c = ve.useRef({
        isDirty: !1,
        isLoading: !1,
        dirtyFields: !1,
        touchedFields: !1,
        validatingFields: !1,
        isValidating: !1,
        isValid: !1,
        errors: !1
    })
      , f = ve.useRef(s);
    return f.current = s,
    Rv({
        disabled: n,
        next: h => l.current && X_(f.current, h.name, i) && J_(h, c.current, r._updateFormState) && o({
            ...r._formState,
            ...h
        }),
        subject: r._subjects.state
    }),
    ve.useEffect( () => (l.current = !0,
    c.current.isValid && r._updateValid(!0),
    () => {
        l.current = !1
    }
    ), [r]),
    ve.useMemo( () => Y_(a, r, c.current, !1), [a, r])
}
var Ln = e => typeof e == "string"
  , eT = (e, t, r, n, s) => Ln(e) ? (n && t.watch.add(e),
q(r, e, s)) : Array.isArray(e) ? e.map(i => (n && t.watch.add(i),
q(r, i))) : (n && (t.watchAll = !0),
r);
function aq(e) {
    const t = Iv()
      , {control: r=t.control, name: n, defaultValue: s, disabled: i, exact: a} = e || {}
      , o = ve.useRef(n);
    o.current = n,
    Rv({
        disabled: i,
        subject: r._subjects.values,
        next: f => {
            X_(o.current, f.name, a) && c(wr(eT(o.current, r._names, f.values || r._formValues, !1, s)))
        }
    });
    const [l,c] = ve.useState(r._getWatch(n, s));
    return ve.useEffect( () => r._removeUnmounted()),
    l
}
function oq(e) {
    const t = Iv()
      , {name: r, disabled: n, control: s=t.control, shouldUnregister: i} = e
      , a = Q_(s._names.array, r)
      , o = aq({
        control: s,
        name: r,
        defaultValue: q(s._formValues, r, q(s._defaultValues, r, e.defaultValue)),
        exact: !0
    })
      , l = iq({
        control: s,
        name: r,
        exact: !0
    })
      , c = ve.useRef(s.register(r, {
        ...e.rules,
        value: o,
        ...qr(e.disabled) ? {
            disabled: e.disabled
        } : {}
    }))
      , f = ve.useMemo( () => Object.defineProperties({}, {
        invalid: {
            enumerable: !0,
            get: () => !!q(l.errors, r)
        },
        isDirty: {
            enumerable: !0,
            get: () => !!q(l.dirtyFields, r)
        },
        isTouched: {
            enumerable: !0,
            get: () => !!q(l.touchedFields, r)
        },
        isValidating: {
            enumerable: !0,
            get: () => !!q(l.validatingFields, r)
        },
        error: {
            enumerable: !0,
            get: () => q(l.errors, r)
        }
    }), [l, r])
      , h = ve.useMemo( () => ({
        name: r,
        value: o,
        ...qr(n) || l.disabled ? {
            disabled: l.disabled || n
        } : {},
        onChange: m => c.current.onChange({
            target: {
                value: K_(m),
                name: r
            },
            type: Of.CHANGE
        }),
        onBlur: () => c.current.onBlur({
            target: {
                value: q(s._formValues, r),
                name: r
            },
            type: Of.BLUR
        }),
        ref: m => {
            const y = q(s._fields, r);
            y && m && (y._f.ref = {
                focus: () => m.focus(),
                select: () => m.select(),
                setCustomValidity: k => m.setCustomValidity(k),
                reportValidity: () => m.reportValidity()
            })
        }
    }), [r, s._formValues, n, l.disabled, o, s._fields]);
    return ve.useEffect( () => {
        const m = s._options.shouldUnregister || i
          , y = (k, x) => {
            const w = q(s._fields, k);
            w && w._f && (w._f.mount = x)
        }
        ;
        if (y(r, !0),
        m) {
            const k = wr(q(s._options.defaultValues, r));
            Be(s._defaultValues, r, k),
            kt(q(s._formValues, r)) && Be(s._formValues, r, k)
        }
        return !a && s.register(r),
        () => {
            (a ? m && !s._state.action : m) ? s.unregister(r) : y(r, !1)
        }
    }
    , [r, s, a, i]),
    ve.useEffect( () => {
        s._updateDisabledField({
            disabled: n,
            fields: s._fields,
            name: r
        })
    }
    , [n, r, s]),
    ve.useMemo( () => ({
        field: h,
        formState: l,
        fieldState: f
    }), [h, l, f])
}
const Dn = e => e.render(oq(e));
var tT = (e, t, r, n, s) => t ? {
    ...r[e],
    types: {
        ...r[e] && r[e].types ? r[e].types : {},
        [n]: s || !0
    }
} : {}
  , b1 = e => ({
    isOnSubmit: !e || e === pn.onSubmit,
    isOnBlur: e === pn.onBlur,
    isOnChange: e === pn.onChange,
    isOnAll: e === pn.all,
    isOnTouch: e === pn.onTouched
})
  , x1 = (e, t, r) => !r && (t.watchAll || t.watch.has(e) || [...t.watch].some(n => e.startsWith(n) && /^\.\w+/.test(e.slice(n.length))));
const ru = (e, t, r, n) => {
    for (const s of r || Object.keys(e)) {
        const i = q(e, s);
        if (i) {
            const {_f: a, ...o} = i;
            if (a) {
                if (a.refs && a.refs[0] && t(a.refs[0], s) && !n)
                    return !0;
                if (a.ref && t(a.ref, a.name) && !n)
                    return !0;
                if (ru(o, t))
                    break
            } else if (_t(o) && ru(o, t))
                break
        }
    }
}
;
var lq = (e, t, r) => {
    const n = tu(q(e, r));
    return Be(n, "root", t[r]),
    Be(e, r, n),
    e
}
  , Ov = e => e.type === "file"
  , An = e => typeof e == "function"
  , Mf = e => {
    if (!Nv)
        return !1;
    const t = e ? e.ownerDocument : 0;
    return e instanceof (t && t.defaultView ? t.defaultView.HTMLElement : HTMLElement)
}
  , _d = e => Ln(e)
  , Mv = e => e.type === "radio"
  , Af = e => e instanceof RegExp;
const w1 = {
    value: !1,
    isValid: !1
}
  , S1 = {
    value: !0,
    isValid: !0
};
var rT = e => {
    if (Array.isArray(e)) {
        if (e.length > 1) {
            const t = e.filter(r => r && r.checked && !r.disabled).map(r => r.value);
            return {
                value: t,
                isValid: !!t.length
            }
        }
        return e[0].checked && !e[0].disabled ? e[0].attributes && !kt(e[0].attributes.value) ? kt(e[0].value) || e[0].value === "" ? S1 : {
            value: e[0].value,
            isValid: !0
        } : S1 : w1
    }
    return w1
}
;
const k1 = {
    isValid: !1,
    value: null
};
var nT = e => Array.isArray(e) ? e.reduce( (t, r) => r && r.checked && !r.disabled ? {
    isValid: !0,
    value: r.value
} : t, k1) : k1;
function E1(e, t, r="validate") {
    if (_d(e) || Array.isArray(e) && e.every(_d) || qr(e) && !e)
        return {
            type: r,
            message: _d(e) ? e : "",
            ref: t
        }
}
var Ma = e => _t(e) && !Af(e) ? e : {
    value: e,
    message: ""
}
  , _1 = async (e, t, r, n, s, i) => {
    const {ref: a, refs: o, required: l, maxLength: c, minLength: f, min: h, max: m, pattern: y, validate: k, name: x, valueAsNumber: w, mount: v} = e._f
      , p = q(r, x);
    if (!v || t.has(x))
        return {};
    const S = o ? o[0] : a
      , P = z => {
        s && S.reportValidity && (S.setCustomValidity(qr(z) ? "" : z || ""),
        S.reportValidity())
    }
      , j = {}
      , L = Mv(a)
      , E = cc(a)
      , b = L || E
      , O = (w || Ov(a)) && kt(a.value) && kt(p) || Mf(a) && a.value === "" || p === "" || Array.isArray(p) && !p.length
      , M = tT.bind(null, x, n, j)
      , D = (z, $, Y, ce=Zn.maxLength, Ke=Zn.minLength) => {
        const xt = z ? $ : Y;
        j[x] = {
            type: z ? ce : Ke,
            message: xt,
            ref: a,
            ...M(z ? ce : Ke, xt)
        }
    }
    ;
    if (i ? !Array.isArray(p) || !p.length : l && (!b && (O || dr(p)) || qr(p) && !p || E && !rT(o).isValid || L && !nT(o).isValid)) {
        const {value: z, message: $} = _d(l) ? {
            value: !!l,
            message: l
        } : Ma(l);
        if (z && (j[x] = {
            type: Zn.required,
            message: $,
            ref: S,
            ...M(Zn.required, $)
        },
        !n))
            return P($),
            j
    }
    if (!O && (!dr(h) || !dr(m))) {
        let z, $;
        const Y = Ma(m)
          , ce = Ma(h);
        if (!dr(p) && !isNaN(p)) {
            const Ke = a.valueAsNumber || p && +p;
            dr(Y.value) || (z = Ke > Y.value),
            dr(ce.value) || ($ = Ke < ce.value)
        } else {
            const Ke = a.valueAsDate || new Date(p)
              , xt = me => new Date(new Date().toDateString() + " " + me)
              , B = a.type == "time"
              , he = a.type == "week";
            Ln(Y.value) && p && (z = B ? xt(p) > xt(Y.value) : he ? p > Y.value : Ke > new Date(Y.value)),
            Ln(ce.value) && p && ($ = B ? xt(p) < xt(ce.value) : he ? p < ce.value : Ke < new Date(ce.value))
        }
        if ((z || $) && (D(!!z, Y.message, ce.message, Zn.max, Zn.min),
        !n))
            return P(j[x].message),
            j
    }
    if ((c || f) && !O && (Ln(p) || i && Array.isArray(p))) {
        const z = Ma(c)
          , $ = Ma(f)
          , Y = !dr(z.value) && p.length > +z.value
          , ce = !dr($.value) && p.length < +$.value;
        if ((Y || ce) && (D(Y, z.message, $.message),
        !n))
            return P(j[x].message),
            j
    }
    if (y && !O && Ln(p)) {
        const {value: z, message: $} = Ma(y);
        if (Af(z) && !p.match(z) && (j[x] = {
            type: Zn.pattern,
            message: $,
            ref: a,
            ...M(Zn.pattern, $)
        },
        !n))
            return P($),
            j
    }
    if (k) {
        if (An(k)) {
            const z = await k(p, r)
              , $ = E1(z, S);
            if ($ && (j[x] = {
                ...$,
                ...M(Zn.validate, $.message)
            },
            !n))
                return P($.message),
                j
        } else if (_t(k)) {
            let z = {};
            for (const $ in k) {
                if (!_r(z) && !n)
                    break;
                const Y = E1(await k[$](p, r), S, $);
                Y && (z = {
                    ...Y,
                    ...M($, Y.message)
                },
                P(Y.message),
                n && (j[x] = z))
            }
            if (!_r(z) && (j[x] = {
                ref: S,
                ...z
            },
            !n))
                return j
        }
    }
    return P(!0),
    j
}
;
function uq(e, t) {
    const r = t.slice(0, -1).length;
    let n = 0;
    for (; n < r; )
        e = kt(e) ? n++ : e[t[n++]];
    return e
}
function cq(e) {
    for (const t in e)
        if (e.hasOwnProperty(t) && !kt(e[t]))
            return !1;
    return !0
}
function Rt(e, t) {
    const r = Array.isArray(t) ? t : jv(t) ? [t] : G_(t)
      , n = r.length === 1 ? e : uq(e, r)
      , s = r.length - 1
      , i = r[s];
    return n && delete n[i],
    s !== 0 && (_t(n) && _r(n) || Array.isArray(n) && cq(n)) && Rt(e, r.slice(0, -1)),
    e
}
var _m = () => {
    let e = [];
    return {
        get observers() {
            return e
        },
        next: s => {
            for (const i of e)
                i.next && i.next(s)
        }
        ,
        subscribe: s => (e.push(s),
        {
            unsubscribe: () => {
                e = e.filter(i => i !== s)
            }
        }),
        unsubscribe: () => {
            e = []
        }
    }
}
  , Ey = e => dr(e) || !Z_(e);
function Ds(e, t) {
    if (Ey(e) || Ey(t))
        return e === t;
    if (Bi(e) && Bi(t))
        return e.getTime() === t.getTime();
    const r = Object.keys(e)
      , n = Object.keys(t);
    if (r.length !== n.length)
        return !1;
    for (const s of r) {
        const i = e[s];
        if (!n.includes(s))
            return !1;
        if (s !== "ref") {
            const a = t[s];
            if (Bi(i) && Bi(a) || _t(i) && _t(a) || Array.isArray(i) && Array.isArray(a) ? !Ds(i, a) : i !== a)
                return !1
        }
    }
    return !0
}
var sT = e => e.type === "select-multiple"
  , dq = e => Mv(e) || cc(e)
  , Tm = e => Mf(e) && e.isConnected
  , iT = e => {
    for (const t in e)
        if (An(e[t]))
            return !0;
    return !1
}
;
function Lf(e, t={}) {
    const r = Array.isArray(e);
    if (_t(e) || r)
        for (const n in e)
            Array.isArray(e[n]) || _t(e[n]) && !iT(e[n]) ? (t[n] = Array.isArray(e[n]) ? [] : {},
            Lf(e[n], t[n])) : dr(e[n]) || (t[n] = !0);
    return t
}
function aT(e, t, r) {
    const n = Array.isArray(e);
    if (_t(e) || n)
        for (const s in e)
            Array.isArray(e[s]) || _t(e[s]) && !iT(e[s]) ? kt(t) || Ey(r[s]) ? r[s] = Array.isArray(e[s]) ? Lf(e[s], []) : {
                ...Lf(e[s])
            } : aT(e[s], dr(t) ? {} : t[s], r[s]) : r[s] = !Ds(e[s], t[s]);
    return r
}
var Tl = (e, t) => aT(e, t, Lf(t))
  , oT = (e, {valueAsNumber: t, valueAsDate: r, setValueAs: n}) => kt(e) ? e : t ? e === "" ? NaN : e && +e : r && Ln(e) ? new Date(e) : n ? n(e) : e;
function Cm(e) {
    const t = e.ref;
    return Ov(t) ? t.files : Mv(t) ? nT(e.refs).value : sT(t) ? [...t.selectedOptions].map( ({value: r}) => r) : cc(t) ? rT(e.refs).value : oT(kt(t.value) ? e.ref.value : t.value, e)
}
var fq = (e, t, r, n) => {
    const s = {};
    for (const i of e) {
        const a = q(t, i);
        a && Be(s, i, a._f)
    }
    return {
        criteriaMode: r,
        names: [...e],
        fields: s,
        shouldUseNativeValidation: n
    }
}
  , Cl = e => kt(e) ? e : Af(e) ? e.source : _t(e) ? Af(e.value) ? e.value.source : e.value : e;
const T1 = "AsyncFunction";
var hq = e => !!e && !!e.validate && !!(An(e.validate) && e.validate.constructor.name === T1 || _t(e.validate) && Object.values(e.validate).find(t => t.constructor.name === T1))
  , mq = e => e.mount && (e.required || e.min || e.max || e.maxLength || e.minLength || e.pattern || e.validate);
function C1(e, t, r) {
    const n = q(e, r);
    if (n || jv(r))
        return {
            error: n,
            name: r
        };
    const s = r.split(".");
    for (; s.length; ) {
        const i = s.join(".")
          , a = q(t, i)
          , o = q(e, i);
        if (a && !Array.isArray(a) && r !== i)
            return {
                name: r
            };
        if (o && o.type)
            return {
                name: i,
                error: o
            };
        s.pop()
    }
    return {
        name: r
    }
}
var pq = (e, t, r, n, s) => s.isOnAll ? !1 : !r && s.isOnTouch ? !(t || e) : (r ? n.isOnBlur : s.isOnBlur) ? !e : (r ? n.isOnChange : s.isOnChange) ? e : !0
  , yq = (e, t) => !Sh(q(e, t)).length && Rt(e, t);
const gq = {
    mode: pn.onSubmit,
    reValidateMode: pn.onChange,
    shouldFocusError: !0
};
function vq(e={}) {
    let t = {
        ...gq,
        ...e
    }, r = {
        submitCount: 0,
        isDirty: !1,
        isLoading: An(t.defaultValues),
        isValidating: !1,
        isSubmitted: !1,
        isSubmitting: !1,
        isSubmitSuccessful: !1,
        isValid: !1,
        touchedFields: {},
        dirtyFields: {},
        validatingFields: {},
        errors: t.errors || {},
        disabled: t.disabled || !1
    }, n = {}, s = _t(t.defaultValues) || _t(t.values) ? wr(t.defaultValues || t.values) || {} : {}, i = t.shouldUnregister ? {} : wr(s), a = {
        action: !1,
        mount: !1,
        watch: !1
    }, o = {
        mount: new Set,
        disabled: new Set,
        unMount: new Set,
        array: new Set,
        watch: new Set
    }, l, c = 0;
    const f = {
        isDirty: !1,
        dirtyFields: !1,
        validatingFields: !1,
        touchedFields: !1,
        isValidating: !1,
        isValid: !1,
        errors: !1
    }
      , h = {
        values: _m(),
        array: _m(),
        state: _m()
    }
      , m = b1(t.mode)
      , y = b1(t.reValidateMode)
      , k = t.criteriaMode === pn.all
      , x = C => I => {
        clearTimeout(c),
        c = setTimeout(C, I)
    }
      , w = async C => {
        if (!t.disabled && (f.isValid || C)) {
            const I = t.resolver ? _r((await b()).errors) : await M(n, !0);
            I !== r.isValid && h.state.next({
                isValid: I
            })
        }
    }
      , v = (C, I) => {
        !t.disabled && (f.isValidating || f.validatingFields) && ((C || Array.from(o.mount)).forEach(A => {
            A && (I ? Be(r.validatingFields, A, I) : Rt(r.validatingFields, A))
        }
        ),
        h.state.next({
            validatingFields: r.validatingFields,
            isValidating: !_r(r.validatingFields)
        }))
    }
      , p = (C, I=[], A, G, H=!0, W=!0) => {
        if (G && A && !t.disabled) {
            if (a.action = !0,
            W && Array.isArray(q(n, C))) {
                const ae = A(q(n, C), G.argA, G.argB);
                H && Be(n, C, ae)
            }
            if (W && Array.isArray(q(r.errors, C))) {
                const ae = A(q(r.errors, C), G.argA, G.argB);
                H && Be(r.errors, C, ae),
                yq(r.errors, C)
            }
            if (f.touchedFields && W && Array.isArray(q(r.touchedFields, C))) {
                const ae = A(q(r.touchedFields, C), G.argA, G.argB);
                H && Be(r.touchedFields, C, ae)
            }
            f.dirtyFields && (r.dirtyFields = Tl(s, i)),
            h.state.next({
                name: C,
                isDirty: z(C, I),
                dirtyFields: r.dirtyFields,
                errors: r.errors,
                isValid: r.isValid
            })
        } else
            Be(i, C, I)
    }
      , S = (C, I) => {
        Be(r.errors, C, I),
        h.state.next({
            errors: r.errors
        })
    }
      , P = C => {
        r.errors = C,
        h.state.next({
            errors: r.errors,
            isValid: !1
        })
    }
      , j = (C, I, A, G) => {
        const H = q(n, C);
        if (H) {
            const W = q(i, C, kt(A) ? q(s, C) : A);
            kt(W) || G && G.defaultChecked || I ? Be(i, C, I ? W : Cm(H._f)) : ce(C, W),
            a.mount && w()
        }
    }
      , L = (C, I, A, G, H) => {
        let W = !1
          , ae = !1;
        const Ee = {
            name: C
        };
        if (!t.disabled) {
            const wt = !!(q(n, C) && q(n, C)._f && q(n, C)._f.disabled);
            if (!A || G) {
                f.isDirty && (ae = r.isDirty,
                r.isDirty = Ee.isDirty = z(),
                W = ae !== Ee.isDirty);
                const ft = wt || Ds(q(s, C), I);
                ae = !!(!wt && q(r.dirtyFields, C)),
                ft || wt ? Rt(r.dirtyFields, C) : Be(r.dirtyFields, C, !0),
                Ee.dirtyFields = r.dirtyFields,
                W = W || f.dirtyFields && ae !== !ft
            }
            if (A) {
                const ft = q(r.touchedFields, C);
                ft || (Be(r.touchedFields, C, A),
                Ee.touchedFields = r.touchedFields,
                W = W || f.touchedFields && ft !== A)
            }
            W && H && h.state.next(Ee)
        }
        return W ? Ee : {}
    }
      , E = (C, I, A, G) => {
        const H = q(r.errors, C)
          , W = f.isValid && qr(I) && r.isValid !== I;
        if (t.delayError && A ? (l = x( () => S(C, A)),
        l(t.delayError)) : (clearTimeout(c),
        l = null,
        A ? Be(r.errors, C, A) : Rt(r.errors, C)),
        (A ? !Ds(H, A) : H) || !_r(G) || W) {
            const ae = {
                ...G,
                ...W && qr(I) ? {
                    isValid: I
                } : {},
                errors: r.errors,
                name: C
            };
            r = {
                ...r,
                ...ae
            },
            h.state.next(ae)
        }
    }
      , b = async C => {
        v(C, !0);
        const I = await t.resolver(i, t.context, fq(C || o.mount, n, t.criteriaMode, t.shouldUseNativeValidation));
        return v(C),
        I
    }
      , O = async C => {
        const {errors: I} = await b(C);
        if (C)
            for (const A of C) {
                const G = q(I, A);
                G ? Be(r.errors, A, G) : Rt(r.errors, A)
            }
        else
            r.errors = I;
        return I
    }
      , M = async (C, I, A={
        valid: !0
    }) => {
        for (const G in C) {
            const H = C[G];
            if (H) {
                const {_f: W, ...ae} = H;
                if (W) {
                    const Ee = o.array.has(W.name)
                      , wt = H._f && hq(H._f);
                    wt && f.validatingFields && v([G], !0);
                    const ft = await _1(H, o.disabled, i, k, t.shouldUseNativeValidation && !I, Ee);
                    if (wt && f.validatingFields && v([G]),
                    ft[W.name] && (A.valid = !1,
                    I))
                        break;
                    !I && (q(ft, W.name) ? Ee ? lq(r.errors, ft, W.name) : Be(r.errors, W.name, ft[W.name]) : Rt(r.errors, W.name))
                }
                !_r(ae) && await M(ae, I, A)
            }
        }
        return A.valid
    }
      , D = () => {
        for (const C of o.unMount) {
            const I = q(n, C);
            I && (I._f.refs ? I._f.refs.every(A => !Tm(A)) : !Tm(I._f.ref)) && It(C)
        }
        o.unMount = new Set
    }
      , z = (C, I) => !t.disabled && (C && I && Be(i, C, I),
    !Ds(De(), s))
      , $ = (C, I, A) => eT(C, o, {
        ...a.mount ? i : kt(I) ? s : Ln(C) ? {
            [C]: I
        } : I
    }, A, I)
      , Y = C => Sh(q(a.mount ? i : s, C, t.shouldUnregister ? q(s, C, []) : []))
      , ce = (C, I, A={}) => {
        const G = q(n, C);
        let H = I;
        if (G) {
            const W = G._f;
            W && (!W.disabled && Be(i, C, oT(I, W)),
            H = Mf(W.ref) && dr(I) ? "" : I,
            sT(W.ref) ? [...W.ref.options].forEach(ae => ae.selected = H.includes(ae.value)) : W.refs ? cc(W.ref) ? W.refs.length > 1 ? W.refs.forEach(ae => (!ae.defaultChecked || !ae.disabled) && (ae.checked = Array.isArray(H) ? !!H.find(Ee => Ee === ae.value) : H === ae.value)) : W.refs[0] && (W.refs[0].checked = !!H) : W.refs.forEach(ae => ae.checked = ae.value === H) : Ov(W.ref) ? W.ref.value = "" : (W.ref.value = H,
            W.ref.type || h.values.next({
                name: C,
                values: {
                    ...i
                }
            })))
        }
        (A.shouldDirty || A.shouldTouch) && L(C, H, A.shouldTouch, A.shouldDirty, !0),
        A.shouldValidate && me(C)
    }
      , Ke = (C, I, A) => {
        for (const G in I) {
            const H = I[G]
              , W = `${C}.${G}`
              , ae = q(n, W);
            (o.array.has(C) || _t(H) || ae && !ae._f) && !Bi(H) ? Ke(W, H, A) : ce(W, H, A)
        }
    }
      , xt = (C, I, A={}) => {
        const G = q(n, C)
          , H = o.array.has(C)
          , W = wr(I);
        Be(i, C, W),
        H ? (h.array.next({
            name: C,
            values: {
                ...i
            }
        }),
        (f.isDirty || f.dirtyFields) && A.shouldDirty && h.state.next({
            name: C,
            dirtyFields: Tl(s, i),
            isDirty: z(C, W)
        })) : G && !G._f && !dr(W) ? Ke(C, W, A) : ce(C, W, A),
        x1(C, o) && h.state.next({
            ...r
        }),
        h.values.next({
            name: a.mount ? C : void 0,
            values: {
                ...i
            }
        })
    }
      , B = async C => {
        a.mount = !0;
        const I = C.target;
        let A = I.name
          , G = !0;
        const H = q(n, A)
          , W = () => I.type ? Cm(H._f) : K_(C)
          , ae = Ee => {
            G = Number.isNaN(Ee) || Bi(Ee) && isNaN(Ee.getTime()) || Ds(Ee, q(i, A, Ee))
        }
        ;
        if (H) {
            let Ee, wt;
            const ft = W()
              , Vt = C.type === Of.BLUR || C.type === Of.FOCUS_OUT
              , rn = !mq(H._f) && !t.resolver && !q(r.errors, A) && !H._f.deps || pq(Vt, q(r.touchedFields, A), r.isSubmitted, y, m)
              , ka = x1(A, o, Vt);
            Be(i, A, ft),
            Vt ? (H._f.onBlur && H._f.onBlur(C),
            l && l(0)) : H._f.onChange && H._f.onChange(C);
            const Ss = L(A, ft, Vt, !1)
              , Eh = !_r(Ss) || ka;
            if (!Vt && h.values.next({
                name: A,
                type: C.type,
                values: {
                    ...i
                }
            }),
            rn)
                return f.isValid && (t.mode === "onBlur" && Vt ? w() : Vt || w()),
                Eh && h.state.next({
                    name: A,
                    ...ka ? {} : Ss
                });
            if (!Vt && ka && h.state.next({
                ...r
            }),
            t.resolver) {
                const {errors: nn} = await b([A]);
                if (ae(ft),
                G) {
                    const pc = C1(r.errors, n, A)
                      , ll = C1(nn, n, pc.name || A);
                    Ee = ll.error,
                    A = ll.name,
                    wt = _r(nn)
                }
            } else
                v([A], !0),
                Ee = (await _1(H, o.disabled, i, k, t.shouldUseNativeValidation))[A],
                v([A]),
                ae(ft),
                G && (Ee ? wt = !1 : f.isValid && (wt = await M(n, !0)));
            G && (H._f.deps && me(H._f.deps),
            E(A, wt, Ee, Ss))
        }
    }
      , he = (C, I) => {
        if (q(r.errors, I) && C.focus)
            return C.focus(),
            1
    }
      , me = async (C, I={}) => {
        let A, G;
        const H = tu(C);
        if (t.resolver) {
            const W = await O(kt(C) ? C : H);
            A = _r(W),
            G = C ? !H.some(ae => q(W, ae)) : A
        } else
            C ? (G = (await Promise.all(H.map(async W => {
                const ae = q(n, W);
                return await M(ae && ae._f ? {
                    [W]: ae
                } : ae)
            }
            ))).every(Boolean),
            !(!G && !r.isValid) && w()) : G = A = await M(n);
        return h.state.next({
            ...!Ln(C) || f.isValid && A !== r.isValid ? {} : {
                name: C
            },
            ...t.resolver || !C ? {
                isValid: A
            } : {},
            errors: r.errors
        }),
        I.shouldFocus && !G && ru(n, he, C ? H : o.mount),
        G
    }
      , De = C => {
        const I = {
            ...a.mount ? i : s
        };
        return kt(C) ? I : Ln(C) ? q(I, C) : C.map(A => q(I, A))
    }
      , Fe = (C, I) => ({
        invalid: !!q((I || r).errors, C),
        isDirty: !!q((I || r).dirtyFields, C),
        error: q((I || r).errors, C),
        isValidating: !!q(r.validatingFields, C),
        isTouched: !!q((I || r).touchedFields, C)
    })
      , Ir = C => {
        C && tu(C).forEach(I => Rt(r.errors, I)),
        h.state.next({
            errors: C ? r.errors : {}
        })
    }
      , Qt = (C, I, A) => {
        const G = (q(n, C, {
            _f: {}
        })._f || {}).ref
          , H = q(r.errors, C) || {}
          , {ref: W, message: ae, type: Ee, ...wt} = H;
        Be(r.errors, C, {
            ...wt,
            ...I,
            ref: G
        }),
        h.state.next({
            name: C,
            errors: r.errors,
            isValid: !1
        }),
        A && A.shouldFocus && G && G.focus && G.focus()
    }
      , zt = (C, I) => An(C) ? h.values.subscribe({
        next: A => C($(void 0, I), A)
    }) : $(C, I, !0)
      , It = (C, I={}) => {
        for (const A of C ? tu(C) : o.mount)
            o.mount.delete(A),
            o.array.delete(A),
            I.keepValue || (Rt(n, A),
            Rt(i, A)),
            !I.keepError && Rt(r.errors, A),
            !I.keepDirty && Rt(r.dirtyFields, A),
            !I.keepTouched && Rt(r.touchedFields, A),
            !I.keepIsValidating && Rt(r.validatingFields, A),
            !t.shouldUnregister && !I.keepDefaultValue && Rt(s, A);
        h.values.next({
            values: {
                ...i
            }
        }),
        h.state.next({
            ...r,
            ...I.keepDirty ? {
                isDirty: z()
            } : {}
        }),
        !I.keepIsValid && w()
    }
      , or = ({disabled: C, name: I, field: A, fields: G}) => {
        (qr(C) && a.mount || C || o.disabled.has(I)) && (C ? o.disabled.add(I) : o.disabled.delete(I),
        L(I, Cm(A ? A._f : q(G, I)._f), !1, !1, !0))
    }
      , xs = (C, I={}) => {
        let A = q(n, C);
        const G = qr(I.disabled) || qr(t.disabled);
        return Be(n, C, {
            ...A || {},
            _f: {
                ...A && A._f ? A._f : {
                    ref: {
                        name: C
                    }
                },
                name: C,
                mount: !0,
                ...I
            }
        }),
        o.mount.add(C),
        A ? or({
            field: A,
            disabled: qr(I.disabled) ? I.disabled : t.disabled,
            name: C
        }) : j(C, !0, I.value),
        {
            ...G ? {
                disabled: I.disabled || t.disabled
            } : {},
            ...t.progressive ? {
                required: !!I.required,
                min: Cl(I.min),
                max: Cl(I.max),
                minLength: Cl(I.minLength),
                maxLength: Cl(I.maxLength),
                pattern: Cl(I.pattern)
            } : {},
            name: C,
            onChange: B,
            onBlur: B,
            ref: H => {
                if (H) {
                    xs(C, I),
                    A = q(n, C);
                    const W = kt(H.value) && H.querySelectorAll && H.querySelectorAll("input,select,textarea")[0] || H
                      , ae = dq(W)
                      , Ee = A._f.refs || [];
                    if (ae ? Ee.find(wt => wt === W) : W === A._f.ref)
                        return;
                    Be(n, C, {
                        _f: {
                            ...A._f,
                            ...ae ? {
                                refs: [...Ee.filter(Tm), W, ...Array.isArray(q(s, C)) ? [{}] : []],
                                ref: {
                                    type: W.type,
                                    name: C
                                }
                            } : {
                                ref: W
                            }
                        }
                    }),
                    j(C, !1, void 0, W)
                } else
                    A = q(n, C, {}),
                    A._f && (A._f.mount = !1),
                    (t.shouldUnregister || I.shouldUnregister) && !(Q_(o.array, C) && a.action) && o.unMount.add(C)
            }
        }
    }
      , hc = () => t.shouldFocusError && ru(n, he, o.mount)
      , kh = C => {
        qr(C) && (h.state.next({
            disabled: C
        }),
        ru(n, (I, A) => {
            const G = q(n, A);
            G && (I.disabled = G._f.disabled || C,
            Array.isArray(G._f.refs) && G._f.refs.forEach(H => {
                H.disabled = G._f.disabled || C
            }
            ))
        }
        , 0, !1))
    }
      , mc = (C, I) => async A => {
        let G;
        A && (A.preventDefault && A.preventDefault(),
        A.persist && A.persist());
        let H = wr(i);
        if (o.disabled.size)
            for (const W of o.disabled)
                Be(H, W, void 0);
        if (h.state.next({
            isSubmitting: !0
        }),
        t.resolver) {
            const {errors: W, values: ae} = await b();
            r.errors = W,
            H = ae
        } else
            await M(n);
        if (Rt(r.errors, "root"),
        _r(r.errors)) {
            h.state.next({
                errors: {}
            });
            try {
                await C(H, A)
            } catch (W) {
                G = W
            }
        } else
            I && await I({
                ...r.errors
            }, A),
            hc(),
            setTimeout(hc);
        if (h.state.next({
            isSubmitted: !0,
            isSubmitting: !1,
            isSubmitSuccessful: _r(r.errors) && !G,
            submitCount: r.submitCount + 1,
            errors: r.errors
        }),
        G)
            throw G
    }
      , Ut = (C, I={}) => {
        q(n, C) && (kt(I.defaultValue) ? xt(C, wr(q(s, C))) : (xt(C, I.defaultValue),
        Be(s, C, wr(I.defaultValue))),
        I.keepTouched || Rt(r.touchedFields, C),
        I.keepDirty || (Rt(r.dirtyFields, C),
        r.isDirty = I.defaultValue ? z(C, wr(q(s, C))) : z()),
        I.keepError || (Rt(r.errors, C),
        f.isValid && w()),
        h.state.next({
            ...r
        }))
    }
      , Wn = (C, I={}) => {
        const A = C ? wr(C) : s
          , G = wr(A)
          , H = _r(C)
          , W = H ? s : G;
        if (I.keepDefaultValues || (s = A),
        !I.keepValues) {
            if (I.keepDirtyValues) {
                const ae = new Set([...o.mount, ...Object.keys(Tl(s, i))]);
                for (const Ee of Array.from(ae))
                    q(r.dirtyFields, Ee) ? Be(W, Ee, q(i, Ee)) : xt(Ee, q(W, Ee))
            } else {
                if (Nv && kt(C))
                    for (const ae of o.mount) {
                        const Ee = q(n, ae);
                        if (Ee && Ee._f) {
                            const wt = Array.isArray(Ee._f.refs) ? Ee._f.refs[0] : Ee._f.ref;
                            if (Mf(wt)) {
                                const ft = wt.closest("form");
                                if (ft) {
                                    ft.reset();
                                    break
                                }
                            }
                        }
                    }
                n = {}
            }
            i = t.shouldUnregister ? I.keepDefaultValues ? wr(s) : {} : wr(W),
            h.array.next({
                values: {
                    ...W
                }
            }),
            h.values.next({
                values: {
                    ...W
                }
            })
        }
        o = {
            mount: I.keepDirtyValues ? o.mount : new Set,
            unMount: new Set,
            array: new Set,
            disabled: new Set,
            watch: new Set,
            watchAll: !1,
            focus: ""
        },
        a.mount = !f.isValid || !!I.keepIsValid || !!I.keepDirtyValues,
        a.watch = !!t.shouldUnregister,
        h.state.next({
            submitCount: I.keepSubmitCount ? r.submitCount : 0,
            isDirty: H ? !1 : I.keepDirty ? r.isDirty : !!(I.keepDefaultValues && !Ds(C, s)),
            isSubmitted: I.keepIsSubmitted ? r.isSubmitted : !1,
            dirtyFields: H ? {} : I.keepDirtyValues ? I.keepDefaultValues && i ? Tl(s, i) : r.dirtyFields : I.keepDefaultValues && C ? Tl(s, C) : I.keepDirty ? r.dirtyFields : {},
            touchedFields: I.keepTouched ? r.touchedFields : {},
            errors: I.keepErrors ? r.errors : {},
            isSubmitSuccessful: I.keepIsSubmitSuccessful ? r.isSubmitSuccessful : !1,
            isSubmitting: !1
        })
    }
      , ol = (C, I) => Wn(An(C) ? C(i) : C, I);
    return {
        control: {
            register: xs,
            unregister: It,
            getFieldState: Fe,
            handleSubmit: mc,
            setError: Qt,
            _executeSchema: b,
            _getWatch: $,
            _getDirty: z,
            _updateValid: w,
            _removeUnmounted: D,
            _updateFieldArray: p,
            _updateDisabledField: or,
            _getFieldArray: Y,
            _reset: Wn,
            _resetDefaultValues: () => An(t.defaultValues) && t.defaultValues().then(C => {
                ol(C, t.resetOptions),
                h.state.next({
                    isLoading: !1
                })
            }
            ),
            _updateFormState: C => {
                r = {
                    ...r,
                    ...C
                }
            }
            ,
            _disableForm: kh,
            _subjects: h,
            _proxyFormState: f,
            _setErrors: P,
            get _fields() {
                return n
            },
            get _formValues() {
                return i
            },
            get _state() {
                return a
            },
            set _state(C) {
                a = C
            },
            get _defaultValues() {
                return s
            },
            get _names() {
                return o
            },
            set _names(C) {
                o = C
            },
            get _formState() {
                return r
            },
            set _formState(C) {
                r = C
            },
            get _options() {
                return t
            },
            set _options(C) {
                t = {
                    ...t,
                    ...C
                }
            }
        },
        trigger: me,
        register: xs,
        handleSubmit: mc,
        watch: zt,
        setValue: xt,
        getValues: De,
        reset: ol,
        resetField: Ut,
        clearErrors: Ir,
        unregister: It,
        setError: Qt,
        setFocus: (C, I={}) => {
            const A = q(n, C)
              , G = A && A._f;
            if (G) {
                const H = G.refs ? G.refs[0] : G.ref;
                H.focus && (H.focus(),
                I.shouldSelect && An(H.select) && H.select())
            }
        }
        ,
        getFieldState: Fe
    }
}
function dc(e={}) {
    const t = ve.useRef(void 0)
      , r = ve.useRef(void 0)
      , [n,s] = ve.useState({
        isDirty: !1,
        isValidating: !1,
        isLoading: An(e.defaultValues),
        isSubmitted: !1,
        isSubmitting: !1,
        isSubmitSuccessful: !1,
        isValid: !1,
        submitCount: 0,
        dirtyFields: {},
        touchedFields: {},
        validatingFields: {},
        errors: e.errors || {},
        disabled: e.disabled || !1,
        defaultValues: An(e.defaultValues) ? void 0 : e.defaultValues
    });
    t.current || (t.current = {
        ...vq(e),
        formState: n
    });
    const i = t.current.control;
    return i._options = e,
    Rv({
        subject: i._subjects.state,
        next: a => {
            J_(a, i._proxyFormState, i._updateFormState, !0) && s({
                ...i._formState
            })
        }
    }),
    ve.useEffect( () => i._disableForm(e.disabled), [i, e.disabled]),
    ve.useEffect( () => {
        if (i._proxyFormState.isDirty) {
            const a = i._getDirty();
            a !== n.isDirty && i._subjects.state.next({
                isDirty: a
            })
        }
    }
    , [i, n.isDirty]),
    ve.useEffect( () => {
        e.values && !Ds(e.values, r.current) ? (i._reset(e.values, i._options.resetOptions),
        r.current = e.values,
        s(a => ({
            ...a
        }))) : i._resetDefaultValues()
    }
    , [e.values, i]),
    ve.useEffect( () => {
        e.errors && i._setErrors(e.errors)
    }
    , [e.errors, i]),
    ve.useEffect( () => {
        i._state.mount || (i._updateValid(),
        i._state.mount = !0),
        i._state.watch && (i._state.watch = !1,
        i._subjects.state.next({
            ...i._formState
        })),
        i._removeUnmounted()
    }
    ),
    ve.useEffect( () => {
        e.shouldUnregister && i._subjects.values.next({
            values: i._getWatch()
        })
    }
    , [e.shouldUnregister, i]),
    t.current.formState = Y_(n, i),
    t.current
}
const P1 = (e, t, r) => {
    if (e && "reportValidity"in e) {
        const n = q(r, t);
        e.setCustomValidity(n && n.message || ""),
        e.reportValidity()
    }
}
  , lT = (e, t) => {
    for (const r in t.fields) {
        const n = t.fields[r];
        n && n.ref && "reportValidity"in n.ref ? P1(n.ref, r, e) : n.refs && n.refs.forEach(s => P1(s, r, e))
    }
}
  , bq = (e, t) => {
    t.shouldUseNativeValidation && lT(e, t);
    const r = {};
    for (const n in e) {
        const s = q(t.fields, n)
          , i = Object.assign(e[n] || {}, {
            ref: s && s.ref
        });
        if (xq(t.names || Object.keys(e), n)) {
            const a = Object.assign({}, q(r, n));
            Be(a, "root", i),
            Be(r, n, a)
        } else
            Be(r, n, i)
    }
    return r
}
  , xq = (e, t) => e.some(r => r.startsWith(t + "."));
var wq = function(e, t) {
    for (var r = {}; e.length; ) {
        var n = e[0]
          , s = n.code
          , i = n.message
          , a = n.path.join(".");
        if (!r[a])
            if ("unionErrors"in n) {
                var o = n.unionErrors[0].errors[0];
                r[a] = {
                    message: o.message,
                    type: o.code
                }
            } else
                r[a] = {
                    message: i,
                    type: s
                };
        if ("unionErrors"in n && n.unionErrors.forEach(function(f) {
            return f.errors.forEach(function(h) {
                return e.push(h)
            })
        }),
        t) {
            var l = r[a].types
              , c = l && l[n.code];
            r[a] = tT(a, t, r, s, c ? [].concat(c, n.message) : n.message)
        }
        e.shift()
    }
    return r
}
  , fc = function(e, t, r) {
    return r === void 0 && (r = {}),
    function(n, s, i) {
        try {
            return Promise.resolve(function(a, o) {
                try {
                    var l = Promise.resolve(e[r.mode === "sync" ? "parse" : "parseAsync"](n, t)).then(function(c) {
                        return i.shouldUseNativeValidation && lT({}, i),
                        {
                            errors: {},
                            values: r.raw ? n : c
                        }
                    })
                } catch (c) {
                    return o(c)
                }
                return l && l.then ? l.then(void 0, o) : l
            }(0, function(a) {
                if (function(o) {
                    return Array.isArray(o == null ? void 0 : o.errors)
                }(a))
                    return {
                        values: {},
                        errors: bq(wq(a.errors, !i.shouldUseNativeValidation && i.criteriaMode === "all"), i)
                    };
                throw a
            }))
        } catch (a) {
            return Promise.reject(a)
        }
    }
};
function Sq({inventoryItemId: e, defaultValues: t, disabled: r, onSubmit: n, salesChannel: s}) {
    var c;
    const i = dc({
        resolver: fc(rS),
        defaultValues: {
            inventoryItemId: e,
            name: t != null && t.name ? t.name : s === "in_person" ? "For sale" : "",
            price: (t == null ? void 0 : t.price) ?? 100,
            salesChannel: s
        }
    })
      , [a,o] = g.useState(!1)
      , l = rv();
    return d.jsxs("form", {
        className: "space-y-5",
        onSubmit: i.handleSubmit(n, console.log),
        children: [s !== "in_person" && d.jsx(Dn, {
            name: "name",
            control: i.control,
            render: ({field: f, fieldState: h}) => d.jsxs("div", {
                children: [d.jsx(pi, {
                    ...f,
                    placeholder: "Name",
                    autoFocus: !0
                }), h.error && d.jsx("span", {
                    className: "text-xs text-red-500",
                    children: h.error.message
                })]
            })
        }), d.jsx(Dn, {
            name: "price",
            control: i.control,
            render: ({field: f, fieldState: h}) => d.jsxs("div", {
                className: "flex flex-col items-start",
                children: [d.jsxs("div", {
                    className: "flex items-center gap-2 relative",
                    children: [d.jsx("label", {
                        htmlFor: "price",
                        className: "absolute left-4 top-1/2 -translate-y-1/2",
                        children: d.jsx(tl, {
                            className: "w-6"
                        })
                    }), d.jsx(pi, {
                        ...f,
                        placeholder: "Price",
                        type: "number",
                        min: 0,
                        className: "!pl-12",
                        inputMode: "numeric",
                        pattern: "\\d*",
                        step: 1,
                        onKeyDown: m => {
                            (m.key === "." || m.key === "e" || m.key === "-") && m.preventDefault()
                        }
                    })]
                }), h.error && d.jsx("span", {
                    className: "text-xs text-red-500",
                    children: h.error.message
                })]
            })
        }), d.jsx("div", {
            className: "ml-2 my-1",
            children: d.jsx(Rf, {
                labelProps: {
                    className: "text-nowrap pl-3"
                },
                labelLeft: !0,
                isSelected: a,
                onChange: () => o(f => !f),
                children: d.jsxs("p", {
                    className: "text-left leading-tight",
                    children: ["Ban me if this blob is against", d.jsx("br", {}), " community guidelines"]
                })
            })
        }), d.jsx(at, {
            type: "submit",
            variant: "filled",
            bg: "purple",
            size: "lg",
            className: "min-w-60",
            disabled: r || !a || !((c = l.data) != null && c.ok) || !l.data.value.remaining,
            children: s === "store" ? "Put on Store" : "Sell in person"
        })]
    })
}
function kq(e) {
    var S;
    jt();
    const [t,r] = ir()
      , n = Dy()
      , s = gi()
      , [i,a] = g.useState()
      , [o,l] = g.useState(!1)
      , c = rv()
      , f = J7(e.id)
      , h = GL();
    if (f.isLoading || !f.data)
        return d.jsx(Pm, {
            children: d.jsx("div", {
                className: "pb-10",
                children: d.jsx(ar, {
                    size: "xl"
                })
            })
        });
    if (!f.data.ok) {
        let P = "Something went wrong"
          , j = "There was an error loading this item. Try again.";
        return f.data.error.code === "NOT_FOUND" && (P = "Couldn't find item",
        j = "Is it in your inventory? Does it still exist?"),
        f.data.error.code === "FORBIDDEN" && (P = "Keep out",
        j = "You are not authorized to view this item."),
        d.jsx(Pm, {
            children: d.jsxs("div", {
                className: "m-auto text-center pb-10",
                children: [d.jsx("p", {
                    className: "text-3xl mb-5",
                    children: P
                }), d.jsx("p", {
                    children: j
                })]
            })
        })
    }
    const {value: m} = f.data
      , {blob: y} = m;
    (S = s.limitsQuery) != null && S.ok && s.limitsQuery.value.remaining;
    function k() {
        t.delete("itemId"),
        r(t)
    }
    async function x(P) {
        const j = gu();
        try {
            const L = await h.mutateAsync(P);
            if (!L.ok) {
                ke.error(L.error.message);
                return
            }
            k(),
            ke.success(i === "store" ? `${P.name} listed on store.` : "Item available for in-person sale.")
        } catch {
            ke.error("Failed to create product. Try again.")
        } finally {
            j()
        }
    }
    async function w() {
        switch (y.blobType) {
        case "item":
            {
                (await ge.emitUseItem(e.id)).ok || ke.error("Failed to use item. Try again.");
                break
            }
        case "avatar":
            {
                (await ge.emitEquipAvatar(e.id)).ok || ke.error("Failed to equip avatar. Try again.");
                break
            }
        case "building":
            {
                await ge.emitUseItem(e.id),
                (await ge.emitPlaceBuilding(e.id)).ok || ke.error("Failed to use item. Try again.");
                break
            }
        default:
            y.blobType;
            break
        }
        k()
    }
    async function v() {
        try {
            const P = await ge.deleteInventoryItem(e.id);
            if (!P.ok) {
                ke.error(P.error.message);
                return
            }
            k(),
            ke.success("Deleted inventory item")
        } catch {
            ke.error("Failed to delete item. Try again.")
        }
    }
    async function p() {
        switch (y.blobType) {
        case "avatar":
            return ge.emitEditAvatar(m.id);
        case "building":
            return ge.emitEditBuilding(m.id);
        default:
            console.warn("Attempted to update an invalid item type")
        }
    }
    return d.jsx(Pm, {
        isSelling: !!i,
        children: d.jsxs("div", {
            className: "flex-1 flex items-center gap-10 my-auto",
            children: [d.jsx("div", {
                className: "w-1/2 flex flex-col items-center justify-center gap-3",
                children: i ? d.jsx(Sq, {
                    inventoryItemId: e.id,
                    onSubmit: x,
                    disabled: h.isPending,
                    salesChannel: i
                }) : d.jsxs(d.Fragment, {
                    children: [Ve.client && d.jsx(at, {
                        variant: "filled",
                        bg: "yellow",
                        size: "lg",
                        className: "min-w-60",
                        disabled: n.isLockingAction,
                        onClick: w,
                        children: "Use"
                    }), Ve.client && (y.blobType === "avatar" || y.blobType === "building") && d.jsx(at, {
                        variant: "filled",
                        bg: "purple",
                        size: "lg",
                        className: "min-w-60",
                        disabled: n.isLockingAction || !!s.editingAvatarId && y.blobType === "avatar" || !!s.editingBuildingId && y.blobType === "building",
                        onClick: p,
                        children: "Update"
                    }), y.blobType !== "building" && d.jsx(at, {
                        variant: "filled",
                        bg: "blue",
                        size: "lg",
                        className: "min-w-60",
                        disabled: n.isLockingAction,
                        onClick: () => {
                            var P;
                            if (!((P = c.data) != null && P.ok) || !c.data.value.remaining) {
                                ke.error("Unlist some items or wait for them to sell first.");
                                return
                            }
                            a("store")
                        }
                        ,
                        children: "Put on store"
                    }), f.data.value.blob.blobType === "item" && d.jsx(at, {
                        variant: "filled",
                        bg: "forest",
                        size: "lg",
                        className: "min-w-60",
                        disabled: n.isLockingAction,
                        onClick: () => {
                            var P;
                            if (!((P = c.data) != null && P.ok) || !c.data.value.remaining) {
                                ke.error("Unlist some items or wait for them to sell first.");
                                return
                            }
                            a("in_person")
                        }
                        ,
                        children: "Sell in person"
                    }), o ? d.jsxs("div", {
                        className: "flex items-center h-[3.25rem] gap-3",
                        children: [d.jsx("button", {
                            type: "button",
                            onClick: v,
                            disabled: n.isLockingAction,
                            className: "opacity-75 hover:opacity-100 px-2 py-1 bg-red-50 text-red-700 rounded",
                            children: "Yes, delete it"
                        }), d.jsx("button", {
                            type: "button",
                            onClick: () => l(!1),
                            disabled: n.isLockingAction,
                            className: "opacity-75 hover:opacity-100 px-2 py-1",
                            children: "Cancel"
                        })]
                    }) : d.jsx(at, {
                        variant: "filled",
                        bg: "red",
                        size: "lg",
                        className: "min-w-60",
                        disabled: n.isLockingAction,
                        onClick: () => l(!0),
                        children: "Delete"
                    })]
                })
            }), d.jsxs("div", {
                className: "w-1/2 flex flex-col items-center justify-center gap-10",
                children: [d.jsx("p", {
                    className: "flex items-center justify-center w-full px-10 max-w-md",
                    children: d.jsx("img", {
                        src: y.thumbnailUrl ?? "",
                        alt: "Inventory item thumbnail",
                        className: "block w-full",
                        loading: "lazy"
                    })
                }), y.sealedAt && d.jsxs(d.Fragment, {
                    children: [d.jsx("img", {
                        src: "/sealed.png",
                        alt: "Sealed blob badge",
                        className: "absolute -bottom-6 -right-6 w-32 -rotate-6 block drop-shadow-sm z-10"
                    }), d.jsx("div", {
                        className: "flex items-center justify-center shadow-xl bg-[#E5BD5F] rounded-b-lg absolute left-0 right-0 bottom-0 p-2 text-white",
                        children: d.jsxs("p", {
                            className: "text-lg",
                            style: {
                                textShadow: "0 -1px 1px rgba(0,0,0,0.2)"
                            },
                            children: ["Created by ", y.creator.displayName, " ", bh(y.sealedAt)]
                        })
                    })]
                })]
            })]
        })
    })
}
function Pm({children: e, isSelling: t}) {
    const [r] = ir();
    return r.delete("itemId"),
    d.jsx("div", {
        className: "fixed inset-0 z-50 bg-gray-50 bg-opacity-80 flex overflow-auto",
        children: d.jsxs("section", {
            className: "relative w-[95%] max-w-4xl mx-auto flex flex-col flex-1 bg-white p-10 m-auto rounded-lg shadow-xl",
            children: [d.jsx(Kt, {
                to: {
                    pathname: "/inventory",
                    search: r.toString()
                },
                className: "p-2 opacity-75 hover:opacity-100 absolute top-5 left-5 mr-10",
                title: "Close item",
                children: d.jsx(vv, {
                    className: "w-8 h-8"
                })
            }), d.jsx("div", {
                className: "flex items-center justify-center m-auto text-center w-full min-h-[22rem]",
                children: e
            }), t && d.jsx("p", {
                className: "p-3 rounded bg-orange-50 border border-orange-200 text-orange-950 text-center",
                children: "Selling, buying and trading explicit content will result in a minimum ban of 30 days."
            })]
        })
    })
}
function Eq({item: e, showType: t}) {
    const r = Je()
      , n = gi()
      , [s] = ir()
      , i = e.blobId === r.currentAvatarId
      , a = e.blobId === n.editingAvatarId
      , o = e.blobId === n.placedBuildingId
      , l = e.blobId === n.editingBuildingId;
    return s.set("itemId", e.id),
    d.jsx("li", {
        className: "relative",
        children: d.jsx(Kt, {
            to: {
                pathname: "/inventory",
                search: s.toString()
            },
            className: fe("group w-full", (i || a || o || l) && "pointer-events-none"),
            children: d.jsxs(rl, {
                borderProps: {
                    shape: "square",
                    strokeWidth: 10,
                    className: fe(e.blobType === "item" && "text-[#E9FCDD] group-hover:text-[#7AE137]", e.blobType === "building" ? l || i ? l ? "text-rose-50" : "text-purp-50" : "text-purp-50 group-hover:text-purp-400" : "", e.blobType === "avatar" && i ? "text-[#30A0C9]" : a ? "text-amber-600" : "text-[#C2E4F1] group-hover:text-[#30A0C9]")
                },
                className: "p-6 flex items-center justify-center w-full aspect-square relative",
                children: [d.jsx("img", {
                    src: e.thumbnailUrl ?? "",
                    alt: "Inventory item thumbnail",
                    className: "block w-full",
                    loading: "lazy"
                }), d.jsx("p", {
                    "aria-label": "Category",
                    className: fe("absolute bottom-4 left-6 capitalize truncate", t ? "opacity-50 group-hover:opacity-100" : "opacity-10 group-hover:opacity-30"),
                    children: e.blobType
                }), i && d.jsx("p", {
                    className: "p-1 text-3xl text-center text-blu-600 uppercase font-bold -rotate-12 bg-white rounded-2xl absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2",
                    children: "Equipped"
                }), a && d.jsx("p", {
                    className: "p-1 text-3xl text-center text-amber-600 uppercase font-bold -rotate-12 bg-white rounded-2xl absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2",
                    children: "Editing"
                }), o && d.jsx("p", {
                    className: "p-1 text-3xl text-center text-purp-600 uppercase font-bold -rotate-12 bg-white rounded-2xl absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2",
                    children: "Constructed"
                }), l && d.jsx("p", {
                    className: "p-1 text-3xl text-center text-rose-600 uppercase font-bold -rotate-12 bg-white rounded-2xl absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2",
                    children: "Under Construction"
                }), e.blobSealedAt && d.jsx("img", {
                    src: "/sealed.png",
                    alt: "Sealed blob badge",
                    className: "absolute -bottom-2 -right-2 w-2/5 -rotate-6 block drop-shadow-sm"
                })]
            })
        })
    })
}
function _q() {
    var o;
    const [e,t] = ir()
      , r = e.get("itemId") ?? void 0
      , n = e.get("type") ?? void 0
      , s = gi();
    g.useEffect( () => {
        ge.fetchItems()
    }
    , []),
    eq("inventory_query_params");
    const i = [{
        label: "All",
        isActive: !n,
        onClick: l => {
            l.preventDefault(),
            e.delete("type"),
            t(e)
        }
    }, {
        label: "Avatars",
        isActive: n === "avatar",
        onClick: l => {
            l.preventDefault(),
            e.set("type", "avatar"),
            t(e)
        }
    }, {
        label: "Blobs",
        isActive: n === "item",
        onClick: l => {
            l.preventDefault(),
            e.set("type", "item"),
            t(e)
        }
    }]
      , a = (o = s.itemsQuery) != null && o.ok ? n ? s.itemsQuery.value.filter(l => l.blobType === n) : s.itemsQuery.value : [];
    return d.jsxs(d.Fragment, {
        children: [d.jsxs("section", {
            className: "flex flex-1 w-full h-full",
            children: [d.jsxs("div", {
                className: "flex flex-col w-72 bg-gray-50",
                children: [d.jsx("form", {
                    className: "mt-6",
                    children: d.jsx("div", {
                        className: "flex flex-col items-start gap-1 text-xl",
                        children: i.map(l => d.jsxs("button", {
                            type: "button",
                            className: fe("flex items-center w-full text-left pl-10 py-3", l.isActive ? "bg-white" : "opacity-50 hover:opacity-100"),
                            onClick: l.onClick,
                            children: [l.isActive && d.jsx("span", {
                                className: "block rounded-full bg-lime-400 w-2 h-2 mr-3"
                            }), l.label]
                        }, l.label))
                    })
                }), d.jsxs("div", {
                    className: "mt-4 pt-6 border-t border-gray-300 text-xl",
                    children: [d.jsxs(Kt, {
                        to: {
                            pathname: "/inventory/lost-found"
                        },
                        className: "flex items-center w-full text-left pl-10 py-3 opacity-50 hover:opacity-100",
                        children: [d.jsx(u8, {
                            className: "w-6 h-6 mr-3"
                        }), "Lost & Found"]
                    }), d.jsxs(Kt, {
                        to: {
                            pathname: "/inventory/for-sale"
                        },
                        className: "flex items-center w-full text-left pl-10 py-3 opacity-50 hover:opacity-100",
                        children: [d.jsx(d8, {
                            className: "w-6 h-6 mr-3"
                        }), "Tagged For Sale"]
                    })]
                }), d.jsx(H_, {})]
            }), d.jsxs("div", {
                className: "flex flex-1 flex-col max-h-full",
                children: [s.isFetchingItems && !a.length && d.jsx("div", {
                    className: "flex items-center justify-center flex-1",
                    children: d.jsx(ar, {
                        size: "lg"
                    })
                }), a.length > 0 && d.jsx("div", {
                    className: "overflow-auto flex-1",
                    children: d.jsx("ul", {
                        className: "grid justify-start grid-cols-2 lg:grid-cols-3 xl:grid-cols-5 gap-4 lg:gap-6 px-10 pb-10 pt-4",
                        children: a.map(l => d.jsx(Eq, {
                            item: l,
                            showType: !n
                        }, l.id + l.thumbnailUrl))
                    })
                }), d.jsx(tq, {})]
            })]
        }), r && d.jsx(kq, {
            id: r
        })]
    })
}
function Tq() {
    const e = ki()
      , t = Je()
      , r = eD()
      , n = dc({
        resolver: fc(aS),
        defaultValues: {
            username: "",
            password: ""
        }
    });
    g.useEffect( () => {
        t.status === "AUTHORIZED" && e("/inventory")
    }
    , [t.status]);
    async function s(i) {
        try {
            await r.mutateAsync(i)
        } catch (a) {
            console.error("Login failed", a)
        }
    }
    return d.jsx("section", {
        className: "w-full h-full flex items-center justify-center",
        children: d.jsxs("form", {
            onSubmit: n.handleSubmit(s),
            children: [d.jsx(Dn, {
                name: "username",
                control: n.control,
                render: ({field: i}) => d.jsx("input", {
                    ...i,
                    type: "text",
                    placeholder: "Username",
                    className: "border border-gray-300 rounded p-2 mb-2"
                })
            }), d.jsx(Dn, {
                name: "password",
                control: n.control,
                render: ({field: i}) => d.jsx("input", {
                    ...i,
                    type: "password",
                    placeholder: "Password",
                    className: "border border-gray-300 rounded p-2 mb-2"
                })
            }), d.jsx("button", {
                type: "submit",
                className: "bg-blue-500 text-white rounded p-2",
                children: "Login"
            })]
        })
    })
}
function Cq() {
    var r;
    const e = Qk({
        staleTime: 6e5
    })
      , t = new Set((r = e.data) == null ? void 0 : r.map(n => n.userId));
    return d.jsxs("div", {
        className: "flex-1 flex border-t-2 border-gray-100 overflow-hidden",
        children: [d.jsx(Pq, {
            friendsLookup: t
        }), d.jsx($q, {
            friendsLookup: t
        })]
    })
}
function Pq(e) {
    const t = Je();
    return d.jsxs("section", {
        className: "flex flex-col flex-1 px-10 pt-10",
        children: [d.jsx("h2", {
            className: "text-3xl pb-5 mb-5 border-b border-gray-200",
            children: "Recent"
        }), d.jsx("div", {
            className: "flex-1 overflow-auto",
            children: t.recentUsers && d.jsxs(d.Fragment, {
                children: [t.recentUsers.length === 0 && d.jsx("p", {
                    className: "rounded-xl bg-gray-50 p-4 text-xl",
                    children: "Players that you've run into will appear in this list."
                }), t.recentUsers.length > 0 && d.jsx("ul", {
                    className: "space-y-4 text-xl",
                    children: t.recentUsers.map(r => d.jsx(uT, {
                        user: r,
                        alredyFriends: e.friendsLookup.has(r.id)
                    }, r.id))
                })]
            })
        })]
    })
}
function $q(e) {
    var i;
    const t = dc({
        resolver: fc(QA),
        values: {
            name: ""
        }
    })
      , [r,n] = g.useState({})
      , s = t9(r);
    return d.jsxs("section", {
        className: "flex-1 flex flex-col w-2/5 px-10 pt-10",
        children: [d.jsx("h2", {
            className: "text-3xl pb-5 mb-5 border-b border-gray-200",
            children: "Find a friend"
        }), d.jsxs("form", {
            onSubmit: t.handleSubmit(n),
            className: "flex items-center space-x-3 mb-6",
            children: [d.jsx(Dn, {
                name: "name",
                control: t.control,
                render: ({field: a, fieldState: o}) => d.jsxs("div", {
                    className: "w-60",
                    children: [d.jsx(pi, {
                        type: "search",
                        ...a,
                        placeholder: "Name",
                        autoFocus: !0,
                        minLength: 3,
                        maxLength: 32
                    }), o.error && d.jsx("span", {
                        className: "text-xs text-red-500",
                        children: o.error.message
                    })]
                })
            }), d.jsx(at, {
                type: "submit",
                variant: "filled",
                bg: "blue",
                size: "lg",
                disabled: !t.formState.isValid || s.isFetching,
                children: "Search"
            }), s.isFetching && d.jsx(ar, {
                size: "md",
                className: "ml-3"
            })]
        }), d.jsx("div", {
            className: "flex-1 overflow-auto",
            children: ((i = s.data) == null ? void 0 : i.ok) && d.jsxs(d.Fragment, {
                children: [s.data.value.length === 0 && d.jsx("p", {
                    children: "No users found"
                }), s.data.value.length > 0 && d.jsx("ul", {
                    className: "space-y-4 pl-4",
                    children: s.data.value.map(a => d.jsx(uT, {
                        user: a,
                        alredyFriends: e.friendsLookup.has(a.id)
                    }, a.id))
                })]
            })
        })]
    })
}
function uT({user: e, alredyFriends: t}) {
    var o;
    const r = Je()
      , [n,s] = g.useState(!1)
      , i = KL();
    if (((o = r.currentUser) == null ? void 0 : o.id) === e.id)
        return null;
    async function a() {
        i.mutate({
            userId: e.id
        }, {
            onSuccess: () => {
                s(!0),
                ke.success(`Friend request sent to ${e.displayName}`)
            }
            ,
            onError: l => {
                if (l.message === "You've already requested to be friends.") {
                    s(!0);
                    return
                }
                ke.error(l.message || "Failed to send friend request")
            }
        })
    }
    return d.jsxs("li", {
        className: "group flex items-center gap-3",
        children: [d.jsxs("div", {
            className: "flex items-center",
            children: [!t && d.jsx("div", {
                className: "flex items-center h-10 ml-auto text-lg",
                children: n ? d.jsx("div", {
                    className: "flex items-center px-3",
                    children: d.jsx(h8, {
                        className: "m-auto text-green-500 mr-3"
                    })
                }) : d.jsxs("button", {
                    type: "button",
                    onClick: a,
                    className: "ml-auto flex items-center opacity-20 group-hover:opacity-60 group-hover:hover:opacity-100 bg-blue-50 rounded h-10 px-3 flex",
                    children: [d.jsx(m8, {
                        className: "mr-3 text-blu-700"
                    }), d.jsx("span", {
                        className: "inline-flex text-blue-900",
                        children: "Add"
                    })]
                })
            }), r.isModerator && d.jsx(Kt, {
                to: `/admin/users?username=${e.displayName}`,
                className: fe("flex items-center justify-center h-10 w-10 ml-2 p-2 rounded", "opacity-20 group-hover:opacity-60 group-hover:hover:opacity-100", "text-red-500 bg-red-50"),
                children: d.jsx(hh, {
                    className: "w-4 h-4 stroke-[3px]"
                })
            })]
        }), d.jsx("p", {
            className: "text-xl",
            children: e.displayName
        })]
    })
}
function Nq({targetDate: e, onFinish: t}) {
    const r = g.useRef()
      , n = g.useCallback( () => {
        const a = new Date(e).getTime()
          , o = new Date().getTime()
          , l = a - o;
        if (l <= 0)
            return clearInterval(r.current),
            {
                days: 0,
                hours: 0,
                minutes: 0,
                seconds: 0
            };
        const c = Math.floor(l / (1e3 * 60 * 60 * 24))
          , f = Math.floor(l % (1e3 * 60 * 60 * 24) / (1e3 * 60 * 60))
          , h = Math.floor(l % (1e3 * 60 * 60) / (1e3 * 60))
          , m = Math.floor(l % (1e3 * 60) / 1e3);
        return {
            days: c,
            hours: f,
            minutes: h,
            seconds: m
        }
    }
    , [e])
      , [s,i] = g.useState(n());
    return g.useEffect( () => (r.current = setInterval( () => {
        i(n())
    }
    , 1e3),
    () => clearInterval(r.current)), [n]),
    d.jsxs(d.Fragment, {
        children: [s.days, "d ", s.hours, "h ", s.minutes, "m ", s.seconds, "s"]
    })
}
const jq = 1e3 * 60 * 60 * 24 * 90;
function Iq() {
    var t;
    const e = Je();
    return g.useEffect( () => {
        Zf()
    }
    , []),
    d.jsx("div", {
        className: "flex-1 flex overflow-auto",
        children: d.jsxs("div", {
            className: "m-auto flex flex-col items-center justify-center py-10",
            children: [d.jsxs("header", {
                className: "text-center",
                children: [d.jsx("p", {
                    children: d.jsx(p8, {
                        className: "w-12 h-12 inline-block mb-6"
                    })
                }), d.jsx("h1", {
                    className: "text-5xl",
                    children: (t = e.currentUser) == null ? void 0 : t.displayName
                })]
            }), d.jsx("section", {
                className: "my-20 flex items-center text-center max-w-[800px]",
                children: d.jsx("p", {
                    className: "p-3 rounded bg-orange-50 border border-orange-200 text-orange-950 text-center",
                    children: "Changing your name requires a restart to take effect. Every change is logged and monitored. Using an inappropriate name or impersonating others will result in a ban and/or loss of these privileges."
                })
            }), d.jsx("section", {
                className: "flex flex-col w-full w-[800px] gap-12",
                children: d.jsx(Oq, {})
            }), d.jsx(Mq, {})]
        })
    })
}
function Rq(e) {
    return e.trim().replace(/[^a-zA-Z0-9._-]/g, "")
}
function Oq() {
    var o, l;
    const e = Je()
      , [t,r] = g.useState("")
      , n = tv()
      , s = e.profileChangeCooldowns.displayName ? new Date(e.profileChangeCooldowns.displayName).getTime() > Date.now() : !1;
    async function i(c) {
        var f, h;
        if (c.preventDefault(),
        (f = e.currentUser) != null && f.id && ((h = e.currentUser) == null ? void 0 : h.displayName) !== t)
            try {
                const m = await n.mutateAsync({
                    id: e.currentUser.id,
                    data: {
                        displayName: t
                    }
                });
                if (!m.ok) {
                    ke.error(m.error.message);
                    return
                }
                Se.currentUser = {
                    ...e.currentUser,
                    displayName: t
                },
                Se.profileChangeCooldowns.displayName = new Date(Date.now() + jq)
            } catch (m) {
                console.error("Failed to update username", m),
                ke.error("Failed to update username. Try again later.")
            }
    }
    const a = t && ((o = e.currentUser) == null ? void 0 : o.displayName) && t !== e.currentUser.displayName && t.toLowerCase() === e.currentUser.displayName.toLowerCase();
    return d.jsxs("div", {
        className: fe("grid grid-cols-2 gap-10", s && "items-center"),
        children: [d.jsxs("div", {
            children: [d.jsx("p", {
                className: "text-lg",
                children: "Username"
            }), d.jsx("p", {
                className: "mt-3 text-sm opacity-60",
                children: "There is a 90 day cooldown between name changes."
            }), d.jsx("p", {
                className: "mt-1 text-sm opacity-60",
                children: "Choose wisely."
            })]
        }), d.jsx("div", {
            children: s ? d.jsx("div", {
                className: "inline-block bg-gray-50 rounded px-3 py-2",
                children: e.profileChangeCooldowns.displayName ? d.jsxs("div", {
                    className: "flex items-center gap-3 text-xl",
                    children: [d.jsx(n8, {
                        className: "w-8 h-8"
                    }), d.jsx(Nq, {
                        targetDate: e.profileChangeCooldowns.displayName,
                        onFinish: Zf
                    })]
                }) : d.jsx("p", {
                    className: "text-lg",
                    children: "You can change your username after the 90 days has expired."
                })
            }) : d.jsxs(d.Fragment, {
                children: [d.jsxs("form", {
                    className: "flex items-center gap-4",
                    onSubmit: i,
                    children: [d.jsx("div", {
                        className: "-ml-2",
                        children: d.jsx(pi, {
                            name: "displayName",
                            value: t,
                            onInput: c => r(Rq(c.currentTarget.value)),
                            placeholder: "New username",
                            minLength: 3,
                            maxLength: 24
                        })
                    }), d.jsx(at, {
                        variant: "filled",
                        bg: "blue",
                        type: "submit",
                        disabled: n.isPending || t.length < 3 || t.length > 24 || t === ((l = e.currentUser) == null ? void 0 : l.displayName),
                        children: "Update"
                    })]
                }), a && d.jsx("p", {
                    className: "text-sm text-orange-600 mt-3",
                    children: "Only the capitalization of your name has changed."
                })]
            })
        })]
    })
}
function Mq() {
    var i;
    const e = Je()
      , [t,r] = g.useState("")
      , n = tv();
    if (!e.isAdmin)
        return null;
    async function s(a) {
        var o;
        if (a.preventDefault(),
        !((o = e.currentUser) != null && o.id)) {
            ke.error("You are not logged in.");
            return
        }
        try {
            const l = await n.mutateAsync({
                id: e.currentUser.id,
                data: {
                    password: e.isAdmin ? t : void 0
                }
            });
            if (!l.ok) {
                ke.error(l.error.message);
                return
            }
            ke.success("Password updated successfully.")
        } catch (l) {
            console.error("Failed to update display name", l),
            ke.error("Failed to update display name. Try again later.")
        }
    }
    return d.jsxs("section", {
        className: "mt-20 p-10 border-4 border-yellow-100 rounded w-full",
        children: [d.jsxs("p", {
            className: "text-xl flex items-center gap-2",
            children: [d.jsx(hh, {
                className: "w-6 h-6 stroke-[2.5px]"
            }), "Admins only"]
        }), d.jsx("p", {
            className: "mt-10 mb-3",
            children: d.jsx("span", {
                className: "bg-gray-50 font-mono",
                children: "https://app.blobtown.com/login"
            })
        }), d.jsxs("p", {
            className: "mb-10",
            children: ["You can use your username (", (i = e.currentUser) == null ? void 0 : i.username, ") and password to login via web browser."]
        }), d.jsxs("form", {
            onSubmit: s,
            children: [d.jsx("input", {
                className: "border border-gray-200 bg-white active:border-gray-700 p-2 w-72",
                placeholder: "Enter your new password",
                value: t,
                onInput: a => r(a.currentTarget.value),
                minLength: 8
            }), d.jsx("button", {
                type: "submit",
                className: "bg-gray-700 hover:bg-gray-900 text-white rounded ml-3 px-4 py-2",
                children: "Save"
            })]
        })]
    })
}
function Aq({id: e, defaultValues: t, onSuccess: r}) {
    const n = jt()
      , [s,i] = g.useState((t == null ? void 0 : t.name) ?? "")
      , a = Z7();
    return d.jsxs("form", {
        className: "space-y-5",
        onSubmit: o => {
            o.preventDefault(),
            a.mutate({
                id: e,
                data: {
                    name: s.substring(0, 88)
                }
            }, {
                onSuccess: () => {
                    n.invalidateQueries({
                        queryKey: ["products"]
                    }),
                    r == null || r({
                        name: s
                    })
                }
            })
        }
        ,
        children: [d.jsx(pi, {
            placeholder: "Name",
            value: s,
            onInput: o => i(o.currentTarget.value),
            maxLength: 88,
            autoFocus: !0
        }), d.jsx(at, {
            type: "submit",
            variant: "filled",
            bg: "purple",
            size: "lg",
            className: "min-w-60",
            disabled: a.isPending || !s.length || s === (t == null ? void 0 : t.name),
            children: "Update"
        })]
    })
}
function Lq(e) {
    var S, P;
    const [t,r] = ir()
      , n = Je()
      , s = gi()
      , i = X7(e.id)
      , a = JL()
      , o = W7()
      , [l,c] = g.useState(!1)
      , [f,h] = g.useState(!1)
      , m = a.isPending || o.isPending;
    if (i.isLoading)
        return d.jsx($m, {
            children: d.jsx("div", {
                className: "pb-10",
                children: d.jsx(ar, {
                    size: "xl"
                })
            })
        });
    if (!i.data)
        return d.jsx($m, {
            children: d.jsxs("div", {
                className: "m-auto text-center pb-10",
                children: [d.jsx("p", {
                    className: "text-3xl mb-5",
                    children: "Couldn't find item."
                }), d.jsx("p", {
                    children: "Has it been purchased? Does it still exist?"
                })]
            })
        });
    if (!((S = i.data) != null && S.ok))
        return d.jsx("p", {
            children: "Error. Please go back"
        });
    const {name: y, seller: k} = i.data.value
      , x = ((P = n.currentUser) == null ? void 0 : P.id) === k.id
      , w = i.data.value.blob.id;
    function v() {
        t.delete("productId"),
        r(t)
    }
    async function p() {
        var L, E, b, O;
        const j = gu();
        if ((L = i.data) != null && L.ok && n.balance < i.data.value.price) {
            j(),
            ke.error("You need more blobium to purchase that.");
            return
        }
        if ((E = s.limitsQuery) != null && E.ok && !s.limitsQuery.value.remaining) {
            j(),
            ke.error("Your inventory is full. You can't buy this item.");
            return
        }
        if ((b = n.currentUser) != null && b.id && ((O = i.data) != null && O.ok)) {
            const {id: M, name: D} = i.data.value;
            try {
                const z = await o.mutateAsync({
                    id: M
                });
                if (!z.ok)
                    return ke.error(z.error.message),
                    v();
                ke.success(`${D} purchased`),
                v(),
                vw(M)
            } catch (z) {
                console.error(z),
                ke.error("Failed to purchase product. Try again")
            } finally {
                j()
            }
        }
    }
    return d.jsxs($m, {
        children: [d.jsxs("div", {
            className: "flex-1 flex items-center gap-10 my-auto pt-6",
            children: [d.jsx("div", {
                className: "w-1/2 flex flex-col items-center justify-center gap-3",
                children: x ? d.jsxs(d.Fragment, {
                    children: [d.jsx(Aq, {
                        id: e.id,
                        defaultValues: i.data.value,
                        onSuccess: j => {
                            v(),
                            ke(`${j.name} updated`)
                        }
                    }), d.jsx(at, {
                        variant: "filled",
                        bg: "red",
                        size: "lg",
                        className: "min-w-60",
                        disabled: m,
                        onClick: async () => {
                            Om(i.data),
                            Om(s.limitsQuery);
                            const {id: j, name: L} = i.data.value
                              , {remaining: E} = s.limitsQuery.value;
                            if (E === 0) {
                                ke.error("Your inventory is full. You can't unlist this item.");
                                return
                            }
                            const b = gu();
                            try {
                                const O = await a.mutateAsync({
                                    id: j
                                });
                                if (!O.ok) {
                                    ke.error(O.error.message);
                                    return
                                }
                                v(),
                                ke.success(`${L} removed from the store.`),
                                hr.hiddenProducts.add(j)
                            } catch (O) {
                                console.error(O),
                                ke.error("Failed to unlist product. Try again")
                            } finally {
                                b()
                            }
                        }
                        ,
                        children: "Unlist"
                    })]
                }) : d.jsxs("div", {
                    className: "text-left w-full pl-10",
                    children: [d.jsxs("div", {
                        className: "pl-2",
                        children: [d.jsx("p", {
                            className: "text-2xl",
                            children: i.data.value.name
                        }), d.jsxs("p", {
                            className: "mt-2 mb-4 opacity-60",
                            children: [d.jsx("span", {
                                className: "font-normal",
                                children: "Sold by:"
                            }), " ", i.data.value.seller.displayName]
                        })]
                    }), f ? d.jsx(Dq, {
                        productId: e.id,
                        blobId: w,
                        setIsReporting: h
                    }) : d.jsxs(d.Fragment, {
                        children: [d.jsxs("div", {
                            className: "flex items-center my-6",
                            children: [l ? d.jsxs("div", {
                                className: "flex items-center h-[3.25rem] gap-3",
                                children: [d.jsx("button", {
                                    type: "button",
                                    onClick: p,
                                    disabled: m,
                                    className: "opacity-75 hover:opacity-100 px-2 py-1 bg-yellow-50 text-yellow-700 rounded",
                                    children: "Yes, buy it"
                                }), d.jsx("button", {
                                    type: "button",
                                    onClick: () => c(!1),
                                    disabled: m,
                                    className: "opacity-75 hover:opacity-100 px-2 py-1",
                                    children: "Cancel"
                                })]
                            }) : d.jsx(at, {
                                variant: "filled",
                                bg: "yellow",
                                size: "lg",
                                disabled: m,
                                onClick: () => {
                                    c(!0)
                                }
                                ,
                                children: "Buy it"
                            }), d.jsxs("div", {
                                className: "flex items-center ml-5",
                                children: [d.jsx(tl, {
                                    className: "w-6 h-6 mr-2"
                                }), d.jsx("p", {
                                    className: "text-xl",
                                    children: i.data.value.price
                                })]
                            })]
                        }), d.jsx("div", {
                            children: d.jsxs("button", {
                                type: "button",
                                onClick: j => h(!0),
                                className: "flex items-center text-red-600 mt-6 opacity-50 hover:opacity-100 ml-2",
                                children: [d.jsx(l8, {
                                    className: "w-5 h-5 mr-2"
                                }), "Report"]
                            })
                        })]
                    })]
                })
            }), d.jsx("div", {
                className: "w-1/2 flex flex-col items-center justify-center gap-4",
                children: d.jsx("p", {
                    className: "flex items-center justify-center w-full px-10 max-w-md",
                    children: d.jsx("img", {
                        src: i.data.value.blob.thumbnailUrl ?? "",
                        alt: "Product thumbnail",
                        className: "block w-full",
                        loading: "lazy"
                    })
                })
            })]
        }), i.data.value.blob.sealedAt && d.jsxs(d.Fragment, {
            children: [d.jsx("img", {
                src: "/sealed.png",
                alt: "Sealed blob badge",
                className: "absolute -bottom-6 -right-6 w-32 -rotate-6 block drop-shadow-sm z-10"
            }), d.jsx("div", {
                className: "flex items-center justify-center shadow-xl bg-[#E5BD5F] rounded-b-lg absolute left-0 right-0 bottom-0 p-2 text-white",
                children: d.jsxs("p", {
                    className: "text-lg",
                    style: {
                        textShadow: "0 -1px 1px rgba(0,0,0,0.2)"
                    },
                    children: ["Created by ", i.data.value.blob.creatorDisplayName, " ", bh(i.data.value.blob.sealedAt)]
                })
            })]
        })]
    })
}
function $m({children: e}) {
    const [t] = ir();
    t.delete("productId");
    const r = t.toString();
    return d.jsx("div", {
        className: "fixed inset-0 z-50 bg-gray-50 bg-opacity-80 flex overflow-auto",
        children: d.jsxs("section", {
            className: "relative w-[95%] max-w-4xl mx-auto flex flex-col flex-1 bg-white p-10 m-auto rounded-lg shadow-xl",
            children: [d.jsx(Kt, {
                to: {
                    pathname: "/store",
                    search: r
                },
                className: "p-2 opacity-75 hover:opacity-100 absolute top-5 left-5",
                title: "Close item",
                children: d.jsx(vv, {
                    className: "w-8 h-8"
                })
            }), d.jsx("div", {
                className: "flex items-center justify-center m-auto text-center w-full min-h-[22rem] pb-3",
                children: e
            })]
        })
    })
}
function Dq({productId: e, blobId: t, setIsReporting: r}) {
    const [n,s] = ir()
      , i = dc({
        resolver: fc(Jw),
        defaultValues: {
            reportNotes: ""
        }
    })
      , a = ZL();
    async function o(l) {
        try {
            const c = await a.mutateAsync({
                id: t,
                reportNotes: l.reportNotes
            });
            if (!c.ok)
                if (c.error.code === "ALREADY_REPORTED")
                    vw(e);
                else {
                    ke.error(c.error.message);
                    return
                }
            n.delete("productId"),
            s(n),
            ke.success("This product will be reviewed by a moderator. Thank you for your help!")
        } catch (c) {
            console.error(c),
            ke.error("Failed to report product. Try again")
        }
    }
    return d.jsxs("form", {
        onSubmit: i.handleSubmit(o, console.log),
        children: [d.jsx(Dn, {
            name: "reportNotes",
            control: i.control,
            render: ({field: l}) => d.jsx("textarea", {
                ...l,
                placeholder: "Report reason (optional)",
                className: "w-full h-24 p-2 border border-gray-300 rounded-lg"
            })
        }), d.jsxs("div", {
            className: "flex items-center gap-3 mt-4",
            children: [d.jsx(at, {
                variant: "filled",
                bg: "red",
                children: "Submit Report"
            }), d.jsx("button", {
                type: "button",
                onClick: () => r(!1),
                className: "ml-4 opacity-50 hover:opacity-100",
                children: "Cancel"
            })]
        })]
    })
}
function Fq(e) {
    const t = Je()
      , [r,n] = ir()
      , s = r.get("sellerId")
      , i = e.refreshDisabled ? c8 : sE;
    return d.jsxs("header", {
        className: "flex items-center h-24 px-10 border-b-2 border-gray-100",
        children: [d.jsx(at, {
            variant: "filled",
            size: "lg",
            bg: s ? "faded" : "blue",
            onClick: () => {
                r.delete("sellerId"),
                n(r)
            }
            ,
            children: "Blob Store"
        }), d.jsx(at, {
            variant: "filled",
            size: "lg",
            bg: s ? "blue" : "faded",
            onClick: () => {
                var a;
                (a = t.currentUser) != null && a.id && (r.set("sellerId", t.currentUser.id),
                n(r))
            }
            ,
            children: "My Store"
        }), d.jsxs("button", {
            type: "button",
            className: "ml-auto flex items-center opacity-50 hover:opacity-100 disabled:opacity-10 transition-opacity text-lg",
            onClick: e.onRefresh,
            disabled: e.refreshDisabled,
            children: [d.jsx(i, {
                className: "w-5 h-5 mr-2"
            }), "Refresh"]
        })]
    })
}
function zq({item: e, showType: t}) {
    const r = Je()
      , n = Dy()
      , [s] = ir()
      , [i,a] = g.useState(!1)
      , [o,l] = g.useState(!1)
      , c = Zk();
    return !e || n.hiddenProducts.has(e.id) ? null : (s.set("productId", e.id),
    d.jsxs("li", {
        className: fe("group relative mb-6", o && "opacity-50 pointer-events-none"),
        children: [r.isModerator && d.jsx("div", {
            className: "absolute top-0 right-0 z-20 bg-white pb-4 pl-4",
            children: i ? d.jsxs("div", {
                className: "flex items-center h-[3.25rem] gap-3",
                children: [d.jsx("button", {
                    type: "button",
                    onClick: async () => {
                        c.mutate({
                            id: e.blobId
                        }, {
                            onSuccess() {
                                l(!0),
                                a(!1)
                            },
                            onError() {
                                ke.error("Failed to delete item")
                            }
                        })
                    }
                    ,
                    disabled: c.isPending,
                    className: "opacity-75 hover:opacity-100 px-2 py-1 bg-red-50 text-red-700 rounded",
                    children: "Yes, delete it"
                }), d.jsx("button", {
                    type: "button",
                    onClick: () => a(!1),
                    disabled: c.isPending,
                    className: "opacity-75 hover:opacity-100 px-2 py-1",
                    children: "Cancel"
                })]
            }) : d.jsx(at, {
                variant: "filled",
                bg: "red",
                className: "hidden group-hover:flex !min-w-0",
                onClick: () => {
                    a(!0)
                }
                ,
                children: d.jsx(sv, {})
            })
        }), d.jsxs(Kt, {
            to: {
                pathname: "/store",
                search: s.toString()
            },
            className: "w-full group",
            children: [d.jsxs(rl, {
                borderProps: {
                    shape: "square",
                    strokeWidth: 10,
                    className: fe(o && "!text-red-500", e.blobType === "item" && "text-[#E9FCDD] group-hover:text-[#7AE137]", e.blobType === "building" && "text-purp-50 group-hover:text-purp-400", e.blobType === "avatar" && "text-[#C2E4F1] group-hover:text-[#30A0C9]")
                },
                className: "p-6 flex items-center justify-center w-full aspect-square relative",
                children: [d.jsx("img", {
                    src: e.thumbnailUrl ?? "",
                    alt: "Store item thumbnail",
                    className: "block w-full",
                    loading: "lazy"
                }), t && d.jsx("p", {
                    className: "opacity-50 group-hover:opacity-100 absolute bottom-4 left-6 capitalize truncate",
                    "aria-label": "Category",
                    children: e.blobType === "item" ? "Blob" : e.blobType
                }), e.blobSealedAt && d.jsx("img", {
                    src: "/sealed.png",
                    alt: "Sealed blob badge",
                    className: "absolute -bottom-2 -right-2 w-2/5 -rotate-6 block drop-shadow-sm"
                })]
            }), d.jsxs("div", {
                className: "px-3 mt-1",
                children: [o ? d.jsx("p", {
                    className: "text-red-700 break-words min-w-0 truncate",
                    children: e.name ? e.name.substring(0, 36) : "Nameless"
                }) : d.jsx("p", {
                    className: fe(!e.name && "opacity-50 italic min-w-0 truncate line-clamp-2"),
                    children: e.name ? e.name.substring(0, 36) : "Nameless"
                }), d.jsx("p", {
                    className: "mt-1 break-words flex items-center overflow-hidden",
                    children: d.jsx("span", {
                        className: "opacity-75 min-w-0 truncate",
                        children: e.seller.displayName
                    })
                }), d.jsxs("p", {
                    className: "flex items-center mt-2",
                    children: [d.jsx(tl, {
                        className: "w-5 h-5 mr-2"
                    }), e.price]
                })]
            })]
        })]
    }, e.id))
}
const Uq = 100;
u.object({
    name: u.string().optional(),
    type: gs.optional(),
    sellerId: u.string().optional(),
    sellerUsername: u.string().optional(),
    isMaxBalance: u.boolean().optional()
});
function Vq() {
    var x;
    const e = jt()
      , [t,r] = ir()
      , n = t.get("productId")
      , s = gs.safeParse(t.get("type"))
      , i = t.get("sellerId") ?? void 0
      , a = t.get("name") ?? void 0
      , o = t.get("sellerUsername") ?? void 0
      , l = t.get("isMaxBalance") === "true"
      , c = t.get("isSealed") === "true"
      , f = dc({
        resolver: fc(qA),
        defaultValues: {
            name: a,
            sellerId: i,
            sellerUsername: o,
            isMaxBalance: l,
            isSealed: c
        }
    });
    g.useEffect( () => () => {
        e.removeQueries({
            queryKey: ["products"]
        }),
        hr.hiddenProducts.clear()
    }
    , [e]),
    g.useEffect( () => {
        i && (t.delete("sellerUsername"),
        r(t))
    }
    , [i, t, r]);
    const h = g.useMemo( () => ({
        limit: Uq,
        type: s.success ? s.data : void 0,
        name: a,
        sellerId: i,
        sellerUsername: o,
        isMaxBalance: l,
        isSealed: c
    }), [s, a, i, o, l, c])
      , m = Gk(h)
      , y = [{
        label: "All",
        isActive: !s.success,
        onClick: w => {
            w.preventDefault(),
            t.delete("type"),
            r(t)
        }
    }, {
        label: "Avatars",
        isActive: s.success && s.data === "avatar",
        onClick: w => {
            w.preventDefault(),
            t.set("type", "avatar"),
            r(t)
        }
    }, {
        label: "Blobs",
        isActive: s.success && s.data === "item",
        onClick: w => {
            w.preventDefault(),
            t.set("type", "item"),
            r(t)
        }
    }];
    function k(w) {
        for (const v in w) {
            const p = w[v];
            if (!p) {
                t.delete(v);
                continue
            }
            t.set(v, p)
        }
        r(t),
        e.invalidateQueries({
            queryKey: ["products"]
        })
    }
    return d.jsxs(d.Fragment, {
        children: [d.jsxs("section", {
            className: "flex flex-1 w-full h-full",
            children: [d.jsxs("div", {
                className: "flex flex-col w-72 bg-gray-50",
                children: [d.jsxs("div", {
                    className: "mt-6",
                    children: [d.jsx("div", {
                        className: "flex flex-col items-start gap-1 text-xl",
                        children: y.map(w => d.jsxs("button", {
                            type: "button",
                            className: fe("flex items-center w-full text-left pl-10 py-3", w.isActive ? "bg-white" : "opacity-50 hover:opacity-100"),
                            onClick: w.onClick,
                            children: [w.isActive && d.jsx("span", {
                                className: "block rounded-full bg-lime-400 w-2 h-2 mr-3"
                            }), w.label]
                        }, w.label))
                    }), d.jsxs("form", {
                        onSubmit: f.handleSubmit(k),
                        className: "flex flex-col gap-2 mt-4 pt-6 border-t border-gray-300 px-6",
                        children: [d.jsx(Dn, {
                            control: f.control,
                            name: "name",
                            render: ({field: w}) => d.jsx(pi, {
                                ...w,
                                type: "search",
                                placeholder: "Item name",
                                defaultValue: a,
                                maxLength: 36
                            })
                        }), !i && d.jsx(Dn, {
                            control: f.control,
                            name: "sellerUsername",
                            render: ({field: w}) => d.jsx(pi, {
                                ...w,
                                type: "search",
                                placeholder: "Seller name",
                                defaultValue: o,
                                maxLength: 36
                            })
                        }), d.jsxs("div", {
                            className: "my-2",
                            children: [d.jsx(Dn, {
                                control: f.control,
                                name: "isSealed",
                                render: ({field: {value: w, ...v}}) => d.jsxs(g1, {
                                    className: "group flex items-center gap-3 my-2 ml-2",
                                    children: [d.jsx(Rf, {
                                        ...v,
                                        defaultSelected: c
                                    }), d.jsx("p", {
                                        className: "text-xl text-gray-700",
                                        children: "Only sealed blobs"
                                    })]
                                })
                            }), d.jsx(Dn, {
                                control: f.control,
                                name: "isMaxBalance",
                                render: ({field: {value: w, ...v}}) => d.jsxs(g1, {
                                    className: "group flex items-center gap-3 my-2 ml-2",
                                    children: [d.jsx(Rf, {
                                        ...v,
                                        defaultSelected: l
                                    }), d.jsx("p", {
                                        className: "text-xl text-gray-700",
                                        children: "Only blobs I can afford"
                                    })]
                                })
                            })]
                        }), d.jsx(at, {
                            variant: "filled",
                            bg: "purple",
                            children: "Search"
                        })]
                    })]
                }), d.jsx(q_, {})]
            }), d.jsxs("div", {
                className: "flex-1 flex flex-col",
                children: [d.jsx(Fq, {
                    onRefresh: () => m.refresh(),
                    refreshDisabled: m.isFetching || !m.isStale
                }), m.isLoading && d.jsx("div", {
                    className: "flex items-center justify-center flex-1",
                    children: d.jsx(ar, {
                        size: "lg"
                    })
                }), !m.isLoading && d.jsx("div", {
                    className: "relative flex-1 overflow-hidden",
                    children: d.jsxs("div", {
                        className: "absolute top-0 right-0 bottom-0 left-0 overflow-auto",
                        children: [d.jsx("ul", {
                            className: "grid justify-start grid-cols-2 lg:grid-cols-3 xl:grid-cols-5 gap-4 lg:gap-6 p-10",
                            children: (x = m.data) == null ? void 0 : x.pages.map(w => w.ok ? d.jsx(g.Fragment, {
                                children: w.value.items.map(v => d.jsx(zq, {
                                    item: v
                                }, v.id))
                            }, w.value.nextCursor) : null)
                        }), d.jsx(W_, {
                            onIntersect: m.fetchNextPage,
                            isLoading: m.isFetchingNextPage,
                            disabled: !m.hasNextPage
                        })]
                    })
                })]
            })]
        }), n && d.jsx(Lq, {
            id: n
        })]
    })
}
const Bq = P7([{
    path: "/",
    element: d.jsx(G8, {}),
    children: [{
        path: "/",
        element: d.jsx(B8, {}),
        children: [{
            path: "/",
            element: d.jsx(QW, {})
        }, {
            path: "/login",
            element: d.jsx(Tq, {})
        }]
    }, {
        path: "/",
        element: d.jsx(U8, {}),
        children: [{
            path: "/inventory",
            element: d.jsx(_q, {})
        }, {
            path: "/inventory/lost-found",
            element: d.jsx(XW, {})
        }, {
            path: "/inventory/for-sale",
            element: d.jsx(JW, {})
        }, {
            path: "/store",
            element: d.jsx(Vq, {})
        }, {
            path: "/friends",
            element: d.jsx(ZW, {})
        }, {
            path: "/friends/requests",
            element: d.jsx(HW, {})
        }, {
            path: "/people",
            element: d.jsx(Cq, {})
        }, {
            path: "/profile",
            element: d.jsx(Iq, {})
        }, {
            path: "/admin",
            element: d.jsx(WW, {}),
            children: [{
                path: "/admin/reports",
                element: d.jsx(UW, {}),
                children: [{
                    path: "/admin/reports/:id",
                    element: d.jsx(oB, {})
                }]
            }, {
                path: "/admin/inventories",
                element: d.jsx(rU, {})
            }, {
                path: "/admin/lost-found",
                element: d.jsx(iB, {})
            }, {
                path: "/admin/users",
                element: d.jsx(BW, {})
            }]
        }]
    }]
}])
  , Wq = new jL({
    defaultOptions: {
        mutations: {
            retry: !1
        },
        queries: {
            retry: !1,
            staleTime: 1e3 * 5
        }
    }
})
  , qq = "wss://blobtown-prod-ws.fly.dev"
  , Hq = new u9({
    url: qq
});
function Zq() {
    return d.jsxs(d.Fragment, {
        children: [d.jsxs(AL, {
            client: Wq,
            children: [d.jsxs(g8, {
                value: Hq,
                children: [d.jsx(A7, {
                    router: Bq
                }), d.jsx(b8, {}), d.jsx(y8, {})]
            }), d.jsx(Kq, {})]
        }), d.jsx(X9, {
            position: "top-center",
            toastOptions: {
                className: "!rounded !shadow-lg border border-zinc-100"
            }
        }), d.jsx("div", {
            className: "fixed top-0 left-0 right-0 bottom-0 border-[8px] border-white z-[99] pointer-events-none rounded"
        })]
    })
}
function Kq() {
    const e = Dy();
    return d.jsx("div", {
        className: fe("fixed top-0 right-0 bottom-0 left-0 bg-white bg-opacity-50 z-[99] items-center justify-center transition-all", e.isLockingAction ? "flex" : "hidden"),
        children: d.jsx(ar, {
            size: "lg"
        })
    })
}
Jk(document.getElementById("root")).render(d.jsx(Zq, {}));
export {H8 as _, d as j, Wd as o, g as r, jt as u};
